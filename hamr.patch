diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/Config source/Grid/GridMain/paramesh/Config
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/Config	2021-02-23 18:16:25.705283106 -0500
+++ source/Grid/GridMain/paramesh/Config	2021-02-19 18:01:48.483737366 -0500
@@ -14,7 +14,7 @@
 ENDIF
 
 # interpolation comes after paramesh4 source while linking so it can override!
-CHILDORDER paramesh4 interpolation
+CHILDORDER multiresolution paramesh4 interpolation
 
 CONFLICTS IO/IOMain/hdf5/parallel/UG
 CONFLICTS IO/IOMain/hdf5/serial/UG
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90 source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90	2021-02-23 18:16:43.503797933 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90	2021-02-23 16:52:08.777949847 -0500
@@ -25,8 +25,18 @@
 !!  SIDE EFFECTS
 !!
 !!    Particle positions may be initialized, see DESCRIPTION above.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
+
+
+
 #define DEBUG_PARTICLES
 
 subroutine gr_expandDomain (particlesInitialized)
@@ -236,5 +246,8 @@
 
   call gr_ensureValidNeighborInfo(10)
 
+  ! if the mesh changed, need to recompute the MR mask(s)
+  call wvlt_encodeMesh()
+
   return
 end subroutine gr_expandDomain
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90	2021-02-23 18:16:43.503797933 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90	2021-02-23 16:52:28.000511829 -0500
@@ -21,6 +21,13 @@
 !!
 !! MODIFIED AD:05/19/04
 !!   
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 !!REORDER(5):scratch, scratch_ctr, scratch_facevar[xyz], gr_[xyz]flx
@@ -152,6 +159,7 @@
   real, save :: gr_smallx
 
   integer, save :: gr_numRefineVars, gr_numRefineVarsMax
+  integer, save :: gr_numWvltRefineVars
   integer,allocatable,dimension(:) ,save :: gr_refineVars
   real ,save :: gr_imin,gr_imax,gr_jmin,gr_jmax,gr_kmin,gr_kmax
   real, save, dimension(LOW:HIGH,MDIM) :: gr_globalDomain
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90	2021-02-23 16:53:13.648846365 -0500
@@ -14,6 +14,12 @@
 !!
 !!  Deallocates memory allocated in the Grid Unit to prepare for shutdowns
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 subroutine Grid_finalize()
@@ -25,6 +31,7 @@
   use Grid_data, ONLY : gr_gsurr_blks
 #endif
   use gr_sbInterface, ONLY: gr_sbFinalize
+  use wvlt_interface, ONLY: wvlt_finalize
 
   implicit none
 
@@ -34,6 +41,7 @@
   if(allocated(gr_gsurr_blks))deallocate(gr_gsurr_blks)
 #endif
 
+  call wvlt_finalize()
   call gr_ptFinalize()
   call gr_solversFinalize()
   call gr_bcFinalize()
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90	2021-02-23 18:16:43.503797933 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90	2021-02-23 16:53:25.165183044 -0500
@@ -113,6 +113,13 @@
 !! z_refine_center [REAL]
 !!
 !! gr_restrictAllMethod [INTEGER]
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 !!REORDER(5):scratch, scratch_ctr, scratch_facevar[xyz], gr_[xyz]flx
@@ -131,6 +138,7 @@
   use Simulation_interface, ONLY : Simulation_mapStrToInt, Simulation_getVarnameType
   use Grid_interface, only: Grid_getVarNonRep
   use paramesh_comm_data, ONLY : amr_mpi_meshComm
+  use wvlt_interface, ONLY : wvlt_init
 !  use gr_sbInterface, ONLY: gr_sbInit
   implicit none
 
@@ -423,6 +431,9 @@
 
   call RuntimeParameters_get("gr_restrictAllMethod", gr_restrictAllMethod)
 
+  ! initialize multiresolution module
+  call wvlt_init()
+
 #ifdef FLASH_PARTICLES
   call RuntimeParameters_get('useParticles',gr_useParticles)
   call RuntimeParameters_get('pt_maxPerProc',gr_maxParticlesPerProc)
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90	2021-02-23 16:53:53.277004886 -0500
@@ -38,6 +38,11 @@
 !! module Grid_data (in file Grid_data.F90). The other variables
 !! are local to the specific routines and do not have the prefix "gr_"
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
 !!***
 
@@ -128,6 +133,9 @@
   end if
 #endif
 
+  ! call wavelet transform and block tagging
+  call Grid_markWaveletRefineDerefine()
+  
   if(gr_refineOnParticleCount)call gr_ptMarkRefineDerefine()
 
   if(gr_enforceMaxRefinement) call gr_enforceMaxRefine(gr_maxRefine)
@@ -144,7 +152,7 @@
      refine(:)   = .false.
      derefine(:) = .false.
   end where
-  
+
   return
 end subroutine Grid_markRefineDerefine
 
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90	2021-02-23 16:57:08.875722974 -0500
@@ -0,0 +1,165 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/Grid_markWaveletRefineDerefine.F90
+!!
+!! NAME
+!!
+!!  Grid_markWaveletRefineDerefine
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!  Flags blocks for refinement or coarsening depending on the multiresolution
+!!  mask.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine Grid_markWaveletRefineDerefine()
+
+  use tree
+  use paramesh_dimensions
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, Grid_getBlkIndexLimits
+  use wvlt_data, ONLY : wvlt_numRefineVars
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! local vars
+  character(len=1024) :: filename
+  logical :: exist
+  logical :: test, expandBuffer
+  integer :: nstep
+  integer :: lb, l, i, j, k, p, bs
+  integer :: ilo, ihi, jlo, jhi, a, b, c
+  logical, dimension(NUNK_VARS) :: gcMask = .false.
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, pointer :: solnData(:,:,:,:) 
+
+  ! check if refinement variables are present
+  if ( wvlt_numRefineVars > 0 ) then
+
+    !------- clear mask everywhere -------!
+
+    ! loop through blocks
+    do lb = 1, MAXBLOCKS
+
+      ! get a pointer to solution data 
+      call Grid_getBlkPtr(lb, solnData)
+
+      ! evaluate mask for refinement
+      solnData(MSK1_VAR,:,:,:) = 0.e0
+      solnData(MSK2_VAR,:,:,:) = 0.e0
+      solnData(MSKA_VAR,:,:,:) = 0.e0
+      solnData(MSKB_VAR,:,:,:) = 0.e0
+      solnData(WVLT_VAR,:,:,:) = 0.e0
+
+      ! release pointer
+      call Grid_releaseBlkPtr(lb, solnData)
+
+    enddo
+
+    !------- perform the multiresolution encoding procedure -------!
+
+    ! call multiresolution encoding procedure
+    call wvlt_encodeMesh()
+  
+    !------- set refine/coarsen flags -------!
+
+    ! initialize these
+    refine(:) = .false.
+    derefine(:) = .false.
+    stay(:) = .false.
+
+    ! loop through blocks
+    do lb = 1, lnblocks
+
+      ! only analyze leaf blocks
+      if (nodetype(lb).eq.LEAF) then
+
+        ! get a pointer to solution data 
+        call Grid_getBlkPtr(lb, solnData)
+
+        ! get block dimensions
+        call Grid_getBlkIndexLimits(lb, blkLimits, blkLimitsGC)
+
+        ! evaluate mask for refinement
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            if (solnData(MSK1_VAR,i,j,1).gt.0.0e0) then
+              refine(lb) = .true.
+              stay(lb) = .false.
+            endif
+           enddo
+        enddo
+
+        ! evaluate mask for derefinement 
+        test = .true.
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            if (solnData(MSK2_VAR,i,j,1).gt.0.0e0) test = .false.
+          enddo
+        enddo
+        if (test) then
+          derefine(lb) = .true.
+          stay(lb) = .false.
+        endif
+
+        ! clear pointer
+        call Grid_releaseBlkPtr(lb,solnData)
+
+      endif ! if active block
+
+    enddo
+
+  else
+
+    ! no behavior, so as not to override other refinement criteria
+
+    !!!! loop through all local blocks
+    !!!do lb = 1, lnblocks
+
+    !!!  ! ensure no refinement/coarsening
+    !!!  stay(lb) = .true.
+    !!!  derefine(lb) = .false.
+    !!!  refine(lb) = .false.
+
+    !!!enddo
+
+  endif
+
+end subroutine Grid_markWaveletRefineDerefine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90	2021-02-23 16:55:58.671670682 -0500
@@ -36,6 +36,12 @@
 !!  time  : current evolution time
 !!  gridChanged : returns TRUE if grid may actually have changed.
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 
@@ -48,6 +54,7 @@
   use gr_interface, ONLY : gr_updateRefinement
   use paramesh_interfaces, ONLY : amr_restrict
   use Logfile_interface, ONLY : Logfile_open,Logfile_close
+  use wvlt_data, ONLY: wvlt_useSolverAdaptivity, wvlt_printDiagnostic
  
 !!$  use tree, ONLY : newchild, lnblocks
 !!$  use paramesh_interfaces, ONLY : amr_refine_derefine, &
@@ -78,7 +85,6 @@
   !particles.  If particles are not included, this routine will be a stub
   call gr_ptFillBlkParticleInfo()
   
-  
   ! We only consider refinements every nrefs timesteps.
   if (mod(nstep, gr_nrefs) == 0) then
      
@@ -97,6 +103,10 @@
      
      call gr_updateRefinement(gridChanged)
 
+     ! if the mesh changed, need to recompute the MR mask(s) when using
+     ! solver-adaptivity
+     if ((wvlt_useSolverAdaptivity.or.wvlt_printDiagnostic).and.gridChanged) &
+       call wvlt_encodeMesh()
 
   else
      if (present(gridChanged)) gridChanged = .FALSE.
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Makefile source/Grid/GridMain/paramesh/multiresolution/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Makefile	2021-02-19 15:51:14.497790093 -0500
@@ -0,0 +1 @@
+Grid +=	Grid_markWaveletRefineDerefine.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Config source/Grid/GridSolvers/Multiresolution/Config
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Config	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/Config	2021-02-19 18:04:38.736617958 -0500
@@ -0,0 +1,37 @@
+# this module requires paramesh, plus some modified paramesh files
+REQUIRES ../../GridMain/paramesh/multiresolution
+REQUIRES ../../GridMain/paramesh/paramesh4
+
+# required for amr
+PARAMETER wvlt_thresh  		  REAL	    0.e0 [0.e0 to ]
+PARAMETER wvlt_userelative 	BOOLEAN	  false  
+PARAMETER wvlt_nbuffer 	    INTEGER	  1 [0 to ]
+PARAMETER wvlt_maxlvl  		  INTEGER	  3 [3 to 3]
+PARAMETER wvlt_diagnostic   BOOLEAN   true
+PARAMETER wvlt_refine_var_1 STRING    "none"
+PARAMETER wvlt_refine_var_2 STRING    "none"
+PARAMETER wvlt_refine_var_3 STRING    "none"
+PARAMETER wvlt_refine_var_4 STRING    "none"
+PARAMETER wvlt_refine_var_5 STRING    "none"
+PARAMETER wvlt_refine_var_6 STRING    "none"
+
+# required for solver adaptivity
+PARAMETER wvlt_threshfactor           REAL	0.e0 [0.e0 to ]
+PARAMETER wvlt_interphydro 	          BOOLEAN	false
+PARAMETER wvlt_interpeos 	            BOOLEAN	false
+PARAMETER wvlt_interpburn 	          BOOLEAN	false
+
+# mask construction modes
+PPDEFINE AMR 1
+PPDEFINE SA 2
+
+# variables for parallel construction of mask
+VARIABLE MSK1
+VARIABLE MSK2
+VARIABLE WVLT
+
+# solver adaptive mask variables
+#IF withHAMR
+VARIABLE MSKA
+VARIABLE MSKB
+#D ENDIF
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Makefile source/Grid/GridSolvers/Multiresolution/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/Makefile	2021-02-19 17:42:37.336837990 -0500
@@ -0,0 +1,15 @@
+Grid +=	wvlt_data.o \
+				wvlt_interface.o \
+				wvlt_init.o \
+				wvlt_finalize.o \
+				wvlt_encodeMesh.o \
+				wvlt_encodeBlock.o \
+				wvlt_buildMask.o \
+				wvlt_expandBuffer.o \
+				wvlt_decomp1D.o \
+				wvlt_decomp2D.o \
+				wvlt_transform1D.o \
+				wvlt_transform2D.o \
+				wvlt_buildHydroMask.o \
+				wvlt_buildSourceMask.o \
+				wvlt_decompInterior.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90	2021-02-23 16:11:21.368291079 -0500
@@ -0,0 +1,225 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90
+!!
+!! NAME
+!!
+!!  wvlt_buildHydroMask
+!!
+!! DESCRIPTION
+!!
+!!  Precomputes the split hydro flux interpolation mask when the
+!!  mrppm_simplemask option is set to true. The fluxes in this case are computed
+!!  at a base level, lstart, of the local MR hierarchy, and then interpolated at
+!!  all finer levels. 
+!!
+!! ARGUMENTS
+!!
+!!  blockID - the local block ID on which the sweep level(s) are to be determined 
+!!
+!! RESULT
+!!
+!!  The array hydroSweepLvl.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_buildHydroMask(blockID)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt, &
+                          blkLimits, solnPtr, hydroSweepLvl
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: blockID
+
+  ! local
+  logical :: flag1, flag2
+  integer :: l, i, j, k
+  integer :: ip, jp, kp, lstart
+  integer :: ivar
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(blockID,solnPtr)
+
+#if NDIM == 1
+
+  ! starting level is native grid level by default
+  lstart = wvlt_maxLvl
+
+  ! determine which multiresolution level is active
+  flag1 = .false.
+  flag2 = .true.
+  do while((.not.flag1).and.(lstart.ne.1))
+
+    ! level to analyze coefficients on
+    l = lstart-1
+
+    ! mask variable in 'unk'
+    if (l.eq.(wvlt_maxLvl-1)) then
+      ivar = MSKA_VAR
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      ivar = MSKB_VAR
+    endif
+
+    ! loop through cells
+    do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+      ! check if cell is active
+      if (solnPtr(ivar,i,1,1).gt.0.e0) then
+        flag2 = .false.
+        exit
+      endif
+    enddo
+    if (flag2) then
+      lstart = lstart - 1
+    else
+      flag1 = .true.
+    endif
+  enddo
+
+  ! set value of lstart for this block
+  hydroSweepLvl(1,1,1,blockID) = lstart
+
+#endif
+
+#if NDIM == 2
+
+  ! loop through IAXIS to get JAXIS values
+  do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+    ! starting level is native grid level by default
+    lstart = wvlt_maxLvl
+
+    ! determine which multiresolution level is active
+    flag1 = .false. ! stops the loop
+    flag2 = .true.  ! false if significant mask value found
+    do while((.not.flag1).and.(lstart.ne.1))
+
+      ! level to analyze coefficients on
+      l = lstart-1
+
+      ! mask variable in 'unk'
+      if (l.eq.(wvlt_maxLvl-1)) then
+        ivar = MSKA_VAR
+      elseif (l.eq.(wvlt_maxLvl-2)) then
+        ivar = MSKB_VAR
+      endif
+
+      ! loop through JAXIS with fixed i and determine lstart
+      do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+        if (solnPtr(ivar,i,j,1).gt.0.e0) then
+          flag2 = .false.
+          exit
+        endif
+      enddo
+
+      ! check flags
+      if (flag2) then
+
+        ! decrement lstart
+        lstart = lstart - 1
+
+      else
+
+        ! in this case, significant mask value found, set flag1 to true so the
+        ! loop stops
+        flag1 = .true.
+
+      endif
+
+    enddo
+
+    ! set value of lstart
+    hydroSweepLvl(i,JAXIS,1,blockID) = lstart
+
+  enddo
+
+  ! loop through JAXIS to get IAXIS values
+  do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+
+    ! starting level is native grid level by default
+    lstart = wvlt_maxLvl
+
+    ! determine which multiresolution level is active
+    flag1 = .false.
+    flag2 = .true.
+    do while((.not.flag1).and.(lstart.ne.1))
+
+      ! set mask level
+      l = lstart - 1
+
+      ! mask variable in 'unk'
+      if (l.eq.(wvlt_maxLvl-1)) then
+        ivar = MSKA_VAR
+      elseif (l.eq.(wvlt_maxLvl-2)) then
+        ivar = MSKB_VAR
+      endif
+
+      ! loop through IAXIS with fixed j
+      do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+        if (solnPtr(ivar,i,j,1).gt.0.e0) then
+          flag2 = .false.
+          exit
+        endif
+      enddo
+
+      ! check flags
+      if (flag2) then
+
+        ! decrement lstart
+        lstart = lstart - 1
+
+      else
+
+        ! in this case, significant mask value found, set flag1 to true so the
+        ! loop stops
+        flag1 = .true.
+
+      endif
+
+    enddo
+
+    ! set value of lstart
+    hydroSweepLvl(j,IAXIS,1,blockID) = lstart
+
+  enddo
+
+#endif
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(blockID,solnPtr)
+
+end subroutine wvlt_buildHydroMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90	2021-02-23 16:11:32.608620634 -0500
@@ -0,0 +1,299 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90
+!!
+!! NAME
+!!
+!!  wvlt_buildMask
+!!
+!! DESCRIPTION
+!!
+!!  Constructs the multiresolution (MR) mask after the computation of detail
+!!  coefficients on the provided leaf block. The MR mask associated with the
+!!  local MR hierarchy is stored by level in grid variables MSK1_VAR and
+!!  MSK2_VAR. If the number of levels in the local MR hierarchy is greater than
+!!  three, more grid variables can be added, but are not necessary for the
+!!  purposes of AMR.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  blockID - the local block ID on which to construct the mask
+!!  detailCoeffs - array of detail coefficient values
+!!
+!! RESULT
+!!
+!!  The initial mask associated with the local MR hierarchy.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+
+subroutine wvlt_buildMask(numCells, numLvls, blockID, detailCoeffs)
+  
+  use tree, ONLY : lrefine
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt, &
+                          wvlt_threshold, parentCellIndices1, &
+                          parentCellIndices2, parentCellIndices3, &
+                          blkLimits, solnPtr, wvlt_useRelative, &
+                          wvlt_threshFactor, wvlt_printDiagnostic
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: numCells, numLvls, blockID
+#if NDIM == 1
+  real, dimension(numCells, 1, 1, numLvls), intent(inout) :: detailCoeffs
+#elif NDIM == 2
+  real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+#endif
+
+  ! local 
+  integer :: l, i, j, k, var, ivar
+  integer :: ii, jj, kk, lvl, ip, jp, kp
+  real :: tol, dereftol, interptol
+  real :: mskval
+  integer, dimension(iCellsInt(wvlt_maxLvl)) :: parentCellIndices
+#if NDIM == 1
+  logical, dimension(numCells, 1, 1, numLvls) :: mask
+  logical, dimension(numCells, 1, 1, numLvls) :: maskdrf
+  logical, dimension(numCells, 1, 1, numLvls) :: maskinterp
+#elif NDIM == 2
+  logical, dimension(numCells, numCells, 1, numLvls) :: mask
+  logical, dimension(numCells, numCells, 1, numLvls) :: maskdrf
+  logical, dimension(numCells, numCells, 1, numLvls) :: maskinterp
+#endif
+
+  ! initialize data
+  mask = .false.
+  maskdrf = .false.
+  maskinterp = .false.
+
+  ! get current level of block
+  lvl = lrefine(blockID)
+
+  ! compute tolerance
+  tol = wvlt_threshold(lvl)
+
+  ! loop through levels
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! derefinement tolerance + interptol
+    dereftol = tol
+    interptol = tol * wvlt_threshFactor
+
+    ! loop through interior cells
+#if NDIM == 1
+    do i = 1, iCellsInt(l)
+ 
+      ! refinement mask
+      if (l.eq.(wvlt_maxLvl-1)) then
+        if ((detailCoeffs(2*i-1,1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,1,1,l+1).ge.tol)) then
+
+          ! set mask to true in this location
+          mask(i,1,1,l) = .true.
+
+        endif
+      endif
+
+      ! derefinement mask
+      if (l.eq.(wvlt_maxLvl-2)) then
+        if ((detailCoeffs(2*i-1,1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,1,1,l+1).ge.dereftol)) then
+
+          ! set mask to true in this location
+          maskdrf(i,1,1,l) = .true.
+
+        endif
+      endif
+
+      ! interpolation mask
+      if ((detailCoeffs(2*i-1,1,1,l+1).ge.interptol) &
+          .or.(detailCoeffs(2*i,1,1,l+1).ge.interptol)) then
+
+        ! set mask to true in this location
+        maskinterp(i,1,1,l) = .true.
+
+      endif
+
+    enddo
+
+    ! compute tolerance update
+    tol = 0.5e0 * tol
+
+#elif NDIM == 2
+    do j = 1, jCellsInt(l)
+      do i = 1, iCellsInt(l)
+ 
+        ! if detail coefficient is significant put its neighbors in mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.tol)) then
+
+          ! set mask to true in this location
+          mask(i,j,1,l) = .true.
+
+        endif
+
+        ! if detail coefficient is significant put its neighbors in mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.dereftol)) then
+
+          ! set mask to true in this location
+          maskdrf(i,j,1,l) = .true.
+
+        endif
+
+        ! interpolation mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.interptol)) then
+
+          ! set mask to true in this location
+          maskinterp(i,j,1,l) = .true.
+
+        endif
+
+      enddo
+    enddo
+
+    ! compute tolerance update
+    !tol = 0.25e0 * tol
+    tol = 0.5e0 * tol
+
+#endif
+
+  enddo
+
+  !------- refinement / derefinement mask -------!
+
+  ! store the mask in 'unk'
+  do l = wvlt_maxLvl-1, 1, -1
+
+!!!#if NDIM == 1
+!!!    mskval = 1.e0
+!!!#elif NDIM == 2
+!!!    mskval = real(lvl)
+!!!#endif
+    mskval = real(lvl)
+
+    ! get mask variable in unk
+    if (l.eq.(wvlt_maxLvl-1)) then
+      var = MSK1_VAR
+      ivar = MSKA_VAR
+      parentCellIndices = parentCellIndices1
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      var = MSK2_VAR
+      ivar = MSKB_VAR
+      parentCellIndices = parentCellIndices2
+    endif
+
+    ! nullify solutiondata
+    solnPtr(var,:,:,:) = 0.0e0
+    solnPtr(ivar,:,:,:) = 0.0e0
+
+    ! loop through interior cells, check refinement mask
+    if (l.eq.(wvlt_maxLvl-1)) then
+      do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+        kp = parentCellIndices(max(k-4,1))
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          jp = parentCellIndices(max(j-4,1))
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            ip = parentCellIndices(i-4)
+
+            ! set solnData's mask
+            if (mask(ip,jp,kp,l)) &
+              solnPtr(var,i,j,k) = mskval
+
+          enddo
+        enddo
+      enddo
+    endif
+
+    ! check derefinement mask
+    if (l.eq.(wvlt_maxLvl-2)) then
+      do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+        kp = parentCellIndices(max(k-4,1))
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          jp = parentCellIndices(max(j-4,1))
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            ip = parentCellIndices(i-4)
+
+            ! derefinement trick
+            if (maskdrf(ip,jp,kp,l)) &
+              solnPtr(MSK2_VAR,i,j,k) = mskval
+
+          enddo
+        enddo
+      enddo
+    endif
+
+    ! check interpolation mask
+    do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+      kp = parentCellIndices(max(k-4,1))
+      do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+        jp = parentCellIndices(max(j-4,1))
+        do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+          ip = parentCellIndices(i-4)
+
+          ! set solnData's mask
+          if (maskinterp(ip,jp,kp,l)) &
+            solnPtr(ivar,i,j,k) = mskval
+
+        enddo
+      enddo
+    enddo
+
+    ! store detail coefficients in mask
+    if (wvlt_printDiagnostic) then
+      if (l.eq.(wvlt_maxLvl-1)) then
+        do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+          do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+            do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+              solnPtr(WVLT_VAR,i,j,k) = detailCoeffs(i-4,max(j-4,1),max(k-4,1),l+1)
+            enddo
+          enddo
+        enddo
+      endif
+    endif
+
+  enddo
+
+end subroutine wvlt_buildMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90	2021-02-23 16:16:56.309109377 -0500
@@ -0,0 +1,159 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90
+!!
+!! NAME
+!!
+!!  wvlt_buildSourceMask
+!!
+!! DESCRIPTION
+!!
+!!  Provides a mask for the solver-adaptive equation of state (EoS) and reactive
+!!  source term calculations based on the MR mask.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  solnPtr - pointer to unk array
+!!  activeCell - logical array indicating cells to be calculated directly
+!!  interpCell - logical array indicating cells to be interpolated
+!!
+!! RESULT
+!!
+!!  Arrays activeCell and interpCell, indicating which cells to evaluate exactly
+!!  and which cells are to be interpolated from coarser levels.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_buildSourceMask(numCells, numLvls, solnPtr, activeCell, interpCell)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+#if NDIM == 1
+  logical, dimension(numCells,1,1,numLvls), intent(inout) :: activeCell
+  logical, dimension(numCells,1,1,numLvls), intent(inout) :: interpCell
+#endif
+#if NDIM == 2
+  logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: activeCell
+  logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: interpCell
+#endif
+  real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+
+  ! local
+  integer :: l, i, j, var, dl
+
+  ! clear data
+  interpCell = .false.
+  activeCell = .false.
+ 
+  do l = 1, wvlt_maxLvl-1
+
+    ! level difference
+    dl = wvlt_maxLvl - l
+
+    ! get mask variable in unk
+    if (dl.eq.1) then
+      var = MSKA_VAR
+    elseif (dl.eq.2) then
+      var = MSKB_VAR
+    endif
+
+#if NDIM == 1
+
+    do i = 1, iCellsInt(l)
+
+      ! check if cell is in mask
+      if (solnPtr(var,i*2**dl+4,1,1).gt.0.0) then
+
+        ! set this cell to false
+        activeCell(i,1,1,l) = .false.
+
+        ! set its children to true
+        activeCell(2*i-1,1,1,l+1) = .true.
+        activeCell(2*i,1,1,l+1) = .true.
+
+      else
+
+        ! check if this cell is to be interpolated, else burn it
+        if (.not.interpCell(i,1,1,l)) &
+          activeCell(i,1,1,l) = .true.
+
+        ! set children to be interpolated
+        interpCell(2*i-1,1,1,l+1) = .true.
+        interpCell(2*i,1,1,l+1) = .true.
+
+      endif
+
+    enddo
+
+#endif
+
+#if NDIM == 2
+
+    ! loop through cells at current level
+    do j = 1, jCellsInt(l)
+      do i = 1, iCellsInt(l)
+
+        ! check if cell is in mask
+        if ((solnPtr(var,i*2**dl+4,j*2**dl+4,1).gt.0.0)) then
+
+          ! set this cell to false
+          activeCell(i,j,1,l) = .false.
+
+          ! set its children to true
+          activeCell(2*i-1,2*j-1,1,l+1) = .true.
+          activeCell(2*i-1,2*j,1,l+1) = .true.
+          activeCell(2*i,2*j-1,1,l+1) = .true.
+          activeCell(2*i,2*j,1,l+1) = .true.
+
+        else
+
+          ! check if this cell is to be interpolated, else burn it
+          if (.not.interpCell(i,j,1,l)) &
+            activeCell(i,j,1,l) = .true.
+
+          ! set children to be interpolated
+          interpCell(2*i-1,2*j-1,1,l+1) = .true.
+          interpCell(2*i-1,2*j,1,l+1) = .true.
+          interpCell(2*i,2*j-1,1,l+1) = .true.
+          interpCell(2*i,2*j,1,l+1) = .true.
+
+        endif
+
+      enddo
+    enddo
+
+#endif
+
+  enddo
+
+end subroutine wvlt_buildSourceMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_data.F90 source/Grid/GridSolvers/Multiresolution/wvlt_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_data.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_data.F90	2021-02-23 18:15:50.802273555 -0500
@@ -0,0 +1,102 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_data.F90
+!!
+!! NAME
+!!
+!!  wvlt_data
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!  The module wvlt_data stores all data used by the multiresolution
+!!  subroutines.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+module wvlt_data
+
+  use tree
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  integer,  save                    :: wvlt_numRefineVars, wvlt_maxLvl
+  integer,  save                    :: totCells, totIntCells, numInterp, wvlt_bufferSize
+  integer,  save, allocatable       :: numCells(:), iCellsInt(:), jCellsInt(:), &
+                                       kCellsInt(:), mrRefineMaskVars(:), &
+                                       intCells(:), iCellsTot(:), jCellsTot(:), &
+                                       kCellsTot(:)
+  real, save :: wvlt_threshFactor
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, save, allocatable :: wvlt_threshold(:)
+  real, save, allocatable :: detailCoeffs(:), cellData(:), &
+                              cellDataInterior(:,:), detailCoeffs1D(:)
+  real, save, pointer :: solnPtr(:,:,:,:) 
+  logical, save :: wvlt_interpHydro = .false.
+  logical, save :: wvlt_interpBurn = .false.
+  logical, save :: wvlt_interpEos = .false.
+  logical, save :: wvlt_useSolverAdaptivity = .false.
+  logical, save :: wvlt_useRelative = .false.
+  logical, save :: wvlt_printDiagnostic = .false.
+  logical, save, allocatable :: fluxMask(:,:)
+  integer, save, allocatable :: numIntrfcActv(:), numFluxActv(:)
+  integer, save, allocatable :: intrfcKey(:,:), fluxKey(:,:)
+  integer, save, allocatable :: hydroSweepLvl(:,:,:,:)
+
+  integer, save, allocatable :: parentCellIndices1(:)
+  integer, save, allocatable :: parentCellIndices2(:)
+  integer, save, allocatable :: parentCellIndices3(:)
+
+  contains
+
+    function lmap( l, i ) result(x)
+
+      implicit none
+
+      integer, intent(in)   :: l, i
+      integer               :: dl, x
+
+      ! compute difference between levels
+      dl = wvlt_maxLvl - l
+
+      ! map any interface index on level l to the max level, wvlt_maxLvl
+      x = (2.0**dl)*(i-1) + 1
+      
+    end function lmap 
+
+end module wvlt_data
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90	2021-02-23 16:19:46.751104233 -0500
@@ -0,0 +1,88 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90
+!!
+!! NAME
+!!
+!!  wvlt_decomp1D
+!!
+!! DESCRIPTION
+!!
+!!  Coarsens the specified cell averaged data to the coarsest level of the local
+!!  MR hierarchy.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  varData - variable cell averaged data on the block
+!!  cellData - array with coarsened data
+!!
+!! RESULT
+!!
+!!  The coarsened variable data on all levels of the local MR hierarchy.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_decomp1D(numCells, numLvls, varData, cellData)
+
+  use wvlt_data, ONLY : iCellsTot
+
+  implicit none
+
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells), intent(in) :: varData
+  real, dimension(numCells, 1, 1, numLvls), intent(out) :: cellData
+
+  integer :: l, i, ilo, ihi
+
+  ! max level
+  l = numLvls
+
+  ilo = 1
+  ihi = iCellsTot(l)
+  do i = ilo, ihi
+    cellData(i,1,1,l) = varData(i)
+  enddo
+
+  ! decompose into hierarchy
+  do l = numLvls-1, 1, -1
+
+    ! coarsen cells
+    ilo = 1
+    ihi = iCellsTot(l)
+    do i = ilo, ihi
+      cellData(i,1,1,l) = 0.5e0*(cellData(2*i-1,1,1,l+1) + cellData(2*i,1,1,l+1))
+    enddo
+
+  end do
+
+end subroutine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90	2021-02-23 16:20:11.514829866 -0500
@@ -0,0 +1,100 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90
+!!
+!! NAME
+!!
+!!  wvlt_decomp2D
+!!
+!! DESCRIPTION
+!!
+!!  Coarsens the specified cell averaged data to the coarsest level of the local
+!!  MR hierarchy.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  varData - variable cell averaged data on the block
+!!  cellData - array with coarsened data
+!!
+!! RESULT
+!!
+!!  The coarsened variable data on all levels of the local MR hierarchy.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_decomp2D(numCells, numLvls, varData, cellData)
+
+  use wvlt_data, ONLY : iCellsTot, jCellsTot
+
+  implicit none
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells, numCells), intent(in) :: varData
+  real, dimension(numCells, numCells, 1, numLvls), intent(out) :: cellData
+
+  ! local vars
+  integer :: l, i, j, ilo, ihi, jlo, jhi
+
+  ! max level
+  l = numLvls
+
+  ! get data on block's native grid level
+  ilo = 1
+  ihi = iCellsTot(l)
+  do i = ilo, ihi
+    jlo = 1
+    jhi = jCellsTot(l)
+    do j = jlo, jhi
+      cellData(i,j,1,l) = varData(i,j)
+    enddo
+  enddo
+
+  ! decompose into hierarchy
+  do l = numLvls-1, 1, -1
+
+    ! coarsen cells
+    ilo = 1
+    ihi = iCellsTot(l)
+    do i = ilo, ihi
+      jlo = 1
+      jhi = jCellsTot(l)
+      do j = jlo, jhi
+        cellData(i,j,1,l) = 0.25e0*(cellData(2*i-1,2*j-1,1,l+1) + cellData(2*i-1,2*j,1,l+1) &
+                              + cellData(2*i,2*j-1,1,l+1) + cellData(2*i,2*j,1,l+1))
+      enddo
+    enddo
+
+  end do
+
+end subroutine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90	2021-02-23 16:24:06.690720136 -0500
@@ -0,0 +1,129 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90
+!!
+!! NAME
+!!
+!!  wvlt_decompInterior
+!!
+!! DESCRIPTION
+!!
+!!  Coarsens the specified cell averaged data on the block interior only to the
+!!  coarsest level of the local MR hierarchy. The routine is similar to 
+!!  wvlt_decomp1D and wvlt_decomp2D but is called from physics routines.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  var - variable index to retrieve from unk
+!!  solnPtr - pointer to data in unk
+!!  cellData - array with coarsened data
+!!
+!! RESULT
+!!
+!!  The coarsened block interior variable data on all levels of the local MR
+!!  hierarchy.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_decompInterior(numCells, numLvls, var, solnPtr, cellData)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, blkLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: numCells, numLvls, var
+  real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+  real :: diff, sm
+#if NDIM == 1
+  real, dimension(numCells,1,1,numLvls), intent(inout) :: cellData
+#endif
+#if NDIM == 2
+  real, dimension(numCells,numCells,1,numLvls), intent(inout) :: cellData
+#endif
+
+  ! local data
+  integer :: l, i, j, ilo, ihi, jlo, jhi
+
+  ! initialize data
+  cellData = 0.0
+
+  ! copy first level into new hierarchy data structure 
+  ilo = 1
+  ihi = iCellsInt(wvlt_maxLvl)
+  jlo = 1
+  jhi = jCellsInt(wvlt_maxLvl)
+  do i = ilo, ihi
+    do j = jlo, jhi
+      cellData(i,j,1,wvlt_maxLvl) = solnPtr(var, &
+                                                  blkLimits(LOW,IAXIS)+i-1, &
+                                                  blkLimits(LOW,JAXIS)+j-1, &
+                                                  blkLimits(LOW,KAXIS))
+    enddo
+  enddo
+
+  ! decompose into hierarchy
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! coarsen cells
+#if NDIM == 1
+    ilo = 1
+    ihi = iCellsInt(l)
+    do i = ilo, ihi
+      cellData(i,1,1,l) = 0.5e0*(cellData(2*i,1,1,l+1) + cellData(2*i-1,1,1,l+1))
+    enddo
+#endif
+
+#if NDIM == 2
+    ! coarsen cells in 2D
+    ilo = 1
+    ihi = iCellsInt(l)
+    jlo = 1
+    jhi = jCellsInt(l)
+    do i = ilo, ihi
+      do j = jlo, jhi
+        cellData(i,j,1,l) = (cellData(2*i-1,2*j-1,1,l+1) &
+                                              + cellData(2*i-1,2*j,1,l+1) &
+                                              + cellData(2*i,2*j-1,1,l+1) &
+                                              + cellData(2*i,2*j,1,l+1)) / 4.0e0
+      enddo
+    enddo
+#endif
+
+  enddo
+
+end subroutine wvlt_decompInterior
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90 source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90	2021-02-23 16:30:53.029621493 -0500
@@ -0,0 +1,108 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90
+!!
+!! NAME
+!!
+!!  wvlt_encodeBlock
+!!
+!! DESCRIPTION
+!!
+!!  Performs the multiresolution (MR) encoding procedure on the local MR
+!!  hierarchy associated with the given leaf block.
+!!
+!! ARGUMENTS
+!!
+!!  localBlkID - local block ID
+!!
+!! RESULT
+!!
+!!  Detail coefficients on the local MR hierarchy associated with the given leaf
+!!  block.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_encodeBlock(localBlkID)
+
+  use wvlt_data, ONLY : wvlt_maxLvl, wvlt_numRefineVars, mrRefineMaskVars, &
+                          iCellsTot, jCellsTot, kCellsTot, &
+                          blkLimits, blkLimitsGC, solnPtr
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, &
+                             Grid_getBlkIndexLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  integer, intent(in) :: localBlkID
+  integer :: var, nx, ny, nz
+  real, allocatable, dimension(:,:,:,:) :: details
+
+  ! number of cells on fine grid
+  nx = iCellsTot(wvlt_maxLvl)
+  ny = jCellsTot(wvlt_maxLvl)
+  nz = kCellsTot(wvlt_maxLvl)
+
+  ! allocate arrays
+  allocate(details(nx,ny,nz,wvlt_maxLvl))
+
+  ! initialize values
+  details = 0.0e0
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(localBlkID,solnPtr)
+
+  ! get block dimensions
+  call Grid_getBlkIndexLimits(localBlkID,blkLimits,blkLimitsGC)
+
+  ! loop through variables that refinement is based on
+  do var = 1, wvlt_numRefineVars
+
+    ! compute detail coefficients
+#if NDIM == 1
+    call wvlt_transform1D(nx, wvlt_maxLvl, solnPtr(mrRefineMaskVars(var),:,1,1), details)
+#elif NDIM == 2
+    call wvlt_transform2D(nx, wvlt_maxLvl, solnPtr(mrRefineMaskVars(var),:,:,1), details)
+#endif
+
+  enddo
+
+  ! once detail coefficients computed, add to mask
+  call wvlt_buildMask(nx, wvlt_maxLvl, localBlkID, details)
+
+  ! deallocate arrays
+  deallocate(details)
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(localBlkID,solnPtr)
+
+end subroutine wvlt_encodeBlock
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90 source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90	2021-02-23 16:33:58.709058437 -0500
@@ -0,0 +1,158 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90
+!!
+!! NAME
+!!
+!!  wvlt_encodeMesh
+!!
+!! DESCRIPTION
+!!
+!!  Performs the multiresolution (MR) encoding procedure for the local MR
+!!  hierarchy associated with each leaf block in the given AMR mesh. The mask is
+!!  then constructed, including the buffer region.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!!  MR mask for each leaf block.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_encodeMesh()
+
+  !use paramesh_dimensions
+  use tree
+  use Grid_interface, ONLY : Grid_fillGuardCells
+  use wvlt_data, ONLY : wvlt_numRefineVars, wvlt_maxLvl, &
+                         wvlt_interpHydro, wvlt_bufferSize, &
+                         wvlt_useSolverAdaptivity
+  use wvlt_interface, ONLY : wvlt_encodeBlock, wvlt_expandBuffer, wvlt_buildHydroMask
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! local vars
+  character(len=1024) :: filename
+  logical :: exist
+  logical :: test, expandBuffer
+  integer :: nstep
+  integer :: lb, l, i, j, k, p, bs
+  integer :: ilo, ihi, jlo, jhi, a, b, c
+  logical, dimension(NUNK_VARS) :: gcMask = .false.
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, pointer :: solnData(:,:,:,:) 
+
+  ! check if refinement variables are present
+  if ( wvlt_numRefineVars > 0 ) then
+
+    !------- ensure correct guardcell information -------!
+
+    ! MR interpolation requires correct guardcell data
+    call Grid_fillGuardCells(CENTER, ALLDIR, doEos=.false.)
+
+    !------- compute detail coefficients and initialize mask on all blocks -------!
+
+    ! loop through local blocks
+    do lb = 1, lnblocks
+
+      ! only consider leaf blocks
+      if (nodetype(lb).eq.LEAF) then
+
+        ! perform wavelet transform
+        call wvlt_encodeBlock(lb)
+
+      endif
+
+    enddo
+
+    !------- create MR mask buffer region -------!
+
+    ! set gcMask
+    gcMask(MSK1_VAR) = .true.
+    gcMask(MSK2_VAR) = .true.
+    if (wvlt_useSolverAdaptivity) then
+      gcMask(MSKA_VAR) = .true.
+      gcMask(MSKB_VAR) = .true.
+    endif
+
+    ! loop through buffer layers (advect mask one cell in every direction)
+    do p = 1, wvlt_bufferSize
+
+      ! block loop
+      do lb = 1, lnblocks
+
+        ! only analyze leaf blocks
+        if (nodetype(lb).eq.LEAF) then
+
+          ! propogate the guardcell mask information for amr mask
+          call wvlt_expandBuffer(lb, AMR)
+
+          ! propogate the guardcell mask information for interp mask
+          if (wvlt_useSolverAdaptivity) &
+            call wvlt_expandBuffer(lb, SA)
+
+        endif
+
+      enddo
+
+      ! transfer mask information
+      call Grid_fillGuardCells(CENTER, ALLDIR, doEos=.false., maskSize=NUNK_VARS, &
+                                mask=gcMask, makeMaskConsistent=.false.)
+
+    enddo
+
+    !------- for simplified split hydro mask option -------#
+
+    ! loop through local blocks
+    if (wvlt_interpHydro) then
+
+      ! loop through all blocks
+      do lb = 1, lnblocks
+
+        ! only analyze leaf blocks
+        if (nodetype(lb).eq.LEAF) then
+
+          ! for hydro module
+          call wvlt_buildHydroMask(lb)
+
+        endif
+
+      enddo
+
+    endif
+
+  endif
+
+end subroutine wvlt_encodeMesh
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90 source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90	2021-02-23 16:36:53.730182505 -0500
@@ -0,0 +1,495 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90
+!!
+!! NAME
+!!
+!!  wvlt_expandBuffer
+!!
+!! DESCRIPTION
+!!
+!!  Expands the initial mask by adding cells to the buffer region.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!!  The updated mask on the local MR hierarchy associated with the given leaf
+!!  block.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_expandBuffer(blockID, optmode)
+  
+  use wvlt_data
+  use tree, ONLY : lrefine
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, &
+                             Grid_getBlkIndexLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: blockID
+  integer, intent(in), optional :: optmode
+
+  ! local scalars
+  integer :: lvl, mode
+  integer :: l, i, j, k, var
+  integer :: ii, jj, bs, ip, jp
+  integer :: MVAR1, MVAR2
+  integer :: status = 0
+
+  ! local arrays
+  integer, dimension(iCellsInt(wvlt_maxLvl)) :: parentCellIndices
+  integer, dimension(2,MDIM) :: bufferRange
+  logical, dimension(iCellsTot(wvlt_maxLvl), jCellsTot(wvlt_maxLvl)) :: tmpmask
+
+  ! check mode, make AMR the default mode
+  if (present(optmode)) then
+    mode = optmode
+  else
+    mode = AMR
+  endif
+
+  ! determine which mask to use
+  if (mode.eq.AMR) then
+    MVAR1 = MSK1_VAR
+    MVAR2 = MSK2_VAR
+  elseif (mode.eq.SA) then
+    MVAR1 = MSKA_VAR
+    MVAR2 = MSKB_VAR
+  else
+    print *, "Incorrect mode supplied in 'wvlt_expandBuffer.' Should be 'AMR' or 'SA.'"
+    call exit(status)
+  endif
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(blockID, solnPtr)
+
+  ! get block dimensions
+  call Grid_getBlkIndexLimits(blockID, blkLimits, blkLimitsGC)
+
+  ! get current level of block
+  lvl = lrefine(blockID)
+
+  ! loop through levels
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! initialize arrays
+    tmpmask = .false.
+
+    ! get mask variable in unk
+    if (l.eq.(wvlt_maxLvl-1)) then
+      var = MVAR1
+      parentCellIndices = parentCellIndices1
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      var = MVAR2
+      parentCellIndices = parentCellIndices2
+    endif
+
+    ! size of a cell in the mask
+    !bs = 2**(wvlt_maxLvl-l)
+    bs = 1
+
+#if NDIM == 1
+
+    !------- expand interior -------!
+
+    do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+      ! check for mask information and propagate
+      if (solnPtr(var,i,1,1).gt.0.0e0) then
+
+        ! buffer range (move one mask value per call)
+        bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+        bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+        ! create buffer
+        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+          !solnPtr(var,ii,1,1) = real(lvl)
+          tmpmask(ii,1) = .true.
+        enddo
+
+      endif
+
+    enddo
+
+    !------- extend guardcell regions --------!
+
+    ! if left neighbor is at the same level
+    if (solnPtr(var,blkLimitsGC(LOW,IAXIS),1,1).eq.real(lvl)) then
+
+      ! lower block end expansion
+      do i = blkLimits(LOW,IAXIS)-1, blkLimitsGC(LOW,IAXIS), -1
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = i
+          bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+          ! extend the buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    ! left neighbor is at higher level
+    elseif (solnPtr(var,blkLimitsGC(LOW,IAXIS),1,1).eq.(real(lvl+1))) then
+
+      ! lower block end expansion
+      do i = blkLimits(LOW,IAXIS)-1, blkLimitsGC(LOW,IAXIS)+2, -1
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = i
+          bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+          ! create buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    endif
+
+    ! if right neighbor is at the same level
+    if (solnPtr(var,blkLimitsGC(HIGH,IAXIS),1,1).eq.real(lvl)) then
+
+      ! lower block end expansion
+      do i = blkLimits(HIGH,IAXIS)+1, blkLimitsGC(HIGH,IAXIS)
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = i
+
+          ! extend the buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    ! left neighbor is at higher level
+    elseif (solnPtr(var,blkLimitsGC(HIGH,IAXIS),1,1).eq.(real(lvl+1))) then
+
+      ! lower block end expansion
+      do i = blkLimits(HIGH,IAXIS)+1, blkLimitsGC(HIGH,IAXIS)-2
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = i
+
+          ! create buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    endif
+
+    ! transfer 'tmpmask' to 'unk'
+    do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+      if (tmpmask(i,1)) then
+        solnPtr(var,i,1,1) = real(lvl)
+      else
+        solnPtr(var,i,1,1) = 0.e0
+      endif
+    enddo
+
+#elif NDIM == 2
+
+    !------- expand whole block' mask region -------!
+
+    do j = blkLimitsGC(LOW,JAXIS), blkLimitsGC(HIGH,JAXIS)
+      do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+        ! check for mask information and propagate
+        if (solnPtr(var,i,j,1).gt.0.0e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+          bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+          bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+          ! create buffer
+          do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+            do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+              tmpmask(ii,jj) = .true.
+            enddo
+          enddo
+
+        endif
+
+      enddo
+    enddo
+
+
+    ! old/alternate logic is based on the neighboring block's relative
+    ! refinement level
+
+    !!!!------- expand interior -------!
+
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).gt.0.0e0) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimits(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimits(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!!------- extend guardcell regions --------!
+
+    !!!! check the lower block edge for mask
+    !!!do j = blkLimitsGC(LOW,JAXIS), blkLimits(LOW,JAXIS)
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the left block edge for mask
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimits(LOW,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the right block edge for mask
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimitsGC(HIGH,IAXIS), blkLimits(HIGH,IAXIS), -1
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the upper block edge for mask
+    !!!do j = blkLimitsGC(HIGH,JAXIS), blkLimits(HIGH,JAXIS), -1
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    !!print *, "var, i, j, solnPtr(var,i,j,1)", var, i, j, solnPtr(var,i,j,1)
+    !!!    !!print *, "real(lvl)", real(lvl)
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    ! transfer 'tmpmask' to 'unk'
+    do j = blkLimitsGC(LOW,JAXIS), blkLimitsGC(HIGH,JAXIS)
+      do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+        if (tmpmask(i,j)) then
+          solnPtr(var,i,j,1) = real(lvl)
+        else
+          solnPtr(var,i,j,1) = 0.e0
+        endif
+      enddo
+    enddo
+
+#endif
+
+  enddo
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(blockID,solnPtr)
+
+end subroutine wvlt_expandBuffer
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90 source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90	2021-02-23 16:37:51.238866015 -0500
@@ -0,0 +1,84 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90
+!!
+!! NAME
+!!
+!!  wvlt_finalize
+!!
+!! DESCRIPTION
+!!
+!!  Finalize wvlt module.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_finalize() 
+  
+  ! declare modules used
+  use wvlt_data
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
+                                          RuntimeParameters_getReal
+  use Driver_interface, ONLY : Driver_abortFlash
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  !------- deallocate memory -------!
+
+  deallocate(intCells)
+  deallocate(numCells)
+  deallocate(iCellsInt)
+  deallocate(jCellsInt)
+  deallocate(kCellsInt)
+  deallocate(iCellsTot)
+  deallocate(jCellsTot)
+  deallocate(kCellsTot)
+  deallocate(mrRefineMaskVars)
+  deallocate(wvlt_threshold)
+
+  deallocate(intrfcKey)
+  deallocate(fluxKey)
+  deallocate(fluxMask)
+  deallocate(numIntrfcActv)
+  deallocate(numFluxActv)
+
+  deallocate(parentCellIndices1)
+  deallocate(parentCellIndices2)
+  deallocate(parentCellIndices3)
+
+  deallocate(hydroSweepLvl)
+
+end subroutine wvlt_finalize
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_init.F90 source/Grid/GridSolvers/Multiresolution/wvlt_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_init.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_init.F90	2021-02-23 16:39:25.247617863 -0500
@@ -0,0 +1,350 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_init.F90
+!!
+!! NAME
+!!
+!!  wvlt_init
+!!
+!! DESCRIPTION
+!!
+!!  Initialize wvlt module.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_init() 
+
+  ! declare modules used
+  use wvlt_data 
+  use tree,             ONLY : lrefine, lrefine_min, lrefine_max
+  use Driver_interface, ONLY : Driver_abortFlash
+  use Grid_data,        ONLY : gr_meshMe, gr_domainBC, gr_numWvltRefineVars
+  use wvlt_data,        ONLY : mrRefineMaskVars, wvlt_numRefineVars
+
+  use Grid_interface,              ONLY : Grid_getLocalNumBlks, Grid_getBlkIndexLimits, &
+                                          Grid_getBlkPtr,       Grid_releaseBlkPtr
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
+                                          RuntimeParameters_getReal, &
+                                          RuntimeParameters_getLog
+  use Simulation_interface,        ONLY : Simulation_mapStrToInt, Simulation_getVarnameType
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+#include "Flash_mpi.h"
+
+  integer :: l, i, j, k, refVar, numflx, numintrfc
+  integer :: ip, jp
+  integer :: lstart, itot
+  real :: threshold
+  logical, allocatable :: tmpmask(:)
+  character(len=MAX_STRING_LENGTH),save :: refVarName, refVarString, paramString
+
+  !--------------------------------------------------------------------------------
+
+  ! refinement variable basename
+  refVarName='wvlt_refine_var_'
+
+  ! allocate space for mrRefineVars
+  allocate(mrRefineMaskVars(6))
+
+  gr_numWvltRefineVars = 0
+
+  ! loop through possible refinement choices
+  do i = 1, 6
+
+    ! concatenate string
+    call concatStringWithInt(refVarName,i,refVarString)
+    call RuntimeParameters_get(refVarString, paramString)
+
+    ! if string is not 'none'
+    if(paramString /= "none") then
+
+      ! find the identifying integer
+      call Simulation_mapStrToInt(paramString, refVar, MAPBLOCK_UNK)
+      
+      ! if integer is valid
+      if (refVar > 0) then
+
+        ! add to total
+         gr_numWvltRefineVars = gr_numWvltRefineVars + 1
+
+        ! set mrrefinevar
+        mrRefineMaskVars(i) = refVar
+
+      else
+
+        ! set mrrefinevar
+        mrRefineMaskVars(i) = 0
+
+      endif
+
+    endif
+
+  enddo
+
+  ! number of multiresolution indicator variables
+  wvlt_numRefineVars = gr_numWvltRefineVars
+
+  ! read in multiresolution parameters
+  call RuntimeParameters_getReal("wvlt_thresh", threshold)
+  call RuntimeParameters_getLog("wvlt_userelative", wvlt_useRelative)
+  call RuntimeParameters_get("wvlt_nbuffer", wvlt_bufferSize)
+  call RuntimeParameters_get("wvlt_maxlvl", wvlt_maxLvl)
+  call RuntimeParameters_get("wvlt_diagnostic", wvlt_printDiagnostic)
+  call RuntimeParameters_getReal("wvlt_threshfactor", wvlt_threshFactor)
+  call RuntimeParameters_getLog("wvlt_interphydro", wvlt_interpHydro)
+  call RuntimeParameters_getLog("wvlt_interpeos", wvlt_interpEos)
+  call RuntimeParameters_getLog("wvlt_interpburn", wvlt_interpBurn)
+
+  ! determine if solver-adaptivity is to be used
+  if (wvlt_interpHydro .or. wvlt_interpEos .or. wvlt_interpBurn) &
+    wvlt_useSolverAdaptivity = .true.
+
+  !------- wavelet threshold -------!
+
+  ! allocate memory for each level
+  allocate(wvlt_threshold(lrefine_max))
+
+  ! compute threshold on each level
+  wvlt_threshold(lrefine_max) = threshold
+  do l = lrefine_max-1, 1, -1
+#if NDIM == 1
+    wvlt_threshold(l) = 0.5e0 * wvlt_threshold(l+1)
+#endif
+#if NDIM == 2
+    !wvlt_threshold(l) = 0.25e0 * wvlt_threshold(l+1)
+    wvlt_threshold(l) = 0.5e0 * wvlt_threshold(l+1)
+#endif
+  enddo
+
+  !------- variable-independent block information -------!
+
+  ! allocate memory for block information (independent of vars)
+  allocate(intCells(wvlt_maxLvl))
+  allocate(numCells(wvlt_maxLvl))
+  allocate(iCellsInt(wvlt_maxLvl))
+  allocate(jCellsInt(wvlt_maxLvl))
+  allocate(kCellsInt(wvlt_maxLvl))
+  allocate(iCellsTot(wvlt_maxLvl))
+  allocate(jCellsTot(wvlt_maxLvl))
+  allocate(kCellsTot(wvlt_maxLvl))
+
+  ! get any block's index limits
+  call Grid_getBlkIndexLimits(1,blkLimits,blkLimitsGC)
+
+  ! compute number of cells on interior of block in each direction
+  iCellsInt(wvlt_maxLvl) = blkLimits(HIGH,IAXIS) - blkLimits(LOW,IAXIS) + 1
+  jCellsInt(wvlt_maxLvl) = blkLimits(HIGH,JAXIS) - blkLimits(LOW,JAXIS) + 1
+  kCellsInt(wvlt_maxLvl) = blkLimits(HIGH,KAXIS) - blkLimits(LOW,KAXIS) + 1
+
+  ! compute number of cells total
+  iCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,IAXIS) - blkLimitsGC(LOW,IAXIS) + 1
+  jCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,JAXIS) - blkLimitsGC(LOW,JAXIS) + 1
+  kCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,KAXIS) - blkLimitsGC(LOW,KAXIS) + 1
+
+  ! count the number of cells at every level of refinement (division by 2 each level)
+  do l = wvlt_maxLvl, 1, -1
+    iCellsInt(l) = ceiling( Real(iCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    jCellsInt(l) = ceiling( Real(jCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    kCellsInt(l) = ceiling( Real(kCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    iCellsTot(l) = ceiling( Real(iCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    jCellsTot(l) = ceiling( Real(jCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    kCellsTot(l) = ceiling( Real(kCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    intCells(l) = iCellsInt(l) * jCellsInt(l) * kCellsInt(l)
+    numCells(l) = iCellsTot(l) * jCellsTot(l) * kCellsTot(l)
+  enddo
+
+  ! determine the total number of cells needed for coefficient storage
+  totIntCells = 0
+  totCells = 0
+  do l = 1, wvlt_maxLvl
+    totIntCells = totIntCells + intCells(l)
+    totCells = totCells + numCells(l)
+  enddo
+
+  !------- parent cell indices -------!
+
+  allocate(parentCellIndices1(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = (i + mod(i,2)) / 2
+    parentCellIndices1(i) = ip
+  enddo
+  allocate(parentCellIndices2(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = i
+    do l = wvlt_maxLvl, wvlt_maxLvl-1, -1
+      ip = (ip + mod(ip,2)) / 2
+    enddo
+    parentCellIndices2(i) = ip
+  enddo
+  allocate(parentCellIndices3(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = i
+    do l = wvlt_maxLvl, wvlt_maxLvl-2, -1
+      ip = (ip + mod(ip,2)) / 2
+    enddo
+    parentCellIndices3(i) = ip
+  enddo
+
+  !------- pre-computation of hydro flux masks -------!
+
+  ! stores what MR level the hydro sweep takes place on *** this assumes perfectly square/cube blocks
+#if NDIM == 1
+  allocate(hydroSweepLvl(1,1,1,MAXBLOCKS))
+#endif
+
+#if NDIM == 2
+  allocate(hydroSweepLvl(iCellsTot(wvlt_maxLvl),2,1,MAXBLOCKS))
+#endif
+
+!#if NDIM == 3
+!allocate(hydroSweepLvl(iCellsInt(wvlt_maxLvl),iCellsInt(wvlt_maxLvl),3,MAXBLOCKS,3))
+!#endif
+
+  ! allocate arrays that stores number of active interfaces and fluxes
+  allocate(numIntrfcActv(wvlt_maxLvl))
+  allocate(numFluxActv(wvlt_maxLvl))
+
+  ! temporary masks
+  allocate(tmpmask(iCellsTot(wvlt_maxLvl)))
+
+  ! allocate memory for arrays with fixed mappings
+  allocate(intrfcKey(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+  allocate(fluxKey(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+  allocate(fluxMask(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+
+  ! initialize mask
+  fluxMask = .false.
+
+  ! loop through hierarchy
+  do lstart = wvlt_maxLvl, 1, -1
+
+    ! initialize temporary masks
+    tmpmask = .false.
+
+    ! counters
+    numflx = 0
+    numintrfc = 0
+
+    ! loop through base grid
+    do i = 1, iCellsInt(1)+1
+
+      ! compute total index on fine grid
+      itot = lmap(1,i) + 4
+
+      ! put in the mask
+      fluxMask(itot,lstart) = .true.
+
+      ! increment counter
+      numflx = numflx + 1
+
+    enddo
+
+    ! loop through hierarchy again
+    do l = 1, lstart-1
+
+      ! loop through cells at current level
+      do i = 1, iCellsInt(l)
+
+      ! compute total index on fine grid
+      itot = lmap(l+1,2*i) + 4
+
+      ! put in the mask
+      fluxMask(itot,lstart) = .true.
+
+      numflx = numflx + 1
+
+      enddo
+
+    enddo
+
+    ! direct flux interfaces now known, now form supporting interface mask
+    do i = 2, iCellsTot(wvlt_maxLvl)-1
+
+      ! check if fluxMask is active
+      if (fluxMask(i,lstart)) then
+
+      ! need interfaces to left and right to be active as well
+      tmpmask(i-1:i+1) = .true.
+
+      endif
+
+    enddo
+
+    ! now count up the number of supporting interfaces active
+    numintrfc = count(tmpmask)
+
+    ! fill in these arrays with index mappings
+    j = 1
+    k = 1
+    do i = 1, iCellsTot(wvlt_maxLvl)
+
+      ! check tmpmask active 
+      if (tmpmask(i)) then
+
+        ! set interface key value
+        intrfcKey(j,lstart) = i
+
+        if (fluxMask(i,lstart)) then
+
+          ! set flux key value
+          fluxKey(k,lstart) = j
+
+          ! increment
+          k = k + 1
+
+        endif
+
+        ! increment counter
+        j = j + 1
+
+      endif
+
+    enddo
+
+    ! set number of interfaces and fluxes
+    numIntrfcActv(lstart) = numintrfc
+    numFluxActv(lstart) = numflx
+
+  enddo
+
+  ! cleanup temporary memory
+  deallocate(tmpmask)
+
+  if ( gr_meshMe==MASTER_PE ) &
+    write(*,'(a)') '[wvlt_init] Multiresolution initialized.'
+
+end subroutine wvlt_init
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90 source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90	2021-02-23 16:40:27.371436255 -0500
@@ -0,0 +1,143 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90
+!!
+!! NAME
+!!
+!!  wvlt_interface
+!!
+!! DESCRIPTION
+!!
+!!  Interface for subroutines included in the wvlt module.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+module wvlt_interface
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+#include "Eos.h"
+
+  interface
+    subroutine wvlt_init() 
+      implicit none
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_finalize()
+      implicit none
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_encodeBlock(lb)
+      implicit none
+      integer, intent(in) :: lb
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildMask(localBlkID)
+      implicit none
+      integer, intent(in) :: localBlkID
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildHydroMask(blockID)
+      implicit none
+      integer, intent(in) :: blockID 
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildSourceMask(numCells, numLvls, solnPtr, activeCell, interpCell)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+#if NDIM == 1
+      logical, dimension(numCells,1,1,numLvls), intent(inout) :: activeCell
+      logical, dimension(numCells,1,1,numLvls), intent(inout) :: interpCell
+#endif
+#if NDIM == 2
+      logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: activeCell
+      logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: interpCell
+#endif
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_expandBuffer(localBlkID, optmode)
+      implicit none
+      integer, intent(in) :: localBlkID
+      integer, intent(in), optional :: optmode
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_transform1D(numCells, numLvls, varData, detailCoeffs)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, dimension(numCells), intent(in) :: varData
+      real, dimension(numCells, numLvls), intent(out) :: detailCoeffs
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_transform2D(numCells, numLvls, varData, detailCoeffs)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, dimension(numCells, numCells), intent(in) :: varData
+      real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_decompInterior(numCells, numLvls, var, solnPtr, cellData)
+      implicit none
+      integer, intent(in) :: numCells, numLvls, var
+      real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+#if NDIM == 1
+      real, dimension(numCells,1,1,numLvls), intent(inout) :: cellData
+#endif
+#if NDIM == 2
+      real, dimension(numCells,numCells,1,numLvls), intent(inout) :: cellData
+#endif
+    end subroutine
+  end interface
+
+end module wvlt_interface
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90	2021-02-23 16:44:28.996506880 -0500
@@ -0,0 +1,135 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90
+!!
+!! NAME
+!!
+!!  wvlt_transform1D
+!!
+!! DESCRIPTION
+!!
+!!  Computes detail coefficients given data provided from a local MR hierarchy.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  varData - variable cell averaged data on the block
+!!  detailCoeffs - array with detail coefficients
+!!
+!! RESULT
+!!
+!!  Detail coefficients.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_transform1D(numCells, numLvls, varData, detailCoeffs)
+  
+  use wvlt_data, ONLY : iCellsInt, iCellsTot, wvlt_useRelative
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells), intent(in) :: varData
+  real, dimension(numCells, 1, 1, numLvls), intent(inout) :: detailCoeffs
+
+  ! local
+  integer :: l, i, ilo, ihi, ngx, ii
+  real :: uapprox
+  real, dimension(numCells, 1, 1, numLvls) :: cellData
+
+  !------- perform transform on 1D strip of data -------!
+
+  ! call 1D decomposition
+  call wvlt_decomp1D(numCells, numLvls, varData, cellData)
+
+  ! traverse two levels of hierarchy
+  do l = numLvls-1, numLvls-2, -1
+
+    ! number of ghost cells
+    ngx = (iCellsTot(l) - iCellsInt(l)) / 2
+
+    ! loop through interior cells
+    ilo = 1
+    ihi = iCellsInt(l)
+
+    ! check if using relative detail coeff measure
+    if (wvlt_useRelative) then
+
+      do i = ilo, ihi
+
+        ! total block index
+        ii = i + ngx
+
+        ! compute approximate data on fine scale
+        uapprox = cellData(ii,1,1,l) + 0.125e0 * &
+                    (cellData(ii+1,1,1,l) - cellData(ii-1,1,1,l))
+
+        ! compute detail coefficient for right child
+        detailCoeffs(2*i,1,1,l+1) = max(detailCoeffs(2*i,1,1,l+1), &
+                                        abs((cellData(2*ii,1,1,l+1) - uapprox) &
+                                        / max(abs(cellData(2*ii,1,1,l+1)),1.e0)))
+
+        ! compute left child
+        detailCoeffs(2*i-1,1,1,l+1) = detailCoeffs(2*i,1,1,l+1)
+
+      enddo
+
+    else
+
+      do i = ilo, ihi
+
+        ! total block index
+        ii = i + ngx
+
+        ! compute approximate data on fine scale
+        uapprox = cellData(ii,1,1,l) + 0.125e0 * &
+                    (cellData(ii+1,1,1,l) - cellData(ii-1,1,1,l))
+
+        ! compute detail coefficient for right child
+        detailCoeffs(2*i,1,1,l+1) = max(detailCoeffs(2*i,1,1,l+1), &
+                                        abs(cellData(2*ii,1,1,l+1) - uapprox))
+
+        ! compute left child
+        detailCoeffs(2*i-1,1,1,l+1) = detailCoeffs(2*i,1,1,l+1)
+
+      enddo
+
+    endif
+
+  enddo
+
+end subroutine wvlt_transform1D
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90	2021-02-23 16:44:53.351219010 -0500
@@ -0,0 +1,169 @@
+!!****if* source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90
+!!
+!! NAME
+!!
+!!  wvlt_transform2D
+!!
+!! DESCRIPTION
+!!
+!!  Computes detail coefficients given data provided from a local MR hierarchy.
+!!
+!! ARGUMENTS
+!!
+!!  numCells - the number of cells along any direction of the block (assumes
+!!             equal number in all directions)
+!!  numLvls - the number of levels in the local MR hierarchy
+!!  varData - variable cell averaged data on the block
+!!  detailCoeffs - array with detail coefficients
+!!
+!! RESULT
+!!
+!!  Detail coefficients.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine wvlt_transform2D(numCells, numLvls, varData, detailCoeffs)
+  
+  use wvlt_data, ONLY : iCellsInt, jCellsInt, &
+                          iCellsTot, jCellsTot, &
+                          wvlt_useRelative
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells, numCells), intent(in) :: varData
+  real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+
+  ! local
+  integer :: l, i, j, itot, jtot, ngx, ngy
+  real :: u0, Qx, Qy, Qxy
+  real, dimension(numCells, numCells, 1, numLvls) :: cellData
+ 
+  !------- perform transform on 2D strip of data -------!
+
+  ! call 2D decomposition
+  call wvlt_decomp2D(numCells, numLvls, varData, cellData)
+
+  ! traverse hierarchy
+  do l = numLvls-1, numLvls-2, -1
+
+    ! compute number of ghost cells at current level
+    ngx = (iCellsTot(l) - iCellsInt(l)) / 2
+    ngy = (jCellsTot(l) - jCellsInt(l)) / 2
+
+    ! loop through interior cells
+    do i = 1, iCellsInt(l)
+
+      ! convert interior index to total index
+      itot = ngx + i
+
+      ! loop through interior j-axis cells
+      do j = 1, jCellsInt(l)
+
+        ! convert interior index to total index
+        jtot = ngy + j
+
+        ! centered value
+        u0 = cellData(itot,jtot,1,l)
+
+        ! compute the terms 'Qx', 'Qy', and 'Qxy' - bihari1997
+        Qx = (-0.125e0) * (cellData(itot+1,jtot,1,l) - cellData(itot-1,jtot,1,l))
+        Qy = (-0.125e0) * (cellData(itot,jtot+1,1,l) - cellData(itot,jtot-1,1,l))
+        Qxy = 0.015625e0 * (cellData(itot+1,jtot+1,1,l) - cellData(itot+1,jtot-1,1,l) &
+                - cellData(itot-1,jtot+1,1,l) + cellData(itot-1,jtot-1,1,l))
+
+        if (wvlt_useRelative) then
+
+          ! compute d^{l+1}_{2i-1,2j-1} (quadrant 3)
+          detailCoeffs(2*i-1,2*j-1,1,l+1) = max(abs((cellData(2*itot-1,2*jtot-1,1,l+1) &
+                                              - (u0 + Qx + Qy + Qxy)) &
+                                              / max(abs(cellData(2*itot-1,2*jtot-1,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i-1,2*j-1,1,l+1))
+
+          ! compute d^{l+1}_{2i,2j-1} (quadrant 4)
+          detailCoeffs(2*i,2*j-1,1,l+1) = max(abs((cellData(2*itot,2*jtot-1,1,l+1) &
+                                              - (u0 - Qx + Qy - Qxy)) &
+                                              / max(abs(cellData(2*itot,2*jtot-1,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i,2*j-1,1,l+1))
+
+
+          ! compute d^{l+1}_{2i-1,2j} (quadrant 2)
+          detailCoeffs(2*i-1,2*j,1,l+1) = max(abs((cellData(2*itot-1,2*jtot,1,l+1) &
+                                              - (u0 + Qx - Qy - Qxy)) &
+                                              / max(abs(cellData(2*itot-1,2*jtot,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i-1,2*j,1,l+1))
+
+
+          ! compute d^{l+1}_{2i,2j} (quadrant 1)
+          detailCoeffs(2*i,2*j,1,l+1) = max(abs((cellData(2*itot,2*jtot,1,l+1) &
+                                              - (u0 - Qx - Qy + Qxy)) &
+                                              / max(abs(cellData(2*itot,2*jtot,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i,2*j,1,l+1))
+
+        else
+
+          ! compute d^{l+1}_{2i-1,2j-1} 
+          detailCoeffs(2*i-1,2*j-1,1,l+1) = max(abs(cellData(2*itot-1,2*jtot-1,1,l+1) &
+                                              - (u0 + Qx + Qy + Qxy)), &
+                                              detailCoeffs(2*i-1,2*j-1,1,l+1))
+ 
+          ! compute d^{l+1}_{2i,2j-1} 
+          detailCoeffs(2*i,2*j-1,1,l+1) = max(abs(cellData(2*itot,2*jtot-1,1,l+1) &
+                                              - (u0 - Qx + Qy - Qxy)), &
+                                              detailCoeffs(2*i,2*j-1,1,l+1))
+
+
+          ! compute d^{l+1}_{2i-1,2j} 
+          detailCoeffs(2*i-1,2*j,1,l+1) = max(abs(cellData(2*itot-1,2*jtot,1,l+1) &
+                                              - (u0 + Qx - Qy - Qxy)), &
+                                              detailCoeffs(2*i-1,2*j,1,l+1))
+
+
+          ! compute d^{l+1}_{2i,2j} 
+          detailCoeffs(2*i,2*j,1,l+1) = max(abs(cellData(2*itot,2*jtot,1,l+1) &
+                                              - (u0 - Qx - Qy + Qxy)), &
+                                              detailCoeffs(2*i,2*j,1,l+1))
+
+        endif
+
+      enddo
+
+    enddo
+
+  enddo
+
+end subroutine wvlt_transform2D
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/Config source/physics/Hydro/HydroMain/split/PPM/Config
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/Config	2021-02-23 18:16:25.600280068 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/Config	2021-02-14 17:05:20.165818682 -0500
@@ -105,15 +105,25 @@
 PARAMETER omg2                REAL    10.     # PPM dissipation parameter omega2
 PARAMETER igodu               INTEGER 0       # Use Godunov method
 PARAMETER iplm                INTEGER 0       # Use linear profiles 
+PARAMETER interp_6thOrder     	 INTEGER 0       # Use 6th order approximation to interpolate at interface if not 0
+PARAMETER interp_6thC         	 REAL    1.25e0  # Monotonization zone-to-zone jump weighting
+PARAMETER detect_djump        	 REAL    1.e-2   # Density jump detection threshold for steepener
+PARAMETER gridIsUniform          BOOLEAN TRUE    # required for the 6th order method to work
 PARAMETER vgrid               REAL    0.      # Scale factor for grid velocity
 PARAMETER nriem               INTEGER 10      # No. of iterations in Riemann solver
 PARAMETER rieman_tol          REAL    1.0e-5  # Converge factor for Riemann solver
+PARAMETER rieman_tol_abort    	 REAL    1.e-1   # Converge factor for Riemann solver
 PARAMETER cvisc               REAL    0.1     # Artificial viscosity constant
 PARAMETER dp_sh               REAL    0.33    # pressure jump for 1-D shock detection
 PARAMETER ppm_modifystates    BOOLEAN FALSE   # modify states due to gravity?
 PARAMETER leveque             BOOLEAN FALSE   # do LeVeque's method?
 PARAMETER hybrid_riemann      BOOLEAN FALSE   # use HLLE in shocks to remove odd-even decoupling
 PARAMETER charLimiting        BOOLEAN TRUE    # use characteristic variables for slope limiting
+PARAMETER ppmRiemannSolver       STRING "exact"  # exact, AUSMP, AUSMPUP
+PARAMETER ppmRiemannSolverHybrid STRING "HLLE"   # HLLE, AUSMP, AUSMPUP
+PARAMETER forceApproxRiemann     BOOLEAN FALSE   # Force use of the HLLE solver for all flux calculations.
+PARAMETER use_flattening         BOOLEAN TRUE    # toggle profile flattening
+PARAMETER enr_flattening         BOOLEAN FALSE   # consider total energy when flattening
 
 D ppmEnerFluxConstructionMeth selects a method for constructing energy
 D & fluxes, for total (internal+kinetic) energy,
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90	2021-02-23 17:47:22.436602304 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/avisco
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco
 !!
 !! NAME
 !!
@@ -76,6 +76,12 @@
 !!  cvisc -   Artificial viscosity constant. Probably as set
 !!            in Hydro_init from a runtime parameter.
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 subroutine avisco(j, k, avis, dirGeom, xyzswp,                 &
@@ -413,7 +419,7 @@
            dxtb  = 3.0 / ( 2.0 * (xtop**3 - xbot**3) )
            dzrl  = 0.5 / ( xzn(j) * (zrgt - zlft) ) 
            do i = nzni, nznf
-              sinth   = max(sin( xl(i) ),1e-6)
+              sinth   = sin( xl(i) )
               avis(i) = (sin(x(i)) * u(i) - sin(x(i-1)) * u(i-1)) /        &
                    (xzn(j) * sinth * (x(i) - x(i-1)) ) +                   &
                    (xtop**2 * (uttp(i) + uttp(i-1)) -                      &
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90	2021-02-23 17:47:28.907790532 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/cma_flatten
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten
 !!
 !! NAME
 !!
@@ -38,11 +38,17 @@
 !! dxn :
 !! xn6 :
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 
 subroutine cma_flatten(numIntCells, numCells,guard, xn, xnl, xnr, dxn, xn6)
-  use Hydro_data, ONLY : hy_numXn
+  use Hydro_data, ONLY : hy_numXn, hy_smallx
   implicit none
 
 #include "Flash.h"
@@ -51,9 +57,9 @@
   real, intent(IN),    DIMENSION(numCells, hy_numXn) :: xn
   real, intent(INOUT), DIMENSION(numCells, hy_numXn) :: xnl, xnr, dxn, xn6
 
-  integer :: i, n
-
-  real :: tmp, w_ln, w_rn
+  integer         :: i, n
+  real, parameter :: xjflat = 0.25e0
+  real            :: tmp, w_ln, w_rn
 
   real, DIMENSION(numCells) :: extrema, flatten
   real, DIMENSION(numCells) :: s_L_plus, s_L_minus, s_R_plus, s_R_minus
@@ -68,9 +74,9 @@
 
      do i = guard-1, guard+numIntCells+2
         if ( (xn(i+1,n) - xn(i,n))*(xn(i,n) - xn(i-1,n)) < 0.e0) then
-           extrema(i) = 1.0
+           extrema(i) = 1.e0
         else
-           extrema(i) = 0.0
+           extrema(i) = 0.e0
         endif
      enddo
 
@@ -79,8 +85,8 @@
 ! is an extrema in one of its neighbors and NOT in zone i too.
 
      do i = guard, guard+numIntCells+1
-        flatten(i) = 0.5*max(extrema(i-1), 2.0*extrema(i), extrema(i+1))
-        flatten(i) = min(1.0, flatten(i))
+        flatten(i) = 0.5e0*max(extrema(i-1), 2.e0*extrema(i), extrema(i+1))
+        flatten(i) = min(1.e0, flatten(i))
      enddo
 
 ! Now flatten(i) is > 0 if we are to apply flattening in zone i.  It is
@@ -91,14 +97,14 @@
 ! Apply Eq. 14
 
      do i = guard, guard+numIntCells+1
-        if (flatten(i) > 0.0) then
-           tmp = 1.0 - flatten(i)
+        if (flatten(i) > 0.e0) then
+           tmp = 1.e0 - flatten(i)
            
            xnl(i,n) = flatten(i)*xn(i,n) + tmp*xnl(i,n)
            xnr(i,n) = flatten(i)*xn(i,n) + tmp*xnr(i,n)
            
            dxn(i,n) = xnr(i,n) - xnl(i,n)
-           xn6(i,n) = 6.0*xn(i,n) - 3.0*(xnl(i,n) + xnr(i,n))
+           xn6(i,n) = 6.e0*xn(i,n) - 3.e0*(xnl(i,n) + xnr(i,n))
         endif
      enddo
 
@@ -111,28 +117,28 @@
 
 ! Start by computing two sums, at each interface, Eq. 15.
   do i = guard, guard+numIntCells+1
-     s_L_plus(i) = 0.0
-     s_L_minus(i) = 0.0
+     s_L_plus(i)  = 0.e0
+     s_L_minus(i) = 0.e0
 
-     s_R_plus(i) = 0.0
-     s_R_minus(i) = 0.0
+     s_R_plus(i)  = 0.e0
+     s_R_minus(i) = 0.e0
   enddo
 
   do n = 1, NSPECIES
      do i = guard, guard+numIntCells+1
-        s_L_plus(i)  = s_L_plus(i)  + max(0.0, xnl(i,n) - xn(i,n))
-        s_L_minus(i) = s_L_minus(i) + max(0.0, xn(i,n) - xnl(i,n))
+        s_L_plus(i)  = s_L_plus(i)  + max(0.e0, xnl(i,n) - xn (i,n))
+        s_L_minus(i) = s_L_minus(i) + max(0.e0, xn (i,n) - xnl(i,n))
         
-        s_R_plus(i)  = s_R_plus(i)  + max(0.0, xnr(i,n) - xn(i,n))
-        s_R_minus(i) = s_R_minus(i) + max(0.0, xn(i,n) - xnr(i,n))
+        s_R_plus(i)  = s_R_plus(i)  + max(0.e0, xnr(i,n) - xn (i,n))
+        s_R_minus(i) = s_R_minus(i) + max(0.e0, xn (i,n) - xnr(i,n))
      enddo
   enddo
 
   do i = guard, guard+numIntCells+1
-     delta_L_min(i) = min(s_L_plus(i), s_L_minus(i))
+     delta_L_min(i) = min(s_L_plus(i), s_L_minus(i)) + hy_smallx
      delta_L_max(i) = max(s_L_plus(i), s_L_minus(i))
   
-     delta_R_min(i) = min(s_R_plus(i), s_R_minus(i))
+     delta_R_min(i) = min(s_R_plus(i), s_R_minus(i)) + hy_smallx
      delta_R_max(i) = max(s_R_plus(i), s_R_minus(i))
   enddo
 
@@ -140,21 +146,34 @@
 ! for each abundance
   do n = 1, NSPECIES
      do i = guard, guard+numIntCells+1
-        sgn_L(i,n) = 0.5*abs(sign(1.0, xnr(i,n) - xnl(i,n)) - &
-                             sign(1.0,s_L_plus(i) - s_L_minus(i)))
+        sgn_L(i,n) = 0.5e0*abs( sign(1.e0, xnr(i,n)    - xnl(i,n)    ) &
+                               -sign(1.e0, s_L_plus(i) - s_L_minus(i)))
 
-        sgn_R(i,n) = 0.5*abs(sign(1.0, xnr(i,n) - xnl(i,n)) + &
-                             sign(1.0,s_R_plus(i) - s_R_minus(i)))
+        sgn_R(i,n) = 0.5e0*abs(sign(1.e0, xnr(i,n) - xnl(i,n)) + &
+                               sign(1.e0,s_R_plus(i) - s_R_minus(i)))
 
      enddo
   enddo
 
 ! now, fix up the interface values
   do i = guard, guard+numIntCells+1
-     w_L(i) = max(0.0, min(1.0, 0.25*(delta_L_max(i) - delta_L_min(i))/ &
-                                      delta_L_min(i)))
-     w_R(i) = max(0.0, min(1.0, 0.25*(delta_R_max(i) - delta_R_min(i))/ &
-                                      delta_R_min(i)))
+
+     if ( delta_L_min(i) < 1.e2*tiny(1.e0) ) then
+        write(*,*) ' delta_L_min ',i,delta_L_min(i)
+        write(*,'(a,10es10.2)') 'xnl ',(xnl(i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xn  ',(xn (i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xnr ',(xnr(i,n),n=1,NSPECIES)
+     end if
+     w_L(i) = max(0.e0, min(1.e0, xjflat*(delta_L_max(i) - delta_L_min(i)) &
+                                        /delta_L_min(i)))
+     if ( delta_R_min(i) < 1.e2*tiny(1.e0) ) then
+        write(*,*) ' delta_R_min ',i,delta_R_min(i)
+        write(*,'(a,10es10.2)') 'xnl ',(xnl(i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xn  ',(xn (i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xnr ',(xnr(i,n),n=1,NSPECIES)
+     end if
+     w_R(i) = max(0.e0, min(1.e0, xjflat*(delta_R_max(i) - delta_R_min(i)) &
+                                        /delta_R_min(i)))
   enddo
 
   do n = 1, NSPECIES
@@ -162,11 +181,11 @@
         w_Ln = sgn_L(i,n)*w_L(i)
         w_Rn = sgn_R(i,n)*w_R(i)
 
-        xnl(i,n) = w_Ln*xn(i,n) + (1.0 - w_Ln)*xnl(i,n)
-        xnr(i,n) = w_Rn*xn(i,n) + (1.0 - w_Rn)*xnr(i,n)
+        xnl(i,n) = w_Ln*xn(i,n) + (1.e0 - w_Ln)*xnl(i,n)
+        xnr(i,n) = w_Rn*xn(i,n) + (1.e0 - w_Rn)*xnr(i,n)
         
         dxn(i,n) = xnr(i,n) - xnl(i,n)
-        xn6(i,n) = 6.0*xn(i,n) - 3.0*(xnl(i,n) + xnr(i,n))
+        xn6(i,n) = 6.e0*xn(i,n) - 3.e0*(xnl(i,n) + xnr(i,n))
      enddo
   enddo
 
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config	2021-02-23 18:16:43.507798049 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config	2021-02-15 15:55:06.874067566 -0500
@@ -1,182 +1,73 @@
-# Config file for physics/Hydro/HydroMain/split/PPM
-#
+D hy_renormalizeSpecies            species renormalization
+PARAMETER hy_renormalizeSpecies     BOOLEAN  true
 
-#       Config file for explicit split PPM hydrodynamics.
-#       This implementation is based on the PROMETHEUS code by B. A. Fryxell and
-#       E. Mueller.
+D hy_limitSpecies                  species limiting
+PARAMETER hy_limitSpecies     BOOLEAN  true
 
-REQUESTS Driver/DriverMain/Split
-REQUIRES physics/Eos
+D hy_speciesSumTolerance           warning threshold for species normalization error
+PARAMETER hy_speciesSumTolerance    REAL     1.e-8    [0 to ]
 
-DEFAULT PPMKernel
+D hy_speciesSumToleranceAbort      abort threshold for species normalization error
+PARAMETER hy_speciesSumToleranceAbort           REAL     1.e-4    [0 to ]
 
-USESETUPVARS chomboCompatibleHydro, threadBlockList, threadWithinBlock
-IF chomboCompatibleHydro
-   REQUIRES physics/Hydro/HydroMain/split/PPM/chomboCompatible
-ENDIF
+D hy_renormalizeMassScalars        mass scalars renormalization
+PARAMETER hy_renormalizeMassScalars   BOOLEAN  false
 
-IF threadBlockList or threadWithinBlock
-   CONFLICTS physics/Hydro/HydroMain/split/PPM/chomboCompatible
-   CONFLICTS physics/Hydro/HydroMain/split/PPM/multiTemp
-ENDIF
+D hy_limitMassScalars              mass scalars limiting
+PARAMETER hy_limitMassScalars       BOOLEAN  false
 
-# We must use a special customized version of hy_ppm_sweep.
-IF threadBlockList
-   CONFLICTS physics/Hydro/HydroMain/split/PPM/threadWithinBlock
-   REQUIRES physics/Hydro/HydroMain/split/PPM/threadBlockList
-ENDIF
+D hy_massScalarsSumTolerance       warning threshold for mass scalars normalization error
+PARAMETER hy_massScalarsSumTolerance      REAL    HUGE(1.e0)
 
+D hy_massScalarsSumToleranceAbort  abort threshold for mass scalars normalization error
+PARAMETER hy_massScalarsSumToleranceAbort REAL    HUGE(1.e0)
 
-# We must use a special customized version of hy_ppm_block.
-IF threadWithinBlock
-   CONFLICTS physics/Hydro/HydroMain/split/PPM/threadBlockList
-   REQUIRES physics/Hydro/HydroMain/split/PPM/threadWithinBlock
-ENDIF
+D cfl            Courant factor
+PARAMETER cfl           REAL    0.8e0   # Courant factor
 
+D cfl_init      initial Courant factor: if non-zero the initial timestep will set to cfl_init Courant factor
+PARAMETER cfl_init     REAL     -1.e0
 
+D cfl_crit      highest allowed Courant factor before automatic timestep reduction kicks in
+PARAMETER cfl_crit     REAL     0.9e0
 
-VARIABLE dens TYPE: PER_VOLUME  EOSMAP:  DENS  # density
-VARIABLE velx TYPE: PER_MASS    EOSMAPIN:VELX  # x-velocity
-VARIABLE vely TYPE: PER_MASS    EOSMAPIN:VELY  # y-velocity
-VARIABLE velz TYPE: PER_MASS    EOSMAPIN:VELZ  # z-velocity
-VARIABLE pres                   EOSMAP:  PRES  # pressure
-VARIABLE ener TYPE: PER_MASS    EOSMAP:  ENER  # specific total energy (T+U)
-VARIABLE temp                   EOSMAP:  TEMP  # temperature
-
-USESETUPVARS SuppressEintVariable
-IF not SuppressEintVariable
-	VARIABLE eint TYPE: PER_MASS  EOSMAP: EINT  # specific internal energy
-ENDIF
+D cfl_factor_min the smallest allowed cfl in the process of automatic timestep reduction
+PARAMETER cfl_factor_min REAL 0.
+
+D cfl_dynamical  use measured effective Courant factor to additionally limit timestep
+PARAMETER cfl_dynamical BOOLEAN FALSE
 
-FLUX rho
-FLUX u
-FLUX p
-FLUX ut
-FLUX utt
-FLUX e
-FLUX eint
-
-# This is currently not used, but should be enabled if the call 
-# in Driver_computeDt to Driver_computeDtTemp gets enabled.
-#SCRATCHVAR otmp                   # old temperature 
-
-
-USESETUPVARS SupportWeno, SupportPpmUpwind
-IF SupportWeno
-  SETUPERROR The PPM split Hydro implementation does not support WENO, try +unsplitHydro
-ELSEIF SupportPpmUpwind
-  SETUPERROR The PPM split Hydro implementation does not support PPM Upwind, try +unsplitHydro
+D UnitSystem  System of Units
+PARAMETER UnitSystem  STRING   "none"      # System of Units
+
+D use_cma_flattening use the flattening procedure for the abundances as  
+D &                  described in the CMA paper
+
+PARAMETER use_steepening      BOOLEAN TRUE    # toggle the contact steepening
+PARAMETER use_cma_flattening  BOOLEAN FALSE   # use the CMA flattening procedure
+PARAMETER use_cma_steepening  BOOLEAN FALSE   # use the CMA steepening procedure
+PARAMETER use_cma_advection   BOOLEAN FALSE   # use the CMA advection with partial masses being primary variables
+
+PARAMETER xl_boundary_noflow  BOOLEAN FALSE   # noflow conditions (force advection velocities to zero)
+PARAMETER xr_boundary_noflow  BOOLEAN FALSE
+PARAMETER yl_boundary_noflow  BOOLEAN FALSE
+PARAMETER yr_boundary_noflow  BOOLEAN FALSE
+PARAMETER zl_boundary_noflow  BOOLEAN FALSE
+PARAMETER zr_boundary_noflow  BOOLEAN FALSE
+
+USESETUPVARS threadBlockList, threadWithinBlock
+IF threadBlockList
+   PARAMETER threadHydroBlockList BOOLEAN TRUE
+ELSE
+   PARAMETER threadHydroBlockList BOOLEAN FALSE
 ENDIF
 
+IF threadWithinBlock
+   PARAMETER threadHydroWithinBlock BOOLEAN TRUE
+ELSE
+   PARAMETER threadHydroWithinBlock BOOLEAN FALSE
+ENDIF
 
-# Lines that begin with 'D' as in 'Description' will end up as
-# comment lines in the setup_params file.  setup_params is
-# written by the setup script and holds all the default 
-# values of parameters.  
-
-# !!! If you add a parameter, please add a description line
-# Format is D <parameter name> <description>
-
-D hy_eosModeAfter Eos mode to apply at the end of a hydro sweep, after
-D & hy_ppm_updateSoln is done.
-D & Some meaningful choices are (1): == eosMode (traditional),
-D & (2): "dens_ie" for MODE_DENS_EI (which are normally the same!).
-PARAMETER hy_eosModeAfter STRING "dens_ie"["dens_ie","dens_pres","dens_temp","dens_ie_all","dens_ie_scatter","dens_ie_gather","dens_ie_sele_gather","dens_ie_shocksele_gather","dens_temp_equi","dens_temp_all","dens_temp_gather","dens_ie_recal_gather"]
-
-D dp_sh_md       pressure jump for multi-dimensional shock detection
-PARAMETER dp_sh_md      REAL    0.33 
-
-D epsiln             PPM shock detection parameter
-D omg1               PPM dissipation parameter omega1
-D omg2               PPM dissipation parameter omega2
-D igodu              Use Godunov method
-D iplm               Use linear profiles
-D vgrid              Scale factor for grid velocity
-D nriem              No. of iterations in Riemann solver
-D rieman_tol         Converge factor for Riemann solver
-D cvisc              Artificial viscosity constant
-D ppm_modifystates   modify states due to gravity -- our way.
-D leveque            modify states due to gravity -- leveque's way.
-D hybrid_riemann     use HLLE in shocks to remove odd-even decoupling
-D charLimiting       use characteristic variables for slope limiting
-
-PARAMETER epsiln              REAL    0.33    # PPM shock detection parameter
-PARAMETER omg1                REAL    0.75    # PPM dissipation parameter omega1
-PARAMETER omg2                REAL    10.     # PPM dissipation parameter omega2
-PARAMETER igodu               INTEGER 0       # Use Godunov method
-PARAMETER iplm                INTEGER 0       # Use linear profiles 
-PARAMETER vgrid               REAL    0.      # Scale factor for grid velocity
-PARAMETER nriem               INTEGER 10      # No. of iterations in Riemann solver
-PARAMETER rieman_tol          REAL    1.0e-5  # Converge factor for Riemann solver
-PARAMETER cvisc               REAL    0.1     # Artificial viscosity constant
-PARAMETER dp_sh               REAL    0.33    # pressure jump for 1-D shock detection
-PARAMETER ppm_modifystates    BOOLEAN FALSE   # modify states due to gravity?
-PARAMETER leveque             BOOLEAN FALSE   # do LeVeque's method?
-PARAMETER hybrid_riemann      BOOLEAN FALSE   # use HLLE in shocks to remove odd-even decoupling
-PARAMETER charLimiting        BOOLEAN TRUE    # use characteristic variables for slope limiting
-
-D ppmEnerFluxConstructionMeth selects a method for constructing energy
-D & fluxes, for total (internal+kinetic) energy,
-D & from the results of calling the Riemann solver.
-PARAMETER ppmEnerFluxConstructionMeth INTEGER 0 [ 0 to 2, 4 to 6, 11 to 12, 14 to 16, 20 to 27 ]
-
-D ppmEintFluxConstructionMeth selects a method for constructing energy
-D & fluxes, for internal energy,
-D & from the results of calling the Riemann solver.
-D & Note that the eintSwitch runtime parameter controls whether internal energy fluxes,
-D & rather than total energy fluxes, are sometimes used for updating the energy variables
-D & (both internal and total) in a given cell (depending on the ratio of kinetic to internal
-D & energy in that cell).
-PARAMETER ppmEintFluxConstructionMeth INTEGER 0 [ -1 , 0 to 2, 4 to 6 ]
-
-
-PARAMETER ppmEnerCompFluxConstructionMeth INTEGER 0 [ 0 to 7, 11 to 17, 20 to 27 ]
-PARAMETER ppmEintCompFluxConstructionMeth INTEGER 0 [ -1, 0 to 7 ]
-
-
-D hy_fluxRepresentation determines the nature of the data stored in flux arrays.
-D & With this parameter set to "fluxes", the fluxes and cell volumes used in the Hydro method are
-D & calculated correctly using geometry measures (in units matching those in which coordinates
-D & are represented). If hy_fluxRepresentation is "hybrid", fluxes are calculated in a simpler
-D & way; for example, the fluxes in Cartesian coordinates use the convention Face Area == 1
-D & (and thus Cell Volume == dx during the X sweep, etc.). Both settings lead to a correct
-D & algorithm, because what is ultimately applied in the Hydro update is of the form
-D & fluxes times dt/CellVolume, so cell areas (thus fluxes) and volumes can be multiplied
-D & by an arbitrary constant (as long as it is done consistently) without changing results
-D & (except for rounding effects).
-D & The setting here must match Paramesh's understanding of what the "fluxes" are
-D & that it is being passed if Grid_conserveFluxes is called:
-D & If hy_fluxRepresentation is "fluxes", then 
-D &    Paramesh4 should have set consv_fluxes==.true.,  consv_flux_densities==.false.
-D & If hy_fluxRepresentation is "hybrid", then
-D &    Paramesh4 should have set consv_fluxes==.false., consv_flux_densities==.true.
-D & Hydro_init will try to set Paramesh to the right mode if possible, this requires
-D & Paramesh to be compiled in LIBRARY mode. If this fails, the flux representation
-D & will be modified to correspond to what the Grid unit supports.
-D & A third possible value for hy_fluxRepresentation is "auto", in which case the Hydro
-D & code unit will pick either "fluxes" or "hybrid" based on geometry and support in Grid.
-
-PARAMETER hy_fluxRepresentation	STRING "fluxes"	["hybrid","fluxes","auto"]
-
-D small             Cutoff value ... DEV: for what?
-PARAMETER small		REAL	1.E-10
-
-D smlrho            Cutoff value for density	
-PARAMETER smlrho	REAL	1.E-10	
-
-D smallp            Cutoff value for pressure
-PARAMETER smallp	REAL	1.E-10	
-
-D smalle            Cutoff value for energy
-PARAMETER smalle	REAL	1.E-10	
-
-D smallt            Cutoff value for temperature
-PARAMETER smallt	REAL	1.E-10	
-
-D smallu            Cutoff value for velocity
-PARAMETER smallu	REAL	1.E-10	
-
-D smallx            Cutoff value for abundances
-PARAMETER smallx	REAL	1.E-10	
- 
-PPDEFINE FLASH_HYDRO_PPM
+# multiresolution solver-adaptive parameters
+PARAMETER mrppm_iord INTEGER 3 [1 to 3]
+PARAMETER mrppm_simplemask BOOLEAN TRUE
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90	2021-02-23 18:16:43.504797962 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90	2021-02-23 17:47:36.468010435 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/detect
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect
 !!
 !! NAME
 !! 
@@ -40,11 +40,17 @@
 !!  dx :
 !!  x :
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
-subroutine detect(numIntCells, numCells, al,a,ar,smalla,rho,p,game,dx,x)
+subroutine detect( numIntCells, numCells, al, a, ar, smalla, rho, p, game, dx, x )
 
-  use Hydro_data, ONLY: hy_small, hy_dela
+  use Hydro_data, ONLY: hy_small, hy_dela, hy_detect_djump
 
   implicit none
 
@@ -54,24 +60,22 @@
   real, dimension(numCells) ::  scrch1, scrch2, scrch3
   real, intent(IN) :: smalla
   integer :: i,numIntCells5,numIntCells6,numIntCells7,numIntCells8
-  
 
-
-    ! the following parameters are set as in Colella and
-    ! Woodward (JCP, 54 (1984), 174), Eqs. 1.17 and 3.2
+  ! the following parameters are set as in Colella and
+  ! Woodward (JCP, 54 (1984), 174), Eqs. 1.17 and 3.2
 
   real, PARAMETER :: eta1 = 20.e0, eta2 = 0.05e0, epsln = 0.01e0, ak0 = 0.1e0
 
   real :: tmp1, tmp2, tmp3
 
-    !------------------------------------------------------------------------------
+  !------------------------------------------------------------------------------
 
   numIntCells5 = numIntCells + 5
   numIntCells6 = numIntCells + 6
   numIntCells7 = numIntCells + 7
   numIntCells8 = numIntCells + 8
 
-! compute some common factors      
+  ! compute some common factors      
 
   do  i = 2, numIntCells7
      scrch1(i) = dx(i) + dx(i-1)
@@ -87,8 +91,8 @@
      scrch1(i) = scrch1(i) * scrch1(i) * scrch1(i)
   end do
 
-! compute {\tilde \eta (i)} as given in the expression at the top of page 181
-! in Colella & Woodward
+  ! compute {\tilde \eta (i)} as given in the expression at the top of page 181
+  ! in Colella & Woodward
   
   do i = 3, numIntCells5
      scrch3(i) = (scrch2(i-1) - scrch2(i+1)) * (scrch1(i) + scrch1(i+1))
@@ -101,29 +105,29 @@
      
      scrch3(i) = scrch3(i) / ((x(i+1) - x(i-1)) * tmp3)
 
-! scrch2 and scrch3 now contain finite difference approximations
-! to the second and third derivativess of a.
+     ! scrch2 and scrch3 now contain finite difference approximations
+     ! to the second and third derivativess of a.
 
-! apply the first constaint on {\tidle \eta (i) as given in Eq. 1.17
+     ! apply the first constaint on {\tidle \eta (i) as given in Eq. 1.17
 
      if (scrch2(i-1)*scrch2(i+1) >= 0.e0) scrch3(i) = 0.e0
 
-! apply the second constraint
+     ! apply the second constraint
 
-     tmp3 = epsln * min(a(i+1),a(i-1)) - abs(a(i+1) - a(i-1))
+     tmp3 = hy_detect_djump * min(a(i+1),a(i-1)) - abs(a(i+1) - a(i-1))
      
      if (tmp3 >= 0.e0) scrch3(i) = 0.e0
      
      scrch3(i) = max(0.e0, min(1.e0, eta1 * (scrch3(i) - eta2) ))
      
-! add an addition constraint (Eq. 3.2) to detect contact discontinuities
+     ! add an addition constraint (Eq. 3.2) to detect contact discontinuities
 
      tmp1 = abs (p(i+1)   - p(i-1)  ) / min (p(i+1),   p(i-1)  )
      tmp2 = abs (rho(i+1) - rho(i-1)) / min (rho(i+1), rho(i-1))
      
      if (game(i)*ak0*tmp2-tmp1 < 0.e0) scrch3(i) = 0.e0
 
-!  scrch3 now contains the contact steepening coefficient
+     !  scrch3 now contains the contact steepening coefficient
 
      tmp1 = a(i-1) + 0.5e0 * hy_dela(i-1)
      tmp2 = a(i+1) - 0.5e0 * hy_dela(i+1)
@@ -131,7 +135,6 @@
      al(i) = al(i) + (tmp1 - al(i)) * scrch3(i)
      ar(i) = ar(i) + (tmp2 - ar(i)) * scrch3(i)
   end do
-  
-  return
+
 end subroutine detect
   
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90	2021-02-23 17:46:46.532557975 -0500
@@ -1,93 +1,96 @@
 !!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/flaten
 !!
 !! NAME
-!! 
+!!
 !!  flaten
 !!
 !! SYNOPSIS
 !!
-!! 
+!!
 !!  call flaten(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells, 
-!!              real(IN)    :: u(numCells), 
-!!              real(IN)    :: p(numCells),  
-!!              real(OUT)   :: flatn(numCells), 
-!!              real(OUT)   :: flatn1(numCells))
+!!              integer(IN) :: numCells,
+!!              real(IN)    :: u(numCells),
+!!              real(IN)    :: p(numCells),
+!!              real(OUT)   :: flatn(numCells),
+!!
 !!
-!! 
 !! DESCRIPTION
-!!  
+!!
 !!  Flaten zone structure in regions where shocks are too thin.
-!!  This version of subroutine FLATEN only uses the simplest form 
-!!  of dissipation as described in the appendix of Colella and Woodward 
-!!  (JCP, 54 (1984), 174). Therefore the only constants required are 
+!!  This version of subroutine FLATEN only uses the simplest form
+!!  of dissipation as described in the appendix of Colella and Woodward
+!!  (JCP, 54 (1984), 174). Therefore the only constants required are
 !!  omg1, omg2 and epsiln, which are read in.
 !!
-!!  The "standard" values of the constants are:                  
-!!                                                                     
-!!          epsiln = 0.33                                             
-!!                                                                     
-!!          omg1   = 0.75                                             
-!!          omg2   = 10.0                                             
-!!          sig1   = 0.50                                             
-!!          sig2   = 1.00                                             
-!!          ak1    = 2.00                                             
-!!          ak2    = 0.01                                             
-!!                                                                     
-!!          wig1   = 2.00                                             
-!!          wig2   = 0.00           for 1-d                           
-!!                   0.10           for 2-d                           
-!!          wig3   = 0.3333 - wig2                                    
-!!                                                                     
+!!  The "standard" values of the constants are:
+!!
+!!          epsiln = 0.33
+!!
+!!          omg1   = 0.75
+!!          omg2   = 10.0
+!!          sig1   = 0.50
+!!          sig2   = 1.00
+!!          ak1    = 2.00
+!!          ak2    = 0.01
+!!
+!!          wig1   = 2.00
+!!          wig2   = 0.00           for 1-d
+!!                   0.10           for 2-d
+!!          wig3   = 0.3333 - wig2
+!!
 !!
 !!
 !!
 !! ARGUMENTS
 !!
 !! numIntCells :
-!! numCells : 
+!! numCells :
 !! u :
 !! p :
 !! flatn :
-!! flatn1 :
 !!
-!! 
+!! NOTES
+!!
+!!  Modified March 16, 2016 by TAH: Added the contribution from the total energy steepness to
+!!    the omega calculation (C&W A.9)
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
 !!***
 
-subroutine flaten(numIntCells,numCells, &
-                  u, p,  flatn, flatn1)
+subroutine flaten( numIntCells, numCells, u, p, e, flatn )
 
-  use Hydro_data, ONLY: hy_epsiln, hy_omg1, hy_omg2,&
-                        hy_igodu,hy_dp,hy_du,hy_smallu
-                        
-  
-  implicit none
+  use Hydro_data, ONLY: hy_burnShocks, hy_epsiln, hy_omg1, hy_omg2, &
+                        hy_dp, hy_du, hy_smallu, &
+                        hy_enrFlattening
 
-  integer, INTENT(IN):: numIntCells, numCells
-  real,  INTENT(IN), DIMENSION(numCells) :: u, p
-  real,  INTENT(OUT), DIMENSION(numCells) :: flatn, flatn1
+  implicit none
 
+  integer, INTENT(IN)                       :: numIntCells, numCells
+  real,    INTENT(IN),  DIMENSION(numCells) :: u, p, e
+  real,    INTENT(OUT), DIMENSION(numCells) :: flatn
 
-  real,dimension(numCells) :: scrch1,scrch2,scrch3, scrch4
+  real, dimension(numCells) :: scrch1,scrch2,scrch3
   integer :: i, numIntCells5, numIntCells6, numIntCells7, numIntCells8
   real ::  utest, dutest, dp2, dptest, ptest, dpp, ftilde_up
-  
+  real ::  de1, de2, dee
+
+  !----------------------------------------
+
   numIntCells5 = numIntCells + 5
   numIntCells6 = numIntCells + 6
   numIntCells7 = numIntCells + 7
   numIntCells8 = numIntCells + 8
-  
-  do i = 1, numIntCells8
-     flatn (i) = 0.e0
-     flatn1(i) = 1.e0
-  end do
 
   do i = 2, numIntCells7
 
-! compute the w_j parameter in Eq. A.1 in Colella & Woodward.  w_j is equal to
-! 1 if the jth zone is inside a pressure and velocity jump in the sweep direction,
-! in a manner consistent with a shock; storage for this in hy_shockd removed - KW
+     ! compute the w_j parameter in Eq. A.1 in Colella & Woodward.  w_j is equal to
+     ! 1 if the jth zone is inside a pressure and velocity jump in the sweep direction,
+     ! in a manner consistent with a shock
 
      hy_dp(i)      = p(i+1) - p(i-1)
      hy_du(i)      = u(i+1) - u(i-1)
@@ -99,60 +102,76 @@
      else
         dutest = 0.e0
      endif
-     
-     if (scrch1(i) .LT. 0.e0) then 
+
+     if (scrch1(i) .LT. 0.e0) then
         scrch1(i) = 1.e0
      else
         scrch1(i) = 0.e0
      endif
-     
+
      if (hy_du(i) .GE. 0.e0) scrch1(i) = 0.e0
-     
+
      if (dutest .EQ. 0.e0) scrch1(i) = 0.e0
-     
   end do
-  
-  do i = 3, numIntCells6
 
-       ! hy_shockd removed from here, use Hydro_detectShock instead - KW
+  !----------------
+  ! shock detection
 
+  if ( hy_enrFlattening ) then
 
-       ! compute ftilde, using Eq. A.2 in Colella & Woodward
-
-     dp2 = p(i+2) - p(i-2)
-     
-     if ( abs(dp2) .GT. 0.e0 ) then
-        dpp = hy_dp(i) / dp2 - hy_omg1
-     else
+     ! TAH: Original code only considered dpp in the steepness calculation.
+     !      We extend this to include the total energy steepness as well.
+     !      Additionally, we only flatten when the fields are monotonic
+     !      (i.e. not a saw-tooth profile).
+
+     do i = 3, numIntCells6
+        dp2 = p(i+2) - p(i-2)
+        de2 = e(i+2) - e(i-2)
+        de1 = e(i+1) - e(i-1)
         dpp = 0.e0
-     end if
-     
-     scrch3(i) = scrch1(i) * max (0.e0, dpp * hy_omg2)
-  end do
+        dee = 0.e0
+        if(abs(dp2)>TINY(1.e0)) then
+           if( (dp2*hy_dp(i)>0.e0) .and. (abs(hy_dp(i))<abs(dp2)) ) dpp = hy_dp(i)/dp2
+        endif
+        if(abs(de2)>TINY(1.e0)) then
+           if( (de2*de1>0.e0) .and. (abs(de1)<abs(de2)) ) dee = de1/de2
+        endif
+        scrch3(i) = scrch1(i) * max(0.e0, hy_omg2*(max(dpp,dee)-hy_omg1))
+     end do
+
+  else
+
+     do i = 3, numIntCells6
+        ! compute ftilde, using Eq. A.2 in Colella & Woodward
+        dp2 = p(i+2) - p(i-2)
+
+        if ( abs(dp2) .GT. 0.e0 ) then
+           dpp = hy_dp(i) / dp2 - hy_omg1
+        else
+           dpp = 0.e0
+        end if
+        scrch3(i) = scrch1(i) * max (0.e0, dpp * hy_omg2)
+     end do
 
-! select upstream value
+  end if
+
+  ! select upstream value
 
   do i = 4, numIntCells5
-     if ( hy_dp(i) .LT. 0.e0 ) then
+     if ( hy_dp(i) < 0.e0 ) then
         ftilde_up = scrch3(i+1)
-     else if ( hy_dp(i) .EQ. 0.e0 ) then
+     else if ( hy_dp(i) == 0.e0 ) then
         ftilde_up = scrch3(i)
      else
         ftilde_up = scrch3(i-1)
      endif
 
-! select the maximum flattening
-
+     ! select the maximum flattening
      flatn(i) = max (scrch3(i), ftilde_up)
+  end do
+
+  do i = 4, numIntCells5
      flatn(i) = max (0.e0, min (1.e0, flatn(i)))
-     
-     ! select Godunov method, if desired
-     
-     flatn (i) = flatn(i) * (1.e0 - hy_igodu) + hy_igodu
-     
-     flatn1(i) = 1.e0 - flatn(i)
   end do
-  
-  return
-end subroutine flaten
 
+end subroutine flaten
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/grdvel.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/grdvel.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/grdvel.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/grdvel.F90	2021-02-23 17:47:43.127204135 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/grdvel
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/grdvel
 !!
 !! NAME
 !!
@@ -31,6 +31,12 @@
 !! PARAMETERS
 !!
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 subroutine grdvel (blockID)
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90	2021-02-23 17:07:53.625546398 -0500
@@ -1,8 +1,8 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_data
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data
 !!
 !! NAME
-!!   
-!!  Hydro_data 
+!!
+!!  Hydro_data
 !!
 !!
 !! SYNOPSIS
@@ -12,9 +12,14 @@
 !!
 !! DESCRIPTION
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
-
 module Hydro_data
 
 #include "Flash.h"
@@ -24,9 +29,15 @@
   logical, save :: hy_fluxCorrect,       &
                    hy_hybridRiemann,     &
                    hy_useGravity,        &
-                   hy_charLimiting
+                   hy_burnShocks,        &
+                   hy_charLimiting,      &
+                   hy_forceApproxRiemann
+
+  logical ,save :: hy_renormalizeSpecies,      hy_limitSpecies,               &
+                   hy_renormalizeMassScalars,  hy_limitMassScalars
+  real, save    :: hy_speciesSumTolerance,     hy_speciesSumToleranceAbort,   &
+                   hy_massScalarsSumTolerance, hy_massScalarsSumToleranceAbort
 
-  
   integer, save :: hy_geometry, &
                    hy_irenorm, &
                    hy_eosMode,  &
@@ -40,18 +51,25 @@
 
   integer, save, dimension(MDIM) :: hy_dirGeom
 
-  real, save :: hy_cfl,         &
-                hy_dp_sh_md,    &
-                hy_cvisc,       &
-                hy_epsiln,      &
-                hy_eintSwitch, &
-                hy_omg1,        &
-                hy_omg2,        &
+  real, save :: hy_cfl, hy_cflInit, &
+                hy_cfl_crit,        &
+                hy_cfl_factor_min,  &
+                hy_dp_sh_md,        &
+                hy_cvisc,           &
+                hy_epsiln,          &
+                hy_eintSwitch,      &
+                hy_omg1,            &
+                hy_omg2,            &
                 hy_vgrid
 
   logical,save :: hy_useHydro, hy_updateHydroFluxes, &
                   hy_useDiffuse
 
+
+  !--- TAH: Added runtime selection of Riemann solvers (April 6, 2016)
+  integer, save :: hy_RiemannSolver, hy_RiemannSolverHybrid
+  character(len=MAX_STRING_LENGTH), save :: hy_RiemannSolver_str, hy_RiemannSolverHybrid_str
+
   !!*****End Runtime parameters*****
 
 
@@ -61,61 +79,96 @@
   !!*****End Directly Derived from Runtime parameters*****
 
   ! Maybe should become a runtime parameter.
-  ! Set to .TRUE. if you want shock information to be saved in
-  ! SHOK_VAR and/or SHKS_VAR, presumably for analyzing shock
-  ! locations and strengths, even if hybrid_riemann is off;
-  ! see hy_ppm_sweep .
-  logical, parameter :: hy_alwaysCallDetectShock = .FALSE.
+  logical, parameter :: hy_alwaysCallDetectShock = .FALSE. !.TRUE.
 
   logical, save :: hy_movingGrid
-  
+
+  !!AJG CFL violation diagnostics
+  integer, parameter :: CW_STATES=1, CW_DIV=CW_STATES+1, CW_FLX=CW_DIV+1
+  logical, save :: hy_cfl_warning(CW_FLX)
+  real, save :: hy_cfl_max(CW_FLX)
+  logical, save :: hy_cfl_dynamical
+  real, save :: hy_cfl_factor
+
   !!*****Constants database
   real,    save :: hy_pi
 
 
   integer, parameter :: hy_numXN     = NSPECIES+NMASS_SCALARS
-
+  integer, parameter :: hy_numMS     = NMASS_SCALARS
   !!******** PPM KERNEL DATA STRUCTURES SCALARS************
 
   !! - in PPMData
-  integer, save :: hy_igodu, hy_nriem, hy_iplm
+  integer, save :: hy_igodu, hy_nriem, hy_iplm, hy_interp_6thOrder
   real, save    :: hy_small, hy_smallu, hy_smallp, &
-                   hy_smlrho, hy_smallx, hy_dp_sh, hy_riemanTol
+                   hy_smlrho, hy_smallx, hy_dp_sh, &
+                   hy_riemanTol, hy_riemanTolAbort, &
+                   hy_interp_6thC, hy_detect_djump
   logical, save :: hy_ppmModifyStates, hy_leveque,  &
+                   hy_useFlattening,            &
+                   hy_enrFlattening,            &
+                   hy_useSteepening,            &
                    hy_useCmaAdvection,          &
                    hy_useCmaFlattening,         &
-                   hy_useSteepening,            &
+                   hy_useCmaSteepening,         &
+                   hy_gridIsUniform,            &
                    hy_useCellAreasForFluxes
 
+  logical, save :: hy_rieman_printDiag = .false.
+
+  logical, save :: hy_xl_boundary_noflow, hy_xr_boundary_noflow, &
+                   hy_yl_boundary_noflow, hy_yr_boundary_noflow, &
+                   hy_zl_boundary_noflow, hy_zr_boundary_noflow
+
   integer,parameter :: lowerFace=1,upperFace=2
   integer, dimension(2,MDIM*2) :: neigh
   !!******** PPM KERNEL DATA STRUCTURES ************
 
-#ifdef FIXEDBLOCKSIZE  
+  ! interpolation constants
+  real, save :: hy_cl1 = 0.3125e0
+  real, save :: hy_cl2 = 0.9375e0
+  real, save :: hy_cl3 = -0.3125e0
+  real, save :: hy_cl4 = 0.0625e0
+
+  real, save :: hy_cr1 = 0.0625e0
+  real, save :: hy_cr2 = -0.3125e0
+  real, save :: hy_cr3 = 0.9375e0
+  real, save :: hy_cr4 = 0.3125e0
+
+  real, save :: hy_cc1 = -0.0625e0
+  real, save :: hy_cc2 = 0.5625e0
+  real, save :: hy_cc3 = 0.5625e0
+  real, save :: hy_cc4 = -0.0625e0
+
+  ! multiresolution parameters
+  logical , save :: hy_simpleMask
+  integer, save :: hy_lstart, hy_iord
+  real, save :: hy_numAdaptiveFlux = 0
+  real, save :: hy_numTotFlux = 0
+
+  !!******** PPM KERNEL DATA STRUCTURES ************
+
+#ifdef FIXEDBLOCKSIZE
+  logical, save, dimension(MAXCELLS) :: hy_fluxmask
   real,save, DIMENSION(MAXCELLS) :: hy_dela  , &
                                     hy_dp    , hy_du    , hy_dut   , hy_dutt  , &
                                     hy_drho  , hy_dgame , hy_dgamc , hy_dgrav , &
                                     hy_p6    , hy_u6    , hy_ut6   , hy_utt6  , &
                                     hy_rho6  , hy_game6 , hy_gamc6 , hy_grav6 , &
                                     hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic,&
-                                    hy_gravl , hy_gravr,                  &
+                                    hy_gravl , hy_gravr,                     &
                                     hy_clft  , hy_plft  , hy_uttlft,         &
                                     hy_ulft  , hy_vlft  , hy_utlft ,         &
                                     hy_crght , hy_prght , hy_vrght ,         &
                                     hy_urght , hy_utrght, hy_uttrgt,         &
-                                    hy_gmelft, hy_gmergt,                 &
-                                    hy_gmclft, hy_gmcrgt,                 &
-                                    hy_deint, hy_eint6, hy_eiLft, hy_eiRght
-
-!Ensure array is not zero sized.  This avoids the following 
-!link error when compiling with OpenMP on BG/P.
-!intrfc.F90:378: undefined reference to `$.TPK$.&&N&&hydro_data%hy_dxn'
-#if NSPECIES+NMASS_SCALARS > 0
-  real, save, DIMENSION(MAXCELLS,hy_numXN) :: hy_dxn, hy_xn6 ,hy_xnlft, hy_xnrght
-#else
-  real, save, DIMENSION(MAXCELLS,1) :: hy_dxn, hy_xn6 ,hy_xnlft, hy_xnrght
-#endif
+                                    hy_gmelft, hy_gmergt,                    &
+                                    hy_gmclft, hy_gmcrgt,                    &
+                                    hy_deint,  hy_eint6,                     &
+                                    hy_eLft,   hy_eRght,                     &
+                                    hy_eiLft,  hy_eiRght,                    &
+                                    hy_flatn,  hy_cds
 
+  real, save, DIMENSION(MAXCELLS,hy_numXN) :: hy_dxn, hy_xn6 ,hy_xnlft, hy_xnrght
   real,save, dimension(2,NYB,NZB,MAXBLOCKS) :: hy_xarea,hy_xdtdx,&
        hy_xgrav,hy_xngrav,hy_xfict
   real,save, dimension(NXB,2,NZB,MAXBLOCKS) :: hy_yarea,hy_ydtdy,&
@@ -141,8 +194,10 @@
                            hy_urght , hy_utrght, hy_uttrgt, &
                            hy_gmelft, hy_gmergt, &
                            hy_gmclft, hy_gmcrgt, &
-                           hy_deint, hy_eint6, hy_eiLft, hy_eiRght
-  
+                           hy_deint, hy_eint6,   &
+                           hy_eLft,   hy_eRght,  &
+                           hy_eiLft,  hy_eiRght
+
   real, save, allocatable,dimension(:,:) :: hy_dxn,hy_xn6,hy_xnlft, hy_xnrght
   real,save, allocatable, dimension(:,:,:,:) :: hy_xarea,hy_xdtdx,&
        hy_xgrav,hy_xngrav,hy_xfict
@@ -156,7 +211,7 @@
 
 #endif
 
-  real,save,allocatable,dimension(:) :: hy_pstor
+  real,save,allocatable,dimension(:) :: hy_ptrial, hy_perror, hy_wlft, hy_wrght
 
 !! Generated for gravity diagnostic output
   real, save, dimension(MDIM) :: hy_gravMass, hy_gravMassXYZ, hy_gravMassZYX,&
@@ -170,16 +225,4 @@
   integer, save, target, dimension(hy_numPresFluxes) :: hy_specialFluxVars
   data hy_specialFluxVars  / 0 /
 
-  logical, save :: hy_threadBlockList = .false.
-  logical, save :: hy_threadWithinBlock = .false.
-
-  !$omp threadprivate(hy_dela,hy_dp,hy_du,hy_dut,hy_dutt,&
-  !$omp hy_drho,hy_dgame,hy_dgamc,hy_dgrav,hy_p6,hy_u6,hy_ut6,hy_utt6,&
-  !$omp hy_rho6,hy_game6,hy_gamc6,hy_grav6,hy_pwl,hy_pwr,hy_dpw,hy_pw6l,&
-  !$omp hy_pw6r,hy_pwcubic,hy_gravl,hy_gravr,hy_clft,hy_plft,hy_uttlft,&
-  !$omp hy_ulft,hy_vlft,hy_utlft,hy_crght,hy_prght,hy_vrght,hy_urght,&
-  !$omp hy_utrght,hy_uttrgt,hy_gmelft,hy_gmergt,hy_gmclft,hy_gmcrgt,&
-  !$omp hy_deint,hy_eint6,hy_eiLft,hy_eiRght,&
-  !$omp hy_dxn,hy_xn6,hy_xnlft,hy_xnrght,hy_pstor)
-
 end module Hydro_data
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90	2021-02-23 17:48:20.372287506 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_finalize
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize
 !!
 !! NAME
 !!
@@ -13,6 +13,12 @@
 !!  Deallocates any memory that has been allocated in the Hydro Unit
 !!  and prepares the unit for shutdown
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!
 !!***
 
@@ -23,9 +29,17 @@
   use Hydro_data, ONLY : hy_yarea,hy_ydtdy, hy_ygrav,hy_yngrav,hy_yfict
   use Hydro_data, ONLY : hy_zarea,hy_zdtdz, hy_zgrav,hy_zngrav,hy_zfict
   use Hydro_data, ONLY : hy_fluxCorrect
+  use Hydro_data, ONLY : hy_numAdaptiveFlux, hy_numTotFlux
+
   implicit none
+
 #include "Flash.h"
+
+  print *, "Flux evals: ", hy_numAdaptiveFlux, " of ", hy_numTotFlux
+
 #ifndef FIXEDBLOCKSIZE
+
+
   if(hy_fluxCorrect) then
 !!     deallocate(hy_xarea)
 !!     deallocate(hy_xngrav)
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90	2021-02-23 17:48:32.811649342 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_init
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init
 !!
 !! NAME
 !!
@@ -7,29 +7,29 @@
 !!
 !! SYNOPSIS
 !!
-!!  call Hydro_init()
-!!  
+!!  Hydro_init()
+!!
 !!
 !! DESCRIPTION
-!! 
+!!
 !!  Initialize unit scope variables which are typically the runtime parameters.
 !!  This must be called once by Driver_initFlash.F90 first. Calling multiple
 !!  times will not cause any harm but is unnecessary.
 !!
 !! ARGUMENTS
 !!
-!!  
+!!
 !!
 !! PARAMETERS
 !!
-!!   These are the runtime parameters used in the split PPM Hydro 
+!!   These are the runtime parameters used in the split PPM Hydro
 !!   implementation.
 !!
 !!   To see the default parameter values and all the runtime parameters
 !!   specific to your simulation check the "setup_params" file in your
 !!   object directory.
 !!   You might have overwritten these values with the flash.par values
-!!   for your specific run.  
+!!   for your specific run.
 !!
 !!    useHydro [BOOLEAN]
 !!        Should any Hydro calculations be performed?
@@ -39,17 +39,9 @@
 !!    geometry [STRING]
 !!        Grid geometry
 !!    eosMode [STRING]
-!!        the default Eos mode, usually MODE_DENS_EI, 
-!!        where density and energy are provided to 
-!!        calculate pressure and temperature. This is used
-!!        for calling Eos on guard cells initially (where necessary).
-!!    hy_eosModeAfter [STRING]
-!!        the Eos mode, usually MODE_DENS_EI,
-!!        where density and energy are provided to 
-!!        calculate pressure and temperature. This is used
-!!        for calling Eos on interior cells of all leaf blocks
-!!        at the end of each Hydro sweep.
-!!    irenorm
+!!        the default Eos mode, usually MODE_DENS_EI,
+!!        where density and energy are provided to
+!!        calculate pressure and temperature
 !!    flux_correct [BOOLEAN]
 !!    hybrid_riemann [BOOLEAN]
 !!    smlrho [REAL]
@@ -61,6 +53,7 @@
 !!        Artificial viscosity constant
 !!    dp_sh_md
 !!    epsiln [REAL]
+!!    burnShocks [BOOLEAN]
 !!    nriem [INTEGER]
 !!    omg1
 !!        PPM dissipation parameter omega1
@@ -80,50 +73,72 @@
 !!       Enable Guodunov method instead of PPM if set to 1
 !!    iplm [INTEGER]
 !!       Enable piecewise linear method instead of PPM if set to 1
+!!    use_flattening [BOOLEAN]
 !!    use_steepening [BOOLEAN]
 !!    use_cma_flattening [BOOLEAN]
+!!    use_cma_steepening [BOOLEAN]
 !!    use_cma_advection [BOOLEAN]
 !!    ppmEnerFluxConstructionMeth [INTEGER]
 !!    ppmEintFluxConstructionMeth [INTEGER]
 !!    ppmEnerCompFluxConstructionMeth [INTEGER]
 !!    ppmEnerCompFluxConstructionMeth [INTEGER]
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 subroutine Hydro_init()
 
   !!These are all the runtime parameters.  First the logicals, then the
-  !! integers, then the reals    
+  !! integers, then the reals
 
   use Hydro_data
-  use Driver_interface, ONLY : Driver_abortFlash, Driver_getMype, &
-    Driver_getNumProcs
+  use Driver_interface, ONLY : Driver_abortFlash
+  use Driver_interface, ONLY : Driver_getMype, Driver_getNumProcs
   use Logfile_interface, ONLY : Logfile_stampMessage, &
-    Logfile_stampVarMask, Logfile_stamp
+    Logfile_stampVarMask
   use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
     RuntimeParameters_mapStrToInt
   use Grid_interface, ONLY:  Grid_setFluxHandling
 
   implicit none
 
-
   logical :: useSpecialFluxVar
   integer :: istat
 
 #include "constants.h"
-#include "Flash.h"  
+#include "Flash.h"
+#include "PPM.h"
 
   character(len=MAX_STRING_LENGTH) :: str_geometry,eosModeString
-  logical :: threadBlockListBuild, threadWithinBlockBuild
-  
+
   ! Everybody should know these
   call Driver_getMype(MESH_COMM,hy_meshMe)
   call Driver_getNumProcs(MESH_COMM,hy_meshNumProcs)
 
-  
-  call RuntimeParameters_get("useHydro", hy_useHydro)
 
+  call RuntimeParameters_get("useHydro", hy_useHydro)
+  if (hy_meshMe == MASTER_PE) then
+     if ( hy_useHydro ) then
+        write(*,'(a)') "[Hydro_init] Hydro enabled."
+     else
+        write(*,'(a)') "[Hydro_init] Hydro disabled."
+     end if
+  end if
   !!hydro_timestep
   call RuntimeParameters_get ("cfl", hy_cfl)
+  call RuntimeParameters_get ("cfl_init", hy_cflInit)
+  call RuntimeParameters_get ("cfl_crit", hy_cfl_crit)
+  call RuntimeParameters_get ("cfl_dynamical", hy_cfl_dynamical)
+
+  if (hy_cfl_crit<hy_cfl) hy_cfl_crit=hy_cfl*1.01 ! give some margin
+  hy_cfl_factor = 1.e0
+
+  call RuntimeParameters_get ("cfl_factor_min", hy_cfl_factor_min)
 
   !!**Hydro_sweep RuntimeParameters
 
@@ -132,57 +147,122 @@
 
   call RuntimeParameters_get ("eosMode", eosModeString)
   call RuntimeParameters_mapStrToInt(eosModeString, hy_eosMode)
-  if(hy_useHydro) then
-    if(hy_eosMode/=MODE_DENS_EI)&
+  if(hy_eosMode/=MODE_DENS_EI)&
        call Driver_abortFlash("Hydro : Wrong Eos mode for PPM")
-  endif
+
+  call RuntimeParameters_get ("hy_eosModeAfter", eosModeString)
+  call RuntimeParameters_mapStrToInt(eosModeString, hy_eosModeAfter)
+  if(hy_eosModeAfter/=MODE_DENS_EI .AND. &
+       hy_eosModeAfter/=hy_eosMode)&
+       call Driver_abortFlash("Hydro : Wrong Eos mode for After PPM Sweep")
+
   hy_useGravity = .false.
 #ifdef GRAVITY
   call RuntimeParameters_get("useGravity", hy_useGravity)
 #endif
   call RuntimeParameters_get("useDiffuse", hy_useDiffuse)
-  
-  call RuntimeParameters_get("irenorm", hy_irenorm)
-  call RuntimeParameters_get("flux_correct",   hy_fluxCorrect)
-  call RuntimeParameters_get("hybrid_riemann", hy_hybridRiemann)
+
+  !-------------------------
+  ! species error thresholds
+
+  call RuntimeParameters_get("hy_renormalizeSpecies",       hy_renormalizeSpecies )
+  call RuntimeParameters_get("hy_limitSpecies",             hy_limitSpecies )
+  call RuntimeParameters_get("hy_speciesSumTolerance",      hy_speciesSumTolerance )
+  call RuntimeParameters_get("hy_speciesSumToleranceAbort", hy_speciesSumToleranceAbort )
+
+  if ( NSPECIES == 0 ) then
+     if ( hy_limitSpecies .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No species found - disable limiting.'
+     hy_limitSpecies = .false.
+     if ( hy_renormalizeSpecies .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No species found - disable renormalization.'
+     hy_renormalizeSpecies = .false.
+  end if
+
+  !------------------------------
+  ! mass scalars error thresholds
+
+  call RuntimeParameters_get("hy_renormalizeMassScalars",       hy_renormalizeMassScalars )
+  call RuntimeParameters_get("hy_limitMassScalars",             hy_limitMassScalars )
+  call RuntimeParameters_get("hy_massScalarsSumTolerance",      hy_massScalarsSumTolerance )
+  call RuntimeParameters_get("hy_massScalarsSumToleranceAbort", hy_massScalarsSumToleranceAbort )
+
+  if ( NMASS_SCALARS == 0 ) then
+     if ( hy_limitMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars found - disable limiting.'
+     hy_limitMassScalars = .false.
+     if ( hy_renormalizeMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars groups found - disable renormalization.'
+     hy_renormalizeMassScalars = .false.
+  end if
+
+  if ( NMASS_SCALAR_GROUPS == 0 ) then
+     if ( hy_renormalizeMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars groups found - disable renormalization.'
+     hy_renormalizeMassScalars = .false.
+  end if
+
+  call RuntimeParameters_get("flux_correct",              hy_fluxCorrect)
+  call RuntimeParameters_get("hybrid_riemann",            hy_hybridRiemann)
+  call RuntimeParameters_get("forceApproxRiemann",	  hy_forceApproxRiemann)
 
   !!**Hydro_updateSolution
   call RuntimeParameters_get("updateHydroFluxes", hy_updateHydroFluxes)
-  call RuntimeParameters_get("smlrho",hy_smlrho)
-  call RuntimeParameters_get("smallp",hy_smallp)  
-  call RuntimeParameters_get("eintSwitch",hy_eintSwitch)  
- 
+  call RuntimeParameters_get("smlrho",            hy_smlrho)
+  call RuntimeParameters_get("smallp",            hy_smallp)
+  call RuntimeParameters_get("eintSwitch",        hy_eintSwitch)
+
   !!**Hydro_1d needs
-  call RuntimeParameters_get("cvisc", hy_cvisc)
+  call RuntimeParameters_get("cvisc",    hy_cvisc)
   call RuntimeParameters_get("dp_sh_md", hy_dp_sh_md )
-  call RuntimeParameters_get("epsiln", hy_epsiln)
+  call RuntimeParameters_get("epsiln",   hy_epsiln)
 
-  call RuntimeParameters_get("nriem", hy_nriem)
-  call RuntimeParameters_get("omg1", hy_omg1)
-  call RuntimeParameters_get("omg2", hy_omg2)
-  call RuntimeParameters_get("rieman_tol", hy_riemanTol)
-  call RuntimeParameters_get("small", hy_small)
-  !!smallp from update_soln
-  call RuntimeParameters_get("smallu",hy_smallu)
-  call RuntimeParameters_get("smallx",hy_smallx)
-  !!smlrho from update_soln
-  call RuntimeParameters_get("vgrid", hy_vgrid)
+! Define this ifdef variable in your unit's Config file with PPDEFINE
+#ifdef FLASH_SOURCEBURN
+  call RuntimeParameters_get("burnShocks", hy_burnShocks)
+#else
+  hy_burnShocks = .false.
+#endif
+  call RuntimeParameters_get("nriem",            hy_nriem)
+  call RuntimeParameters_get("omg1",             hy_omg1)
+  call RuntimeParameters_get("omg2",             hy_omg2)
+  call RuntimeParameters_get("rieman_tol",       hy_riemanTol)
+  call RuntimeParameters_get("rieman_tol_abort", hy_riemanTolAbort)
+  call RuntimeParameters_get("small",            hy_small)
+  call RuntimeParameters_get("smallu",           hy_smallu)
+  call RuntimeParameters_get("smallx",           hy_smallx)
+  call RuntimeParameters_get("vgrid",            hy_vgrid)
 
   !!**PPM inputs
   call RuntimeParameters_get("ppm_modifystates", hy_ppmModifystates)
-  call RuntimeParameters_get("leveque",hy_leveque)
-  call RuntimeParameters_get("igodu", hy_igodu)
-  call RuntimeParameters_get("iplm", hy_iplm)
+  call RuntimeParameters_get("leveque",          hy_leveque)
+  call RuntimeParameters_get("igodu",            hy_igodu)
+  call RuntimeParameters_get("iplm",             hy_iplm)
+  call RuntimeParameters_get("gridIsUniform",    hy_gridIsUniform)
+  call RuntimeParameters_get("interp_6thOrder",  hy_interp_6thOrder)
+  call RuntimeParameters_get("interp_6thC",      hy_interp_6thC)
+  call RuntimeParameters_get("detect_djump",     hy_detect_djump)
+
+  call RuntimeParameters_get("xl_boundary_noflow", hy_xl_boundary_noflow)
+  call RuntimeParameters_get("xr_boundary_noflow", hy_xr_boundary_noflow)
+  call RuntimeParameters_get("yl_boundary_noflow", hy_yl_boundary_noflow)
+  call RuntimeParameters_get("yr_boundary_noflow", hy_yr_boundary_noflow)
+  call RuntimeParameters_get("zl_boundary_noflow", hy_zl_boundary_noflow)
+  call RuntimeParameters_get("zr_boundary_noflow", hy_zr_boundary_noflow)
+
+
   call RuntimeParameters_get("ppmEnerFluxConstructionMeth", hy_ppmEnerFluxConstructionMeth)
   call RuntimeParameters_get("ppmEintFluxConstructionMeth", hy_ppmEintFluxConstructionMeth)
   if (hy_ppmEintFluxConstructionMeth==-1) hy_ppmEintFluxConstructionMeth = hy_ppmEnerFluxConstructionMeth
+
   call RuntimeParameters_get("ppmEnerCompFluxConstructionMeth", hy_ppmEnerCFluxConstructionMeth)
   call RuntimeParameters_get("ppmEintCompFluxConstructionMeth", hy_ppmEintCFluxConstructionMeth)
   if (hy_ppmEintCFluxConstructionMeth==-1) hy_ppmEintCFluxConstructionMeth = hy_ppmEnerCFluxConstructionMeth
-  call RuntimeParameters_get("use_steepening", hy_useSteepening)
+
+  call RuntimeParameters_get("use_flattening",     hy_useFlattening)
+  call RuntimeParameters_get("enr_flattening",     hy_enrFlattening)
+  call RuntimeParameters_get("use_steepening",     hy_useSteepening)
   call RuntimeParameters_get("use_cma_flattening", hy_useCmaFlattening)
-  call RuntimeParameters_get("use_cma_advection", hy_useCmaAdvection)
-  call RuntimeParameters_get("charLimiting", hy_charLimiting) ! new characteristic limiting - DL
+  call RuntimeParameters_get("use_cma_steepening", hy_useCmaSteepening)
+  call RuntimeParameters_get("use_cma_advection",  hy_useCmaAdvection)
+  call RuntimeParameters_get("charLimiting",       hy_charLimiting) ! new characteristic limiting - DL
+  call RuntimeParameters_get("mrppm_iord", hy_iord)
+  call RuntimeParameters_get("mrppm_simplemask", hy_simpleMask)
 
   call RuntimeParameters_get("hy_fluxRepresentation", hy_fluxRepresentation)
   if (trim(hy_fluxRepresentation) == "auto") then
@@ -197,6 +277,56 @@
 #endif
   end if
 
+
+  ! Riemann solver selection for both normal operation and hybridization around shocks (TAH: April 6, 2016)
+  ! Flags are defined in PPM.h
+  call RuntimeParameters_get("ppmRiemannSolver",       hy_RiemannSolver_str)
+  call RuntimeParameters_get("ppmRiemannSolverHybrid", hy_RiemannSolverHybrid_str)
+  if((trim(hy_RiemannSolver_str) == "Exact") .or. &
+     (trim(hy_RiemannSolver_str) == "exact") .or. &
+     (trim(hy_RiemannSolver_str) == "EXACT") ) then
+     hy_RiemannSolver = EXACTRS
+  elseif( (trim(hy_RiemannSolver_str) == "ausmp") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMP") ) then
+     hy_RiemannSolver = AUSMP
+  elseif( (trim(hy_RiemannSolver_str) == "ausmpup") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMPUP") ) then
+     hy_RiemannSolver = AUSMPUP
+  elseif( (trim(hy_RiemannSolver_str) == "ausmpupit") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMPUPIT") ) then
+     hy_RiemannSolver = AUSMPUPIT
+  elseif( (trim(hy_RiemannSolver_str) == "ROEP") .or. &
+          (trim(hy_RiemannSolver_str) == "roep") ) then
+     hy_RiemannSolver = ROEP
+  
+
+  else
+     call Driver_abortFlash&
+          ("[Hydro_init]: The Riemann Solver is of unknown type: " // &
+           "Options are exact, AUSMP, AUSMPUP,AUSMPUPIT, or ROEP")
+  endif
+
+  if((trim(hy_RiemannSolverHybrid_str) == "hlle") .or. &
+     (trim(hy_RiemannSolverHybrid_str) == "HLLE") ) then
+     hy_RiemannSolverHybrid = HLLE
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmp") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMP") ) then
+     hy_RiemannSolverHybrid = AUSMP
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmpup") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMPUP") ) then
+     hy_RiemannSolverHybrid = AUSMPUP
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmpupit") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMPUPIT") ) then
+     hy_RiemannSolverHybrid = AUSMPUPIT
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ROEP") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "roep") ) then
+     hy_RiemannSolverHybrid = ROEP
+  else
+     call Driver_abortFlash&
+          ("[Hydro_init]: The Hybridization Riemann Solver is of unknown type: " // &
+           "Options are HLLE, AUSMP, or AUSMPUP.")
+  endif
+
   if (.NOT. hy_useHydro) return ! If Hydto is turned off; return here before anything serious gets done.
 
   if (hy_fluxRepresentation == "hybrid") then
@@ -231,7 +361,7 @@
   if (hy_meshMe .EQ. MASTER_PE) then
      print*,'Info: Hydro_init has set hy_specialFluxVars to ',hy_specialFluxVars
   end if
-  
+
 
 !! Determine some unit-wide variables that are directly derived from
 !! Runtime parameters
@@ -262,32 +392,33 @@
   else
      call Driver_abortFlash("unsupported geometry ")
   end if
-  
+
   if (hy_vgrid /= 0.e0) then
      hy_movingGrid = .true.
   else
      hy_movingGrid = .false.
   endif
 
+!! Ensure that hy_hybridRiemann is false if we're in 1D.
+!! Added by Tim in r6222, but not sure why. Commented out as helps with the entropy noise in ySNR models. (tp/201901xx)
+!!  if (hy_hybridRiemann .and. (NDIM==1)) call Driver_abortFlash('[Hydro_init] ERROR: Cannot have hybrid Riemann in 1D')
+
 !! Now initialize the GC Mask
 
   hy_gcMask = .FALSE.
 
+#ifdef FL_NON_PERMANENT_GUARDCELLS
   hy_gcMask(PRES_VAR) = .TRUE.
+#else
+  if (hy_hybridRiemann .AND. (hy_cvisc .ne. 0.0)) hy_gcMask(PRES_VAR) = .TRUE.
+#endif
 
   hy_gcMask(DENS_VAR) = .TRUE.
   hy_gcMask(ENER_VAR) = .TRUE.
 #ifdef EINT_VAR
   hy_gcMask(EINT_VAR) = .TRUE.
 #endif
-  hy_gcMask(TEMP_VAR) = .TRUE.     !for now - only used for initial guess by Helmholtz Eos - KW
-
-#ifdef GAMC_VAR
-  hy_gcMask(GAMC_VAR) = .TRUE.
-#endif
-#ifdef GAME_VAR
-  hy_gcMask(GAME_VAR) = .TRUE.
-#endif
+  hy_gcMask(TEMP_VAR) = .TRUE.     !for now - only used fo initial guess by Helmholtz Eos - KW
 
 #ifdef GPOT_VAR
   hy_gcMask(GPOT_VAR) = .TRUE.
@@ -296,25 +427,6 @@
   hy_gcMask(GPOL_VAR) = .TRUE.
 #endif
 
-#ifdef SGAX_VAR
-  hy_gcMask(SGAX_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-#ifdef SGAY_VAR
-  hy_gcMask(SGAY_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-#ifdef SGAZ_VAR
-  hy_gcMask(SGAZ_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-#ifdef SGXO_VAR
-  hy_gcMask(SGXO_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-#ifdef SGYO_VAR
-  hy_gcMask(SGYO_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-#ifdef SGZO_VAR
-  hy_gcMask(SGZO_VAR) = .TRUE.  !special meaning for sink particles
-#endif
-  
   hy_gcMask(VELX_VAR) = .TRUE.
 #if NDIM >= 2
 #ifdef VELY_VAR
@@ -334,27 +446,9 @@
 
   call Logfile_stampVarMask(hy_gcMask, .FALSE., '[Hydro_init]', 'gcNeed')
 
-  call RuntimeParameters_get ("hy_eosModeAfter", eosModeString)
-  call RuntimeParameters_mapStrToInt(eosModeString, hy_eosModeAfter)
-  if(hy_eosModeAfter/=MODE_DENS_EI .AND. &
-       hy_eosModeAfter/=hy_eosMode)&
-       call Driver_abortFlash("Hydro : Wrong Eos mode for After PPM Sweep")
-
-  call RuntimeParameters_get("threadBlockListBuild", threadBlockListBuild)
-  call RuntimeParameters_get("threadHydroBlockList", hy_threadBlockList)
+  !!AJG CFL violation diagnostics
+  hy_cfl_warning(:) = .false.
+  hy_cfl_max(:)     = -1.e0
 
-  call RuntimeParameters_get("threadWithinBlockBuild", threadWithinBlockBuild)
-  call RuntimeParameters_get("threadHydroWithinBlock", hy_threadWithinBlock)
-
-  if (hy_threadBlockList .and. .not. threadBlockListBuild) then
-     call Logfile_stamp('WARNING! Turning off block list threading '//&
-          'because FLASH is not built appropriately','[Hydro_init]')
-     hy_threadBlockList = .false.
-  end if
-  if (hy_threadWithinBlock .and. .not. threadWithinBlockBuild) then
-     call Logfile_stamp('WARNING! Turning off within block threading '//&
-          'because FLASH is not built appropriately','[Hydro_init]')
-     hy_threadWithinBlock = .false.
-  end if
 
 end subroutine Hydro_init
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90	2021-02-23 17:49:11.755782169 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/hy_ppm_block
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block
 !!
 !! NAME
 !!
@@ -7,8 +7,8 @@
 !! SYNOPSIS
 !!
 !!  call hy_ppm_block(integer(IN):: hy_meshMe,
-!!                integer(IN):: blockID,
 !!                integer(IN):: sweepDir, 
+!!                integer(IN):: blockID,
 !!                real(IN)   :: dt, 
 !!                real(IN)   :: dtOld, 
 !!                integer(IN):: blkLimits(HIGH,MDIM),
@@ -99,6 +99,12 @@
 !!
 !!   solnData --  a pointer to the cell-centered data for the whole block
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 
@@ -122,13 +128,13 @@
                          thirdCoord       , &
                          radialCoord      , &
                          ugrid            , &
-                         tempArea, tempGrav1d_o, tempGrav1d,          &
-                         tempDtDx, tempFict, tempAreaLeft,            &
-                         tempFlx,                & 
-                         shock, solnData )
+                         tempArea, tempGrav1d_o, tempGrav1d, &
+                         tempDtDx, tempFict, tempAreaLeft,   &
+                         tempFlx,                            & 
+                         shock, solnData)
 
 
-  use Hydro_data, ONLY : hy_useGravity, hy_dirGeom,&
+  use Hydro_data, ONLY : hy_useGravity, hy_geometry, hy_dirGeom,&
                          hy_dela, &
                          hy_dp , hy_du , hy_dut, hy_dutt, &
                          hy_drho, hy_dgame, hy_dgamc, hy_dgrav, &
@@ -141,20 +147,24 @@
                          hy_crght , hy_prght , hy_vrght ,         &
                          hy_urght , hy_utrght, hy_uttrgt, &
                          hy_gmelft, hy_gmergt, &
-                         hy_gmclft, hy_gmcrgt, hy_pstor,hy_nriem, &
+                         hy_gmclft, hy_gmcrgt, &
+                         hy_ptrial, hy_perror, &
+                         hy_wlft, hy_wrght, &
+                         hy_nriem, &
                          hy_deint,hy_eint6,hy_eiLft, hy_eiRght,     &
                          hy_dxn,hy_xn6,hy_xnlft, hy_xnrght,     &
                          hy_updateHydroFluxes, &
                          hy_useCellAreasForFluxes, &
-                         hy_gravMass
+                         hy_gravMass, &
+                         hy_flatn, hy_cds
 
   use Grid_interface, ONLY : Grid_getSingleCellVol, Grid_getBlkData
   use Driver_interface, ONLY : Driver_abortFlash
   use Timers_interface, ONLY : Timers_start, Timers_stop
-  
+
   !! LOCAL - effective SCRATCH space
   !! shock and shock_multid are for shock detecting
-  !! u -> utrt are for PPM.
+  !! u -> utrt and omgz are for PPM.
   !! These are slices that we pass to PPM.  Optimized for vector
   !! machines years ago, PPM needs these slices in a very specific
   !! way.  This is costly.  
@@ -173,6 +183,7 @@
   integer, intent(IN),dimension(2,MDIM) :: blkLimitsGC,blkLimits,bcs
 
   real,    pointer :: solnData(:,:,:,:) 
+  !real, intent(INOUT), optional, dimension(numCells) :: vhalf
 
   !! ------------
 
@@ -183,12 +194,27 @@
   integer :: numIntCells
   integer,parameter :: numXn=NSPECIES+NMASS_SCALARS
   integer :: sp,istat
-
+  integer,dimension(MDIM) :: size,startingPos
   ! for gravity accumulation, implemented by LBR 12/19/2006
   integer, DIMENSION(MDIM) :: point
   real               :: cellVolume
   real, allocatable :: faceAreas(:,:,:), cellVolumes(:,:,:)
 
+  ! multiresolution
+  integer :: numflx, numintrfc
+  integer, allocatable :: fluxKey(:), intrfcKey(:)
+
+  interface
+    subroutine ppm_mask(lb, numCells, primDim, secCell, terCell, &
+                          numintrfc, numflx, mask, intrfcmask, flxmask)
+      implicit none
+      integer, intent(in) :: lb, numCells, primDim, secCell, terCell
+      integer, intent(inout) :: numflx, numintrfc
+      real, dimension(numCells, 2), intent(in) :: mask
+      integer, allocatable, intent(inout) :: intrfcmask(:), flxmask(:)
+    end subroutine
+  end interface
+
 #ifdef FIXEDBLOCKSIZE
   real, intent(OUT), DIMENSION(GRID_ILO_GC:GRID_IHI_GC,       &
                                GRID_JLO_GC:GRID_JHI_GC,          &
@@ -225,9 +251,15 @@
                                utflx, uttflx, eflx, eintflx,&
                                u, ut, utt, rho, p, e,  &
                                tmp, gamc, game,  &
-                               uttp, utbt, utlt, utrt
+                               uttp, utbt, utlt, utrt, &
+                               omgz
   real, DIMENSION(MAXCELLS, NSPECIES+NMASS_SCALARS) :: xn,xnflx
+
+  ! multiresolution copy arrays (hardcoded 2 for number of levels currently)
+  real, dimension(MAXCELLS, 2) :: mrmask
+
   istat = 0
+
 #else
   real, intent(OUT), DIMENSION(blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS),       &
                                blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS),          &
@@ -256,14 +288,24 @@
                                            radialCoord     , &
                                            ugrid
 
+
+
+
   real, DIMENSION(numCells) :: dtdx, areaLeft, area, cvol, grav, ngrav, fict, shock_multid
   real, DIMENSION(numCells) :: rhoflx, uflx, pav, &
                                utflx, uttflx, eflx, eintflx,&
                                u, ut, utt, rho, p, e,  &
                                tmp, gamc, game,  &
-                               uttp, utbt, utlt, utrt
+                               uttp, utbt, utlt, utrt, &
+                               omgz
   real, DIMENSION(numCells, NSPECIES+NMASS_SCALARS) :: xn, xnflx
 
+  ! multiresolution copy arrays (hardcoded 2 for number of levels currently)
+  real, dimension(numCells, 2) :: mrmask
+
+  save omgz
+  !======================================================================
+
   allocate(hy_dela(numCells),stat = istat) 
   if (istat==0)allocate(hy_dp(numCells),stat = istat) 
   if (istat==0)allocate( hy_du(numCells),stat = istat)  
@@ -318,10 +360,13 @@
   if (istat==0)allocate( hy_gmcrgt(numCells),stat = istat) !! valid
   
 #endif
+  if (istat==0)allocate( hy_ptrial(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_perror(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_wlft(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_wrght(hy_nriem + 2),stat = istat)
 
-  if (istat==0)allocate( hy_pstor(hy_nriem + 2),stat = istat)
-  if (istat .NE. 0) then
-     call Driver_abortFlash("Memory allocation error in subroutine hy_block!")
+  if (istat /= 0) then
+     call Driver_abortFlash("[hy_ppm_block] ERROR: Memory allocation error in subroutine hy_block!")
   end if
 
 
@@ -332,16 +377,15 @@
 !    conservation step.                                             
 
 !!$ IMPORTANT -- MOVE TO DATABASE. THIS IS A TEMPORARY HACK 
-  grav(:) = 0.
+  grav(:) = 0.e0
           
   call Timers_start("hy_block")
 ! if we are using a hybrid Riemann solvers (i.e. using HLLE inside shocks), 
-! then use a multi-dimensional shock detection -- this is more 
-! accurate than the 1-d one done by the original PPM algorithm.
-! Flags that signal in which cells a shock was detected are passed to this
-! subroutine in the shock_multid array, if necessary.
+! then start by doing a multi-dimensional shock detection -- this is more 
+! accurate than the 1-d one done by the PPM algorithm            
+
+  tempFlx(:,:,:,:) = 0.e0
 
-  tempFlx(:,:,:,:) = 0.0
   select case (sweepDir)
   case (SWEEP_X)
      j1 = 1; j2 = 1
@@ -387,6 +431,9 @@
            tmp(iloGc:ihiGc)  = solnData( TEMP_VAR, iloGc:ihiGc, j, k )
            game(iloGc:ihiGc) = solnData( GAME_VAR, iloGc:ihiGc, j, k )
            gamc(iloGc:ihiGc) = solnData( GAMC_VAR, iloGc:ihiGc, j, k )
+           mrmask(iloGc:ihiGc,2) = solnData( MSKA_VAR, iloGc:ihiGc, j, k )
+           mrmask(iloGc:ihiGc,1) = solnData( MSKB_VAR, iloGc:ihiGc, j, k )
+           !vhalf(iloGc:ihiGc)= solnData( VXIN_VAR, iloGc:ihiGc, j, k )
 
            if (numXN > 0) then
 #ifdef INDEXREORDER
@@ -414,6 +461,14 @@
            utrt(iloGc:ihiGc) = solnData(VELZ_VAR, iloGc:ihiGc, j, k2)
            utlt(iloGc:ihiGc) = solnData(VELZ_VAR, iloGc:ihiGc, j, k1)
 
+           ! support for rotation (only 2D cylindrical)
+           omgz = 0.e0
+#ifdef SAMZ_MSCALAR
+
+           if ( (hy_geometry == CYLINDRICAL) .and. (hy_dirGeom(IAXIS) == RAD_CYL) ) &
+                omgz(iloGc:ihiGc) = solnData(SAMZ_MSCALAR, iloGc:ihiGc, j, k)/primaryCoord(iloGc:ihiGc)**2
+#endif
+
            xbot = 0.
            xtop = 0.           
            ybot = secondCoord(j1)
@@ -424,73 +479,109 @@
            zrgt = thirdCoord(k2)
            numIntCells = ihi-ilo+1
 
-!        call Timers_start("hydro_1d")
-           call hydro_1d (blockID,numIntCells,numCells,numguard, bcs,&
-                          sweepDir, hy_meshMe,dt, dtOld, &
-                          j, k,                       &
-                          hy_dirGeom(IAXIS), hy_useGravity,              &
-                          xbot, xtop,                 &
-                          ybot, ytop, ylft, yrgt,     &
-                          zlft, zrgt, ugrid,          &
-                          primaryCoord ,              &
-                          primaryLeftCoord ,          &
-                          primaryRghtCoord ,          &
-                          primaryDx        ,          &
-                          secondCoord      ,          &
-                          thirdCoord       ,          &
-                          radialCoord     ,           &
-                          u, ut, utt, rho, p, e, tmp, game, gamc,   &
-                          xn, utbt, uttp, utlt, utrt,               &
-                          shock_multid,                             &
-                          dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
-                          rhoflx, uflx, pav, utflx, uttflx,         &
-                          eflx, eintflx, xnflx)
-!        call Timers_stop("hydro_1d")
+           ! get masking information from wavelet module
+           !call Timers_start("ppm_mask")
+           call ppm_mask(blockID, numCells, IAXIS, j, k, numintrfc, numflx, &
+                             mrmask, intrfcKey, fluxKey)
+           !call Timers_stop("ppm_mask")
+
+           ! determine which routine to call
+           call Timers_start("hydro_1d")
+
+           ! call hydro routine to get fluxes
+           call ppm_hydro(blockID,numIntCells,numCells,numintrfc, &
+                         numflx,intrfcKey,fluxKey, &
+                         numguard, bcs, &
+                         sweepDir, hy_meshMe,dt, dtOld, &
+                         j, k,                       &
+                         hy_dirGeom(IAXIS), hy_useGravity,              &
+                         xbot, xtop,                 &
+                         ybot, ytop, ylft, yrgt,     &
+                         zlft, zrgt, ugrid,          &
+                         primaryCoord ,              &
+                         primaryLeftCoord ,          &
+                         primaryRghtCoord ,          &
+                         primaryDx        ,          &
+                         secondCoord      ,          &
+                         thirdCoord       ,          &
+                         radialCoord     ,           &
+                         u, ut, utt, rho, p, e, tmp, game, gamc,   &
+                         xn, utbt, uttp, utlt, utrt,               &
+                         omgz,                                     &
+                         shock_multid,                             &
+                         dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
+                         rhoflx, uflx, pav, utflx, uttflx,         &
+                         eflx, eintflx, xnflx)
+
+           ! deallocate memory from compressed array maps
+           deallocate(intrfcKey)
+           deallocate(fluxKey)
+           call Timers_stop("hydro_1d")
+
+#ifdef FLTX_VAR
+
+           solnData(FLTX_VAR,iloGc:ihiGc,j,k) = hy_flatn(iloGc:ihiGc)
+#endif
+#ifdef CDSX_VAR
+
+           solnData(CDSX_VAR,iloGc:ihiGc,j,k) = hy_cds(iloGc:ihiGc)
+#endif
 
            tempAreaLeft(ilo:ihi+1,j,k) = areaLeft(ilo:ihi+1)
-         if (hy_updateHydroFluxes) then
-           do i = ilo, ihi
-              tempDtDx(i,j,k)     = dtdx(i)
-              tempArea(i,j,k)     = area(i)
-              tempGrav1d_o(i,j,k) = grav(i)
-              tempGrav1d(i,j,k)   = ngrav(i)
-              tempFict(i,j,k)     = fict(i)
-
-              point(IAXIS) = i
-              call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
-              hy_gravMass(IAXIS) = hy_gravMass(IAXIS) + grav(i)*rho(i)*cellVolume
-           enddo
-           
-           do i = ilo, ihi+1
-              tempFlx(RHO_FLUX,i,j,k)  = rhoflx(i)
-              tempFlx(U_FLUX,i,j,k)    = uflx(i)
-              tempFlx(P_FLUX,i,j,k)    = pav(i)
-              tempFlx(UT_FLUX,i,j,k)   = utflx(i)
-              tempFlx(UTT_FLUX,i,j,k)  = uttflx(i)
-              tempFlx(E_FLUX,i,j,k)    = eflx(i)
-              tempFlx(EINT_FLUX,i,j,k) = eintflx(i)
-           enddo
-           
-           do sp = 1, numXn
+           if (hy_updateHydroFluxes) then
+              do i = ilo, ihi
+                 tempDtDx(i,j,k)     = dtdx(i)
+                 tempArea(i,j,k)     = area(i)
+                 tempGrav1d_o(i,j,k) = grav(i)
+                 tempGrav1d(i,j,k)   = ngrav(i)
+                 tempFict(i,j,k)     = fict(i)
+
+                 point(IAXIS) = i
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(IAXIS) = hy_gravMass(IAXIS) + grav(i)*rho(i)*cellVolume
+              enddo
+
               do i = ilo, ihi+1
-                 tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(i,sp)
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(i)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(i)
+                 tempFlx(P_FLUX,i,j,k)    = pav(i)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(i)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(i)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(i)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(i)
+              enddo
+
+              do sp = 1, numXn
+                 do i = ilo, ihi+1
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(i,sp)
+                 end do
+              enddo
+           else
+              do i = ilo, ihi
+                 tempDtDx(i,j,k)     = dtdx(i)
+                 tempArea(i,j,k)     = area(i)
+                 tempGrav1d_o(i,j,k) = grav(i)
+                 tempGrav1d(i,j,k)   = ngrav(i)
+                 tempFict(i,j,k)     = fict(i)
               end do
-           enddo
-         else
-           do i = ilo, ihi
-              tempDtDx(i,j,k)     = dtdx(i)
-              tempArea(i,j,k)     = area(i)
-              tempGrav1d_o(i,j,k) = grav(i)
-              tempGrav1d(i,j,k)   = ngrav(i)
-              tempFict(i,j,k)     = fict(i)
-           end do
-         end if
+           end if
         
         end do !!j loop
      end do !!k loop
 
+     size(IAXIS)=blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1
+     size(JAXIS)=blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1
+     size(KAXIS)=blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1
+
+
 #if NDIM >= 2
+
   case (SWEEP_Y)
+
+     ! although one could assume userForce is sufficiently selective, it seems prudent
+     ! to zero out the specific angular momentum to avoid any possible problems
+     omgz = 0.e0
+
      k1 = 1; k2 = 1
      !! Loop over the interior to create the 1d slices
      jlo = blkLimits(LOW,JAXIS)
@@ -536,6 +627,10 @@
            tmp(jloGc:jhiGc)  = solnData( TEMP_VAR,i, jloGc:jhiGc, k )
            game(jloGc:jhiGc) = solnData( GAME_VAR,i, jloGc:jhiGc, k )
            gamc(jloGc:jhiGc) = solnData( GAMC_VAR,i, jloGc:jhiGc, k )
+           mrmask(jloGc:jhiGc,2) = solnData( MSKA_VAR, i, jloGc:jhiGc, k )
+           mrmask(jloGc:jhiGc,1) = solnData( MSKB_VAR, i, jloGc:jhiGc, k )
+           !vhalf(jloGc:jhiGc)= solnData( VYIN_VAR,i, jloGc:jhiGc, k )
+
            if (numXN > 0) then
 #ifdef INDEXREORDER
               xn(jloGc:jhiGc,:) = solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1),i,jloGc:jhiGc,k)
@@ -554,8 +649,8 @@
            utbt = 0
            utrt = 0
            utlt = 0
-           uttp(jloGc:jhiGc) = solnData(VELX_VAR, i2 ,jloGc:jhiGc, k)
-           utbt(jloGc:jhiGc) = solnData(VELX_VAR, i1,jloGc:jhiGc, k)
+           uttp(jloGc:jhiGc) = solnData(VELX_VAR, i2, jloGc:jhiGc, k)
+           utbt(jloGc:jhiGc) = solnData(VELX_VAR, i1, jloGc:jhiGc, k)
            utrt(jloGc:jhiGc) = solnData(VELZ_VAR,i, jloGc:jhiGc, k2)
            utlt(jloGc:jhiGc) = solnData(VELZ_VAR,i, jloGc:jhiGc, k1)
 
@@ -564,8 +659,17 @@
            zlft = thirdCoord(k1)
            zrgt = thirdCoord(k2)
            numIntCells = jhi-jlo+1
-!        call Timers_start("hydro_1d")
-           call hydro_1d (blockID,numIntCells,numCells,numguard,bcs, &
+
+           ! get masking information from wavelet module
+           !call Timers_start("ppm_mask")
+           call ppm_mask(blockID, numCells, JAXIS, i, k, numintrfc, numflx, &
+                             mrmask, intrfcKey, fluxKey)
+           !call Timers_stop("ppm_mask")
+
+           ! call hydro routine
+           call Timers_start("hydro_1d")
+           call ppm_hydro(blockID,numIntCells,numCells,numintrfc,numflx, &
+                          intrfcKey, fluxKey, numguard, bcs, &
                           sweepDir, hy_meshMe ,dt,dtOld, &
                           i, k,                       &
                           hy_dirGeom(JAXIS), hy_useGravity,                           &
@@ -578,61 +682,81 @@
                           primaryDx        , &
                           secondCoord      , &
                           thirdCoord       , &
-                          radialCoord     , &
+                          radialCoord      , &
                           u, ut, utt, rho, p, e, tmp, game, gamc,  &
                           xn, utbt, uttp, utlt, utrt,              &
+                          omgz,                                    &
                           shock_multid,                            &
                           dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
                           rhoflx, uflx, pav, utflx, uttflx,        &
                           eflx, eintflx, xnflx)
-!        call Timers_stop("hydro_1d")
+
+           ! deallocate memory from compressed array maps
+           deallocate(intrfcKey)
+           deallocate(fluxKey)
+           call Timers_stop("hydro_1d")
+
+#ifdef FLTY_VAR
+
+           solnData(FLTY_VAR,i,jloGc:jhiGc,k) = hy_flatn(jloGc:jhiGc)
+#endif
+#ifdef CDSY_VAR
+
+           solnData(CDSY_VAR,i,jloGc:jhiGc,k) = hy_cds(jloGc:jhiGc)
+#endif
 
            tempAreaLeft(i,jlo:jhi+1,k) = areaLeft(jlo:jhi+1)
-         if (hy_updateHydroFluxes) then
-           do j = jlo, jhi
-              tempDtDx(i,j,k)     = dtdx(j)
-              tempArea(i,j,k)     = area(j)
-              tempGrav1d_o(i,j,k) = grav(j)   !! Gradient in y direction
-              tempGrav1d(i,j,k)   = ngrav(j)  !! Gradient in y direction + (dt/dtOld)*(difference in time)
-              tempFict(i,j,k)     = fict(j)
-
-              point(JAXIS) = j
-              call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
-              hy_gravMass(JAXIS) = hy_gravMass(JAXIS) + grav(j)*rho(j)*cellVolume !  grav(j)*rho(j)*cellVolume 
+           if (hy_updateHydroFluxes) then
+              do j = jlo, jhi
+                 tempDtDx(i,j,k)     = dtdx(j)
+                 tempArea(i,j,k)     = area(j)
+                 tempGrav1d_o(i,j,k) = grav(j)   !! Gradient in y direction
+                 tempGrav1d(i,j,k)   = ngrav(j)  !! Gradient in y direction + (dt/dtOld)*(difference in time)
+                 tempFict(i,j,k)     = fict(j)
+
+                 point(JAXIS) = j
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(JAXIS) = hy_gravMass(JAXIS) + grav(j)*rho(j)*cellVolume !  grav(j)*rho(j)*cellVolume 
+
+              enddo
 
-           enddo
-           
-           do j = jlo, jhi+1
-              tempFlx(RHO_FLUX,i,j,k)  = rhoflx(j)
-              tempFlx(U_FLUX,i,j,k)    = uflx(j)
-              tempFlx(P_FLUX,i,j,k)    = pav(j)
-              tempFlx(UT_FLUX,i,j,k)   = utflx(j)
-              tempFlx(UTT_FLUX,i,j,k)  = uttflx(j)
-              tempFlx(E_FLUX,i,j,k)    = eflx(j)
-              tempFlx(EINT_FLUX,i,j,k) = eintflx(j)
-           enddo
-           
-           do sp = 1, numXn
               do j = jlo, jhi+1
-                 tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(j,sp)
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(j)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(j)
+                 tempFlx(P_FLUX,i,j,k)    = pav(j)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(j)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(j)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(j)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(j)
+              enddo
+
+              do sp = 1, numXn
+                 do j = jlo, jhi+1
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(j,sp)
+                 end do
+              enddo
+           else
+              do j = jlo, jhi
+                 tempDtDx(i,j,k)     = dtdx(j)
+                 tempArea(i,j,k)     = area(j)
+                 tempGrav1d_o(i,j,k) = grav(j)
+                 tempGrav1d(i,j,k)   = ngrav(j)
+                 tempFict(i,j,k)     = fict(j)
               end do
-           enddo
-         else
-           do j = jlo, jhi
-              tempDtDx(i,j,k)     = dtdx(j)
-              tempArea(i,j,k)     = area(j)
-              tempGrav1d_o(i,j,k) = grav(j)
-              tempGrav1d(i,j,k)   = ngrav(j)
-              tempFict(i,j,k)     = fict(j)
-           end do
-         end if
+           end if
+
         end do !!j loop
      end do !!k loop
 
+
+
 #endif
 #if NDIM == 3 
   case (SWEEP_Z) 
 
+     ! although one could assume userForce is sufficiently selective, it seems prudent
+     ! to zero out the specific angular momentum to avoid any possible problems
+     omgz = 0.e0
 
      !! Loop over the interior to create the 1d slices
      klo = blkLimits(LOW,KAXIS)
@@ -680,6 +804,7 @@
            tmp(kloGc:khiGc)  = solnData( TEMP_VAR, i, j, kloGc:khiGc )
            game(kloGc:khiGc) = solnData( GAME_VAR, i, j, kloGc:khiGc )
            gamc(kloGc:khiGc) = solnData( GAMC_VAR, i, j, kloGc:khiGc )
+           !vhalf(kloGc:khiGc)= solnData( VZIN_VAR, i, j, kloGc:khiGc )
 
            if (numXN > 0) then
 #ifdef INDEXREORDER
@@ -703,78 +828,87 @@
            utbt(kloGc:khiGc) = solnData(VELX_VAR, i1, j, kloGc:khiGc)
            utrt(kloGc:khiGc) = solnData(VELY_VAR, i, j2, kloGc:khiGc)
            utlt(kloGc:khiGc) = solnData(VELY_VAR, i, j1, kloGc:khiGc)
-           
+
            xbot = secondCoord(i1)
            xtop = secondCoord(i2)
            ylft = thirdCoord(j1)
            yrgt = thirdCoord(j2)
            numIntCells = khi-klo+1
 !        call Timers_start("hydro_1d")
-           call hydro_1d (blockID,numIntCells,numCells,numguard,bcs, &
-                          sweepDir, hy_meshMe ,dt,dtOld, &
-                          i, j,                       &
-                          hy_dirGeom(KAXIS), hy_useGravity,                           &
-                          xbot, xtop,                              &
-                          ybot, ytop, ylft, yrgt,                  &
-                          zlft, zrgt, ugrid,                       &
-                          primaryCoord ,     &
-                          primaryLeftCoord , &
-                          primaryRghtCoord , &
-                          primaryDx        , &
-                          secondCoord      , &
-                          thirdCoord       , &
-                          radialCoord     , &
-                          u, ut, utt, rho, p, e, tmp, game, gamc,  &
-                          xn, utbt, uttp, utlt, utrt,              &
-                          shock_multid,                            &
+           call hydro_1d (blockID,numIntCells,numCells,numguard,bcs,     &
+                          sweepDir, hy_meshMe, dt, dtOld,                &
+                          i, j,                                          &
+                          hy_dirGeom(KAXIS), hy_useGravity,              &
+                          xbot, xtop,                                    &
+                          ybot, ytop, ylft, yrgt,                        &
+                          zlft, zrgt, ugrid,                             &
+                          primaryCoord ,                                 &
+                          primaryLeftCoord ,                             &
+                          primaryRghtCoord ,                             &
+                          primaryDx        ,                             &
+                          secondCoord      ,                             &
+                          thirdCoord       ,                             &
+                          radialCoord      ,                             &
+                          u, ut, utt, rho, p, e, tmp, game, gamc,        &
+                          xn, utbt, uttp, utlt, utrt,                    &
+                          omgz,                                          &
+                          shock_multid,                                  &
                           dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
-                          rhoflx, uflx, pav, utflx, uttflx,        &
+                          rhoflx, uflx, pav, utflx, uttflx,              &
                           eflx, eintflx, xnflx)
 !        call Timers_stop("hydro_1d")
+#ifdef FLTZ_VAR
+
+           solnData(FLTZ_VAR,i,j,kloGc:khiGc) = hy_flatn(kloGc:khiGc)
+#endif
+#ifdef CDSZ_VAR
+
+           solnData(CDSZ_VAR,i,j,kloGc:khiGc) = hy_cds(kloGc:khiGc)
+#endif
+
            tempAreaLeft(i,j,klo:khi+1) = areaLeft(klo:khi+1)
-         if (hy_updateHydroFluxes) then
-           do k = klo, khi 
-              tempDtDx(i,j,k)     = dtdx(k)
-              tempArea(i,j,k)     = area(k)
-              tempGrav1d_o(i,j,k) = grav(k)
-              tempGrav1d(i,j,k)   = ngrav(k)
-              tempFict(i,j,k)     = fict(k)
-
-              point(KAXIS) = k
-              call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
-              hy_gravMass(KAXIS) = hy_gravMass(KAXIS) + grav(k)*rho(k)*cellVolume
+           if (hy_updateHydroFluxes) then
+              do k = klo, khi 
+                 tempDtDx(i,j,k)     = dtdx(k)
+                 tempArea(i,j,k)     = area(k)
+                 tempGrav1d_o(i,j,k) = grav(k)
+                 tempGrav1d(i,j,k)   = ngrav(k)
+                 tempFict(i,j,k)     = fict(k)
+
+                 point(KAXIS) = k
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(KAXIS) = hy_gravMass(KAXIS) + grav(k)*rho(k)*cellVolume
+
+              enddo
 
-           enddo
-           
-           do k = klo, khi+1 
-              tempFlx(RHO_FLUX,i,j,k)  = rhoflx(k)
-              tempFlx(U_FLUX,i,j,k)    = uflx(k)
-              tempFlx(P_FLUX,i,j,k)    = pav(k)
-              tempFlx(UT_FLUX,i,j,k)  = utflx(k)
-              tempFlx(UTT_FLUX,i,j,k)  = uttflx(k)
-              tempFlx(E_FLUX,i,j,k)    = eflx(k)
-              tempFlx(EINT_FLUX,i,j,k) = eintflx(k)
-           enddo
-           
-           do sp = 1, numXn
               do k = klo, khi+1 
-                 tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(k,sp)
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(k)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(k)
+                 tempFlx(P_FLUX,i,j,k)    = pav(k)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(k)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(k)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(k)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(k)
+              enddo
+
+              do sp = 1, numXn
+                 do k = klo, khi+1 
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(k,sp)
+                 end do
+              enddo
+
+           else
+              do k = klo, khi
+                 tempDtDx(i,j,k)     = dtdx(k)
+                 tempArea(i,j,k)     = area(k)
+                 tempGrav1d_o(i,j,k) = grav(k)
+                 tempGrav1d(i,j,k)   = ngrav(k)
+                 tempFict(i,j,k)     = fict(k)
               end do
-           enddo
-           
-         else
-           do k = klo, khi
-              tempDtDx(i,j,k)     = dtdx(k)
-              tempArea(i,j,k)     = area(k)
-              tempGrav1d_o(i,j,k) = grav(k)
-              tempGrav1d(i,j,k)   = ngrav(k)
-              tempFict(i,j,k)     = fict(k)
-           end do
-         end if
-           
+           end if
+
         end do
      end do
-     
 #endif
      
   end select
@@ -783,7 +917,11 @@
      deallocate(cellVolumes)
      deallocate(faceAreas)
   end if
-  deallocate( hy_pstor)
+
+  deallocate( hy_ptrial )
+  deallocate( hy_perror )
+  deallocate( hy_wlft )
+  deallocate( hy_wrght )
 
 #ifndef FIXEDBLOCKSIZE
   deallocate(hy_dela) 
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile	2021-02-23 18:04:57.532300511 -0500
@@ -1,16 +1,18 @@
 #	Makefile for 1D piecewise-parabolic method (PPM) module
 
-Hydro += hydro_1d.o \
+Hydro += ppm_hydro.o \
          grdvel.o \
+         cma_flatten.o \
          avisco.o \
-         intrfc.o \
-         rieman.o \
          riemann_hlle.o \
-         states.o \
-         coeff.o \
          detect.o \
          flaten.o \
-         interp.o hy_interpNoLim.o \
-         cma_flatten.o \
-         monot.o hy_nomonot.o \
-	 interp_char.o
+				 ppm_intrfc.o \
+				 ppm_coeff.o \
+				 ppm_interp.o \
+				 ppm_profile.o \
+				 ppm_states.o \
+				 ppm_riemann.o \
+				 ppm_decode.o \
+				 ppm_interp_char.o \
+				 ppm_mask.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90	2021-02-23 17:19:48.160393847 -0500
@@ -0,0 +1,107 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff
+!!
+!! NAME
+!!
+!!  ppm_coeff
+!!
+!! DESCRIPTION
+!!
+!!  Computes PPM coefficients.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!!  PPM coefficients.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine ppm_coeff(numCells, numIntrfcActv, dxvec, &
+                      c1, c2, c3, c4, c5, c6, c7, &
+                      s1, s2, s3, s4, s5, s6, key)
+
+
+  implicit none
+
+  integer, intent(IN) :: numCells, numIntrfcActv
+  real, intent(IN), DIMENSION(numCells) :: dxvec
+  logical, intent(in), dimension(numIntrfcActv) :: key  
+
+  real, intent(inout), dimension(numIntrfcActv) :: c1, c2, c3, c4, c5, c6, c7
+  real, intent(inout), dimension(numIntrfcActv) :: s1, s2, s3, s4, s5, s6
+  !real, dimension(4) :: tmp
+  real, dimension(numIntrfcActv) :: tmp1, tmp2, tmp3, tmp4
+  integer :: i, j
+  real :: dx
+
+  ! help vectorize the code
+  !do i = 1, numIntrfcActv
+  !  j = key(i)
+  !  tmp1(i) = dx(j-2)
+  !  tmp2(i) = dx(j-1)
+  !  tmp3(i) = dx(j)
+  !  tmp4(i) = dx(j+1)
+  !enddo
+
+  ! set dx
+  dx = dxvec(5)
+
+  ! loop over active cells only
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed cell index
+    !i = key(j)
+    !tmp = dx(i-2:i+1)
+
+    ! compute coefficients from eq. 1.6
+    c1(j) = dx / (dx + dx)
+    c2(j) = 1.0 / (dx + dx + dx + dx)
+    c3(j) = 2.0 * dx * c1(j) 
+    c4(j) = (dx+dx) / (2.0*dx+dx)
+    c5(j) = (dx + dx) / (2.0*dx + dx)
+    c6(j) = dx * c4(j)
+    c7(j) = dx * c5(j)
+
+    !  compute average slope coefficients for a_{j}
+    s1(j) = dx / (dx + dx + dx)
+    s2(j) = (2.0*dx + dx) / (dx + dx)
+    s3(j) = (dx + 2.0*dx) / (dx + dx)
+
+    !  compute average slope coefficients for a_{j+1}
+    s4(j) = dx / (dx + dx + dx)
+    s5(j) = (2.0*dx + dx) / (dx + dx)
+    s6(j) = (dx + 2.0*dx) / (dx + dx)
+
+
+  enddo
+
+end subroutine ppm_coeff
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90	2021-02-23 17:11:03.275079393 -0500
@@ -0,0 +1,281 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode
+!!
+!! NAME
+!!
+!!  ppm_decode
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!  Interpolate fluxes.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!!  Full array of flux values on the finest level of local MR hierarchy.
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine ppm_decode(numCells, numintrfc, numflx, hy_numXn, fluxmask, &
+                        rhoflx, uflx, utflx, uttflx, pav, &
+                        eintflx, eflx, xnflx)
+  
+  use Hydro_data, ONLY : hy_cl1, hy_cl2, hy_cl3, hy_cl4, &
+                           hy_cr1, hy_cr2, hy_cr3, hy_cr4, &
+                           hy_cc1, hy_cc2, hy_cc3, hy_cc4, &
+                           hy_lstart, hy_simpleMask, hy_iord
+
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! initialize variables
+  integer, intent(in) :: numCells, hy_numXn
+  integer, intent(in) :: numintrfc, numflx
+  logical, intent(in), dimension(numCells) :: fluxmask
+  real, intent(inout), dimension(numCells) :: rhoflx, uflx, utflx, uttflx, &
+                                                pav, eintflx, eflx
+  real, intent(inout), dimension(numCells,hy_numXn) :: xnflx
+
+  ! local vars
+  integer :: l, n, it, i1, i2, i3, i4, ni, dl
+  integer :: i, j, k
+  real :: c1, c2, c3, c4
+  real :: cl1, cl2, cl3, cl4
+  real :: cc1, cc2, cc3, cc4
+  real :: cr1, cr2, cr3, cr4
+
+
+  if (hy_iord.eq.1) then
+
+    cl1 = 0.5e0; cl2 = 0.5e0; cl3 = 0.e0; cl4 = 0.e0
+    cc1 = 0.e0; cc2 = 0.5e0; cc3 = 0.5e0; cc4 = 0.e0;
+    cr1 = 0.e0; cr2 = 0.e0; cr3 = 0.5e0; cr4 = 0.5e0;
+
+  elseif (hy_iord.eq.3) then
+
+    cl1 = hy_cl1; cl2 = hy_cl2; cl3 = hy_cl3; cl4 = hy_cl4
+    cc1 = hy_cc1; cc2 = hy_cc2; cc3 = hy_cc3; cc4 = hy_cc4
+    cr1 = hy_cr1; cr2 = hy_cr2; cr3 = hy_cr3; cr4 = hy_cr4
+
+  endif
+
+  if (hy_simpleMask) then
+
+    ! loop through levels, start at lstart
+    do l = hy_lstart, wvlt_maxLvl-1
+
+      ! number of cells at this level
+      ni = iCellsInt(l)
+
+      ! current level difference
+      dl = wvlt_maxLvl - l
+
+      ! loop through cells 
+      do i = 1, ni
+
+        ! compute fine-grid index of target interface
+        it = 2**(wvlt_maxLvl-(l+1)) * (2*i-1) + 5
+
+        print *, "l, i, it", l, i, it
+
+        ! coefficients and indices
+        if (i.eq.1) then
+
+          ! compute dependencies
+          i1 = 2**dl * (i-1) + 5
+          i2 = 2**dl * (i) + 5
+          i3 = 2**dl * (i+1) + 5
+          i4 = 2**dl * (i+2) + 5
+
+          ! coefficients
+          c1 = cl1; c2 = cl2; c3 = cl3; c4 = cl4
+          !c3 = 0.e0
+          !c4 = 0.e0
+          !c1 = 0.5e0
+          !c2 = 0.5e0
+
+        elseif (i.eq.ni) then
+
+          ! compute dependencies
+          i1 = 2**dl * (i-3) + 5
+          i2 = 2**dl * (i-2) + 5
+          i3 = 2**dl * (i-1) + 5
+          i4 = 2**dl * (i) + 5
+
+          ! coefficients
+          c1 = cr1; c2 = cr2; c3 = cr3; c4 = cr4
+
+        ! centered scheme
+        else
+
+          ! compute dependencies
+          i1 = 2**dl * (i-2) + 5
+          i2 = 2**dl * (i-1) + 5
+          i3 = 2**dl * (i) + 5
+          i4 = 2**dl * (i+1) + 5
+
+          ! coefficients
+          c1 = cc1; c2 = cc2; c3 = cc3; c4 = cc4
+
+        endif
+
+        ! interpolate fluxes
+        rhoflx(it) = c1*rhoflx(i1) + c2*rhoflx(i2) &
+                     + c3*rhoflx(i3) + c4*rhoflx(i4)
+     
+        uflx(it) = c1*uflx(i1) + c2*uflx(i2) &
+                     + c3*uflx(i3) + c4*uflx(i4)
+
+        utflx(it) = c1*utflx(i1) + c2*utflx(i2) &
+                     + c3*utflx(i3) + c4*utflx(i4)
+
+        uttflx(it) = c1*uttflx(i1) + c2*uttflx(i2) &
+                     + c3*uttflx(i3) + c4*uttflx(i4)
+
+        pav(it) = c1*pav(i1) + c2*pav(i2) &
+                     + c3*pav(i3) + c4*pav(i4)
+
+        eintflx(it) = c1*eintflx(i1) + c2*eintflx(i2) &
+                     + c3*eintflx(i3) + c4*eintflx(i4)
+
+        eflx(it) = c1*eflx(i1) + c2*eflx(i2) &
+                     + c3*eflx(i3) + c4*eflx(i4)
+
+        do n = 1, hy_numXn
+          xnflx(it,n) = c1*xnflx(i1,n) + c2*xnflx(i2,n) &
+                          + c3*xnflx(i3,n) + c4*xnflx(i4,n)
+        enddo
+
+      enddo
+
+    enddo
+
+  else
+
+    ! loop through levels, start at lstart
+    do l = 1, wvlt_maxLvl-1
+
+      ! number of cells at this level
+      ni = iCellsInt(l)
+
+      ! current level difference
+      dl = wvlt_maxLvl - l
+
+      ! loop through cells 
+      do i = 1, ni
+
+        ! compute fine-grid index of target interface
+        it = 2**(wvlt_maxLvl-(l+1)) * (2*i-1) + 5
+
+        if (.not.fluxmask(it)) then
+
+          ! coefficients and indices
+          if (i.eq.1) then
+
+            ! compute dependencies
+            i1 = 2**dl * (i-1) + 5
+            i2 = 2**dl * (i) + 5
+            i3 = 2**dl * (i+1) + 5
+            i4 = 2**dl * (i+2) + 5
+
+            ! coefficients
+            c1 = cl1; c2 = cl2; c3 = cl3; c4 = cl4
+
+          elseif (i.eq.ni) then
+
+            ! compute dependencies
+            i1 = 2**dl * (i-3) + 5
+            i2 = 2**dl * (i-2) + 5
+            i3 = 2**dl * (i-1) + 5
+            i4 = 2**dl * (i) + 5
+
+            ! coefficients
+            c1 = cr1; c2 = cr2; c3 = cr3; c4 = cr4
+
+          ! centered scheme
+          else
+
+            ! compute dependencies
+            i1 = 2**dl * (i-2) + 5
+            i2 = 2**dl * (i-1) + 5
+            i3 = 2**dl * (i) + 5
+            i4 = 2**dl * (i+1) + 5
+
+            ! coefficients
+            c1 = cc1; c2 = cc2; c3 = cc3; c4 = cc4
+
+          endif
+
+          ! interpolate fluxes
+          rhoflx(it) = c1*rhoflx(i1) + c2*rhoflx(i2) &
+                       + c3*rhoflx(i3) + c4*rhoflx(i4)
+       
+          uflx(it) = c1*uflx(i1) + c2*uflx(i2) &
+                       + c3*uflx(i3) + c4*uflx(i4)
+
+          utflx(it) = c1*utflx(i1) + c2*utflx(i2) &
+                       + c3*utflx(i3) + c4*utflx(i4)
+
+          uttflx(it) = c1*uttflx(i1) + c2*uttflx(i2) &
+                       + c3*uttflx(i3) + c4*uttflx(i4)
+
+          pav(it) = c1*pav(i1) + c2*pav(i2) &
+                       + c3*pav(i3) + c4*pav(i4)
+
+          eintflx(it) = c1*eintflx(i1) + c2*eintflx(i2) &
+                       + c3*eintflx(i3) + c4*eintflx(i4)
+
+          eflx(it) = c1*eflx(i1) + c2*eflx(i2) &
+                       + c3*eflx(i3) + c4*eflx(i4)
+
+          do n = 1, hy_numXn
+            xnflx(it,n) = c1*xnflx(i1,n) + c2*xnflx(i2,n) &
+                            + c3*xnflx(i3,n) + c4*xnflx(i4,n)
+          enddo
+
+        endif
+
+      enddo
+
+    enddo
+
+
+
+  endif
+
+end subroutine ppm_decode
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h	2021-02-23 18:16:43.507798049 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h	2021-02-14 18:14:49.606934150 -0500
@@ -9,4 +9,12 @@
 #define UPDATE_BOUND 1
 #define UPDATE_ALL 2
 
-
+!!-----------------------------!!
+!!    RIEMANN SOLVER FLAGS     !!  
+!!-----------------------------!!
+#define EXACTRS 1
+#define HLLE    2
+#define AUSMP   3
+#define AUSMPUP 4
+#define AUSMPUPIT 5
+#define ROEP 6
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90	2021-02-23 17:21:17.337995897 -0500
@@ -1,156 +1,29 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/hydro_1d
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro
 !!
 !! NAME
 !!
-!!  hydro_1d
-!!
-!!
-!! SYNOPSIS
-!!  
-!!  call hydro_1d(integer(in) :: blockID,
-!!                integer(in) :: numIntCells,
-!!                integer(in) :: numCells, 
-!!                integer(in) :: guard,
-!!                integer(in) :: bcs,
-!!                integer(in) :: xyzswp, 
-!!                integer(in) :: hy_meshMe, 
-!!                real(in)    :: dt, 
-!!                real(in)    :: dt_old,                 
-!!                integer(in) :: jCell, 
-!!                integer(in) :: kCell,                             
-!!                integer(in) :: igeom, 
-!!                logical(in) :: useGravity,                             
-!!                real(in)    :: xbot, 
-!!                real(in)    :: xtop,                               
-!!                real(in)    :: ybot, 
-!!                real(in)    :: ytop, 
-!!                real(in)    :: ylft, 
-!!                real(in)    :: yrgt,                   
-!!                real(in)    :: zlft, 
-!!                real(in)    :: zrgt, 
-!!                real(in)    :: ugrid(numCells),
-!!                real(in)    :: primaryCoord(numCells),
-!!                real(in)    :: primaryLeftCoord(numCells),
-!!                real(in)    :: primaryRghtCoord(numCells),
-!!                real(in)    :: primaryDx(numCells),
-!!                real(in)    :: secondCoord(numCells),
-!!                real(in)    :: thirdCoord(numCells),
-!!                real(in)    :: radialCoord(numCells),
-!!                real(in)    :: u(numCells), 
-!!                real(in)    :: ut(numCells), 
-!!                real(in)    :: utt(numCells), 
-!!                real(in)    :: rho(numCells), 
-!!                real(in)    :: p(numCells),
-!!                real(in)    :: e(numCells),
-!!                real(in)    :: tmp(numCells), 
-!!                real(inout) :: game(numCells), 
-!!                real(inout) :: gamc(numCells),   
-!!                real(inout) :: xn(numCells, hy_numXn), 
-!!                real(inout) :: utbt(numCells), 
-!!                real(inout) :: uttp(numCells),
-!!                real(inout) :: utlt(numCells),
-!!                real(inout) :: utrt(numCells),               
-!!                real(in)    :: shock_multid(numCells),
-!!                real(out)   :: dtdx(numCells), 
-!!                real(inout) :: areaLeft(numCells),
-!!                real(out)   :: area(numCells), 
-!!                real(in)    :: cvol(numCells), 
-!!                real(inout) :: grav(numCells), 
-!!                real(out)   :: ngrav(numCells), 
-!!                real(out)   :: fict(numCells),            
-!!                real(out)   :: rhoflx(numCells),
-!!                real(out)   :: uflx(numCells), 
-!!                real(out)   :: pav(numCells), 
-!!                real(out)   :: utflx(numCells), 
-!!                real(out)   :: uttflx(numCells),
-!!                real(out)   :: eflx(numCells), 
-!!                real(out)   :: eintflx(numCells), 
-!!                real(out)   :: xnflx(numCells,hy_numXn))
+!!  ppm_hydro
 !!
 !! DESCRIPTION
 !!
-!!  Compute the 1-d directionally split fluxes through the boundary
-!!  of the computational zone using the PPM method.   
+!!  Computes 1D PPM sweep.
 !!
 !! ARGUMENTS
 !!
-!!   blockID - my blockID
-!!   numIntCells -
-!!   numCells - 
-!!   guard -  number of guard cells
-!!   bcs -
-!!   xyzswp - the direction of the sweep
-!!   hy_meshMe - the local processor number. 
-!!   dt -   current delta t
-!!   dt_old - delta t from previous step
-!!   jCell -   index that indicates where we are in terms of the
-!!             first transversal coordinate, i.e., index for secondCoord
-!!   kCell -   index that indicates where we are in terms of the
-!!             second transversal coordinate, i.e., index for thirdCoord
-!!   igeom -
-!!   useGravity - indication if gravitational acceleration should be account for
-!!   xbot - 
-!!   xtop -                               
-!!   ybot - 
-!!   ytop - 
-!!   ylft - 
-!!   yrgt -                   
-!!   zlft - 
-!!   zrgt -  Values of secondary and third coordinates (at center) for the 1d arrays of 
-!!                   cells that are directly neighboring the current 1d array being swept.
-!!                   Only used in avisco.
-!! 
-!!   ugrid - 
-!!   primaryCoord -  positions of cell centers of the 1d slice
-!!
-!!   primaryLeftCoord -  positions of left interfaces
-!!
-!!   primaryRghtCoord -  positions of right interfaces
+!! RESULT
 !!
-!!   primaryDx -  width of cells in the sweep direction
+!!  Fluxes.
 !!
-!!   secondCoord -  values of the first transverse coordinate to the sweep direction
-!!                   for an x sweep: y coordinates; for a y sweep: x coord; for a z sweep: xcoord
+!! DISCLAIMER
 !!
-!!   thirdCoord -   the second transverse coordinate to the sweep direction
-!!                   for an x sweep: z coordinates; for a y sweep: z coord; for a z sweep: ycoord
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
-!!   radialCoord -  The radial coordinate, no matter whether it's primary, second, or third.
-!!                   Actually, this is currently always the IAXIS coordinate.
-!!   u - 
-!!   ut -
-!!   utt -
-!!   rho -
-!!   p -
-!!   e -
-!!   tmp - 
-!!   game - 
-!!   gamc -  
-!!   xn - 
-!!   utbt - 
-!!   uttp -
-!!   utlt - 
-!!   utrt - 
-!!   shock_multid -
-!!   dtdx - 
-!!   areaLeft -
-!!   area - 
-!!   cvol -
-!!   grav -
-!!   ngrav - 
-!!   fict -
-!!   rhoflx - 
-!!   uflx - 
-!!   pav -
-!!   utflx - 
-!!   uttflx - 
-!!   eflx - 
-!!   eintflx -
-!!   xnflx -
-!!   
 !!***
 
-subroutine hydro_1d (blockID,numIntCells,numCells, guard,bcs,        &
+subroutine ppm_hydro(blockID,numIntCells,numCells, numIntrfcActv, numFluxActv, &
+                     intrfcKey, fluxKey, guard,bcs,        &
                      xyzswp, hy_meshMe, dt, dt_old,                 &
                      jCell, kCell,                             &
                      igeom, useGravity,                             &
@@ -166,28 +39,44 @@
                      radialCoord     , &
                      u, ut, utt, rho, p, e, tmp, game, gamc,   &
                      xn, utbt, uttp, utlt, utrt,               &
+                     omgz,                                     &
                      shock_multid,                             &
                      dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
-                     rhoflx, uflx, pav, utflx, uttflx,         &
+                     rhoflx, uflx, pflx, utflx, uttflx,         &
                      eflx, eintflx, xnflx)
 
 
   use Hydro_data, ONLY : hy_dirGeom, hy_movingGrid, hy_useCellAreasForFluxes, &
-       hy_epsiln, hy_omg1, hy_omg2
+                         hy_epsiln, hy_omg1, hy_omg2, &
+                         hy_cfl_crit, hy_cfl_warning, hy_cfl_max, CW_FLX
   use Hydro_data, ONLY : hy_cvisc, hy_useCmaAdvection, hy_smallx, hy_smallp
   use Hydro_data, ONLY : hy_numXn, hy_hybridRiemann, hy_updateHydroFluxes
   use Hydro_data, ONLY : hy_ppmEnerFluxConstructionMeth
-  use Driver_interface, ONLY : Driver_abortFlash
+  use Hydro_data, ONLY : hy_xl_boundary_noflow, hy_xr_boundary_noflow, &
+                         hy_yl_boundary_noflow, hy_yr_boundary_noflow, &
+                         hy_zl_boundary_noflow, hy_zr_boundary_noflow
+  use Hydro_data, ONLY : hy_forceApproxRiemann, hy_RiemannSolver, hy_RiemannSolverHybrid
+  use Hydro_data, ONLY : hy_fluxmask
+  use wvlt_data, ONLY : wvlt_interpHydro
+
+  use Grid_data,  ONLY : gr_imin, gr_imax, gr_jmin, gr_jmax, gr_kmin, gr_kmax
+
+  use Driver_interface,  ONLY : Driver_abortFlash
   use Gravity_interface, ONLY : Gravity_accelOneRow
-  use hy_ppm_interface, ONLY: hy_ppm_force, hy_ppm_geom, hy_ppm_completeGeomFactors
+  use hy_ppm_interface,  ONLY: hy_ppm_force, hy_ppm_geom, hy_ppm_completeGeomFactors
+  use Timers_interface, ONLY : Timers_start, Timers_stop
+
   implicit none
-  
+
 #include "Flash.h"
 #include "constants.h"
+#include "PPM.h"
 
-!--arguments-------------------------
+
+  ! arguments
   integer, intent(IN) ::  blockID,jCell, kCell, numIntCells,numCells,&
                           xyzswp, hy_meshMe,igeom, guard
+  integer, intent(in) :: numIntrfcActv, numFluxActv
   real, intent(IN) :: dt, dt_old
 
   logical, intent(IN) :: useGravity
@@ -207,48 +96,72 @@
   real, DIMENSION(numCells), intent(OUT)   :: area
   real, DIMENSION(numCells, hy_numXn), intent(OUT) :: xnflx
   real, DIMENSION(numCells), intent(OUT) :: dtdx, ngrav, fict
-  real, DIMENSION(numCells), intent(OUT) :: rhoflx, uflx, pav, &
+  real, DIMENSION(numCells), intent(OUT) :: rhoflx, uflx, pflx, &
                                             utflx, uttflx, eflx, eintflx
 
-  
-
   real, DIMENSION(numCells, hy_numXn), intent(INOUT) :: xn
-  real, intent(IN) :: xbot, xtop, ybot 
+  real, intent(IN) :: xbot, xtop, ybot
   real, intent(IN) :: ytop, ylft, yrgt, zlft, zrgt
   real, intent(IN), DIMENSION(numCells) :: ugrid
   real, intent(INOUT), DIMENSION(numCells) :: game, gamc, utbt, &
-                                              uttp, utlt, utrt
-
-
-!--locals-------------------------
-
-  real, DIMENSION(numCells, hy_numXn) :: xnav, xnl, xnr
-
-  real, DIMENSION(numCells)    :: rhoav, uav, utav, uttav, eint, &
-              &                   rhol, rhor, ul, ur, utl, utr, uttl, uttr, &
-              &                   pl, pr, vl, vr, gamcl, gamcr, ce, &
-              &                   urell, ugrdl, gameav, gamel, gamer, &
-              &                   eintl, eintr, eintAv, &
-              &                   v, dvol, &
-              &                   ograv, hgrav
-
+                                              uttp, utlt, utrt! , vhalf
+  real, intent(IN), DIMENSION(numCells)    :: omgz
 
-  
-  real, DIMENSION(numCells) ::  scrch1, scrchEkin
-  real, DIMENSION(numCells) ::  avis
-  real, DIMENSION(numCells) ::  xzn, yzn, zzn
-  real, DIMENSION(numCells) :: xlold, xrold, dxold, dvold, &
-                               alold, aold, arear
-  
-  integer :: i, n, kk
+  ! locals
+  logical :: xl_noflow, xr_noflow
+  integer :: local_RiemannSolver
   integer :: numIntCells4, numIntCells5, numIntCells8
-  
-  real ::  dtfac, dg
-  real ::  c
-
-!  real :: pres_jump
+  integer :: i, n, j, k
+  real ::  dtfac, dg, dudt
+  real :: scrchEkin, c
+  real :: cfl_max
   integer,dimension(2) :: pos
-  
+  real, dimension(numCells) :: ce, eint, &
+                                v, dvol, ograv, hgrav
+  real, DIMENSION(numCells) :: avis
+  real, DIMENSION(numCells) :: xzn, yzn, zzn
+  real, DIMENSION(numCells) :: xlold, xrold, dxold, dvold, &
+                                alold, aold, arear
+
+  ! compressed arrays
+  integer, dimension(numIntrfcActv) :: intrfcKey
+  integer, dimension(numFluxActv) :: fluxKey
+  real, dimension(numFluxActv) :: scrch1
+  real, dimension(numIntrfcActv) :: rho_left, rho_right, u_left, u_right, ut_left, &
+                                    ut_right, utt_left, utt_right, p_left, p_right, &
+                                    gamc_left, gamc_right, game_left, &
+                                    game_right, eint_left, eint_right, &
+                                    grav_left, grav_right, v_left, v_right, &
+                                    pw_left, pw_right
+  real, dimension(numIntrfcActv,hy_numXn) :: xn_left, xn_right
+
+  real, dimension(numFluxActv) :: drho_left, drho_right, du_left, du_right, &
+                                  dut_left, dut_right, dutt_left, dutt_right, &
+                                  dp_left, dp_right, deint_left, deint_right, &
+                                  dgamc_left, dgamc_right, dgame_left, &
+                                  dgame_right, dgrav_left, dgrav_right, dpw_left, &
+                                  dpw_right
+  real, dimension(numFluxActv,hy_numXn) :: dxn_left, dxn_right
+
+  real, dimension(numFluxActv) :: rho6_left, rho6_right, u6_left, &
+                                    u6_right, ut6_left, ut6_right, utt6_left, &
+                                    utt6_right, p6_left, p6_right, eint6_left, &
+                                    eint6_right, gamc6_left, gamc6_right, &
+                                    game6_left, game6_right, grav6_left, &
+                                    grav6_right, pw6_left, pw6_right
+  real, dimension(numFluxActv,hy_numXn) :: xn6_left, xn6_right
+
+  real, dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                    utrght, uttlft, uttrght, plft, &
+                                    prght, eilft, eirght, gmelft, &
+                                    gmerght, gmclft, gmcrght, &
+                                    vlft, vrght
+  real, dimension(numFluxActv,hy_numXn) :: xnlft, xnrght
+
+  real, dimension(numFluxActv) :: rhoav, uav, utav, uttav, &
+                                    pav, gameav, eintav
+  real, dimension(numFluxActv,hy_numXn) :: xnav
+
 #ifndef RHO_FLUX
   call Driver_abortFlash("[HYDRO_1D] ERROR: rhoflx not defined")
 #endif
@@ -271,221 +184,275 @@
   call Driver_abortFlash("[HYDRO_1D] ERROR: eintflx not defined")
 #endif
 
+    numIntCells4 = numIntCells + 4
+    numIntCells5 = numIntCells + 5
+    numIntCells8 = numIntCells + 8
 
-                        ! initialize grav arrays to zero
-  hgrav(:) = 0.e0       ! need to reconsider whether this
-  ngrav(:) = 0.e0       ! is the best place to do this
-
+    !---------------------------
+    if (.NOT. hy_useCellAreasForFluxes) then
+       call hy_ppm_geom (numIntCells, numCells, jCell, kCell, xyzswp, igeom,  &
+            &     areaLeft, arear, area, primaryDx, dvol, &
+            &     primaryLeftCoord, primaryRghtCoord,  &
+            &     radialCoord, thirdCoord)
+    else
+       call hy_ppm_completeGeomFactors(numIntCells4, numCells, igeom, primaryDx, &
+            radialCoord(jCell), dvol, cvol, &
+            area, areaLeft)
+    end if
 
-  numIntCells4 = numIntCells + 4
-  numIntCells5 = numIntCells + 5
-  numIntCells8 = numIntCells + 8
-
-  !---------------------------
-  if (.NOT. hy_useCellAreasForFluxes) then
-     call hy_ppm_geom (numIntCells, numCells, jCell, kCell, xyzswp, igeom,  &
-          &     areaLeft, arear, area, primaryDx, dvol, &
-          &     primaryLeftCoord, primaryRghtCoord,  &
-          &     radialCoord, thirdCoord)
-  else
-     call hy_ppm_completeGeomFactors(numIntCells4, numCells, igeom, primaryDx, &
-          radialCoord(jCell), dvol, cvol, &
-          area, areaLeft)
-  end if
-
-  !---------------------------
-  if (useGravity) then
-     pos(1)=jCell; pos(2)=kCell
+    !---------------------------
+    if (useGravity) then
+       pos(1)=jCell; pos(2)=kCell
 #ifdef GPOL_VAR
 #ifndef GPOT_VAR
-     call Driver_abortFlash("Shouldn't have gpol defined without gpot")
+       call Driver_abortFlash("Shouldn't have gpol defined without gpot")
 #endif
 #endif
 
 #if defined(GPOT_VAR) && defined(GPOL_VAR) && defined(FLASH_GRAVITY_TIMEDEP)
-     ! Gravity implementation defines FLASH_GRAVITY_TIMEDEP -> time-dependent gravity field,
-     ! interpolate the acceleration linearly in time (pointwise) - KW
-     ograv(:) = 0.e0       ! initialize array to zero
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,ograv,GPOL_VAR)
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav,GPOT_VAR)
-     dtfac = dt/dt_old
-
-     do i = 1,numIntCells8
-        dg       = dtfac*(grav(i) - ograv(i))
-        hgrav(i) = grav(i) + 0.5e0*dg
-        ngrav(i) = grav(i) +       dg
-     enddo
+       ! Gravity implementation defines FLASH_GRAVITY_TIMEDEP -> time-dependent gravity field,
+       ! interpolate the acceleration linearly in time (pointwise) - KW
+       ograv(:) = 0.e0       ! initialize array to zero
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,ograv,GPOL_VAR)
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav,GPOT_VAR)
+       dtfac = dt/dt_old
+
+       do i = 1,numIntCells8
+          dg       = dtfac*(grav(i) - ograv(i))
+          hgrav(i) = grav(i) + 0.5e0*dg
+          ngrav(i) = grav(i) +       dg
+       enddo
 
 #else
-     ! FLASH_GRAVITY_TIMEDEP not defined -> assume time-independent gravity field.
-     ! Also if GPOT_VAR or GPOL_VAR defined -> use current accel without time
-     ! interpolation, i.e., handle like time-independent gravity field - KW
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav)
-     hgrav = grav
-     ngrav = grav
+       ! FLASH_GRAVITY_TIMEDEP not defined -> assume time-independent gravity field.
+       ! Also if GPOT_VAR or GPOL_VAR defined -> use current accel without time
+       ! interpolation, i.e., handle like time-independent gravity field - KW
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav)
+       hgrav = grav
+       ngrav = grav
 #endif
 
-  else
+    else
 
-     hgrav(:) = 0.e0
-     ngrav(:) = 0.e0
+       hgrav(:) = 0.e0
+       ngrav(:) = 0.e0
 
-  end if
+    end if
 
-  if (hy_updateHydroFluxes) then
+    if (hy_updateHydroFluxes) then
 
     !---------------------------
     ! For non-cartesian geometries, this call sets fict to have non-zero
     ! values.
     !---------------------------
-     call hy_ppm_force(numCells, numIntCells, jCell, kCell, igeom, &
-                primaryCoord, radialCoord, thirdCoord, u, ut, utt, fict)
+    call hy_ppm_force( numCells, numIntCells, jCell, kCell, igeom, &
+                       primaryCoord, radialCoord, thirdCoord, u, ut, utt, fict )
 
-
-    do i = 2, numIntCells8
-       ugrdl(i) = 0.5e0 * (ugrid(i) + ugrid(i-1))
-    end do
-    ugrdl(1) = ugrdl(2)
+    !call userForce( numCells, numIntCells, jCell, kCell, igeom, xyzswp,&
+    !                primaryCoord, radialCoord, secondCoord, thirdCoord,&
+    !                u, ut, utt, omgz, fict )
+
+    !do i = 2, numIntCells8
+    !   ugrdl(i) = 0.5e0 * (ugrid(i) + ugrid(i-1))
+    !end do
+    !ugrdl(1) = ugrdl(2)
 
     do i = 1, numIntCells8
-       v(i)  = 1.e0 / rho(i)
-       c     = sqrt (gamc(i) * p(i) * rho(i))
+       v(i) = 1.e0 / rho(i)
+       c = sqrt(gamc(i) * p(i) * rho(i))
        ce(i) = c*v(i)
     end do
 
 
-    ! Initialization -- grid/geometry factors
-
+    ! initialization -- grid/geometry factors
     do i = 1, numIntCells8
        dtdx(i) = dt / primaryDx(i)
     enddo
 
-    ! Note - if igeom = 3, 4, or 5, the x coordinate will be a radial
+    ! note - if igeom = 3, 4, or 5, the x coordinate will be a radial
     ! coordinate and the index jCell will always refer to the x direction.
-
-    if (igeom >= PHI_CYL) then
-       do i = 1, numIntCells8
-          dtdx(i) = dtdx(i) / radialCoord(jCell)
-       enddo
-    endif
-    if (igeom == PHI_SPH) then
-      do i = 1, numIntCells8
-        dtdx(i) = dtdx(i) / sin(thirdCoord(kCell))
-
-      enddo
-    endif
+    !if (igeom >= PHI_CYL) then
+    !   do i = 1, numIntCells8
+    !      dtdx(i) = dtdx(i) / radialCoord(jCell)
+    !   enddo
+    !endif
 
     ! compute the internal energy - first time
-    do i = 1,numIntCells8 
+    do i = 1,numIntCells8
        eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
        select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,1,4,5)
+       case(0,1,3,4)
           eint(i) = max(eint(i),hy_smallp/rho(i)) !primitive (mass-specific)
-       case(2,6)
+       case(2,5)
           eint(i) = max(eint(i),hy_smallp/rho(i)) * rho(i) !conserved (per-vol)
        end select
     enddo
-!!    hgrav = 0.
-! Obtain PPM interpolation coefficients.
-    call intrfc(xyzswp,numIntCells,numCells, guard,&
-         &      rho,u,ut,utt,p, &
-         &      rhol,rhor,ul,ur, &
-         &      utl,utr,uttl,uttr, &
-         &      pl,pr,vl,vr,gamcl, &
-         &      gamcr,game, &
-         &      gamel,gamer,gamc,hgrav,eint,eintl,eintr,xn, &
-         &      xnl,xnr,v,primaryDx, primaryCoord,tmp)
-
-    ! Determine input states for the Riemann solver.
-    call states (numIntCells,numCells,&
-                 jCell,igeom, &
-                 rho,u,rhol,rhor,ul,ur,&
-                 utl,utr,uttl,uttr,p, pl,pr, &
-                 gamcl,gamcr,&
-                 ugrid,ce,game,gamer,gamc,gamel,&
-                 eintl,eintr, &
-                 xnl,xnr, &
-                 dtdx, dt, &
-                 primaryCoord, primaryLeftCoord, radialCoord, hgrav, fict)
-    ! Solve Riemann problems at zone edges.
-    call rieman(numIntCells,numCells, &
-                rhoav,uav,utav,uttav,pav,&
-                urell,ugrdl,game,gameav,eintAv,xnav,primaryCoord)
 
+    ! obtain PPM interpolation coefficients.
+    call Timers_start("intrfc")
+    call ppm_intrfc(xyzswp,numCells,numFluxActv,numIntrfcActv,fluxKey, &
+                     intrfcKey,primaryDx,primaryCoord,rho,u,ut,utt,p,eint,hgrav,gamc,game,xn, &
+                     rho_left,rho_right,u_left,u_right, ut_left,ut_right,utt_left,utt_right, &
+                     p_left,p_right,eint_left,eint_right, grav_left,grav_right,v_left,v_right, &
+                     gamc_left,gamc_right,game_left,game_right,pw_left,pw_right,xn_left,xn_right, &
+                     drho_left,drho_right,rho6_left,rho6_right,du_left,du_right,u6_left,u6_right, &
+                     dut_left, dut_right, ut6_left, ut6_right, dutt_left, dutt_right, utt6_left, &
+                     utt6_right, dp_left, dp_right, p6_left, p6_right, deint_left, deint_right, &
+                     eint6_left, eint6_right, dgame_left, dgame_right, game6_left, game6_right, &
+                     dgamc_left, dgamc_right, gamc6_left, gamc6_right, dgrav_left, dgrav_right, &
+                     grav6_left, grav6_right, dpw_left, dpw_right, pw6_left, pw6_right, dxn_left, &
+                     dxn_right, xn6_left, xn6_right)
+    call Timers_stop("intrfc")
+
+    ! integrate profiles
+    call Timers_start("states")
+    call ppm_states(numCells, numIntCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                      rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                      rho_left,rho_right,u_left,u_right, &
+                      ut_left,ut_right,utt_left,utt_right, &
+                      p_left,p_right,eint_left,eint_right, &
+                      pw_left,pw_right,game_left,game_right, &
+                      gamc_left,gamc_right, grav_left,grav_right, &
+                      xn_left,xn_right,drho_left,drho_right,rho6_left,rho6_right,du_left,du_right,u6_left,u6_right, &
+                      dut_left, dut_right, ut6_left, ut6_right, dutt_left, dutt_right, utt6_left, &
+                      utt6_right, dp_left, dp_right, p6_left, p6_right, deint_left, deint_right, &
+                      eint6_left, eint6_right, dpw_left, dpw_right, pw6_left, &
+                      pw6_right, dgame_left, dgame_right, game6_left, game6_right, &
+                      dgamc_left, dgamc_right, gamc6_left, gamc6_right, &
+                      dgrav_left, dgrav_right, grav6_left, grav6_right, &
+                      dxn_left, dxn_right, xn6_left, xn6_right,clft, crght, &
+                      ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                      prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                      vlft, vrght, xnlft, xnrght, jCell, igeom, ugrid, ce, &
+                      dtdx, dt, primaryCoord, radialCoord, fict)
+    !endif
+    call Timers_stop("states")
+
+    ! riemann solver (could alternate here)
+    local_RiemannSolver = hy_RiemannSolver
+
+    ! riemann solver
+    call Timers_start("rieman")
+    select case(local_RiemannSolver)
+
+      case(EXACTRS)
+        call ppm_riemann(numCells, numFluxActv, numIntrfcActv, &
+                           fluxKey, intrfcKey, rhoav, uav, utav, uttav, pav, &
+                           eintav, xnav, gameav, clft, crght, &
+                           ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                           prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                           vlft, vrght, xnlft, xnrght, game)
+
+      case default
+      call Driver_abortFlash&
+      ("[Hydro_init]: The Riemann Solver is of unknown type: " // &
+      "Options are exact and that's it right now.")
+
+    end select
+    call Timers_stop("rieman")
 
+    ! special handling of reflecting boundary conditions
+    xl_noflow = .false.
+    xr_noflow = .false.
     select case (xyzswp)
 
     case (SWEEP_X)
-       if (bcs(LOW,IAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,IAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,IAXIS) == REFLECTING) .or. (hy_xl_boundary_noflow .and. primaryCoord(guard) < gr_imin)  ) then
+          uav  (1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,IAXIS) == REFLECTING) .or. (hy_xr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_imax)  ) then
+          uav  (numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
 
     case (SWEEP_Y)
-       if (bcs(LOW,JAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,JAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,JAXIS) == REFLECTING) .or. (hy_yl_boundary_noflow .and. primaryCoord(guard) < gr_jmin)  ) then
+          uav(1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,JAXIS) == REFLECTING) .or. (hy_yr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_jmax)  ) then
+          uav(numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
 
     case (SWEEP_Z)
-       if (bcs(LOW,KAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,KAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,KAXIS) == REFLECTING) .or. (hy_zl_boundary_noflow .and. primaryCoord(guard) < gr_kmin)  ) then
+          uav(1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,KAXIS) == REFLECTING) .or. (hy_zr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_kmax)  ) then
+          uav(numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
+
     end select
 
-    ! -------------------------------------------------------------------
-    ! Consistent Multi-fluid Advection (Plewa & Mueller 1999, CMA   Eq. 13)
+    if(local_RiemannSolver /= EXACTRS) then
+      if(xl_noflow) then
+        rhoflx (guard+1) = 0.0e0
+        uflx   (guard+1) = 0.0e0
+        utflx  (guard+1) = 0.0e0
+        uttflx (guard+1) = 0.0e0
+        eflx   (guard+1) = 0.0e0
+        eintflx(guard+1) = 0.0e0
+      endif
+
+      if(xr_noflow) then
+        rhoflx (guard+numIntCells+1) = 0.0e0
+        uflx   (guard+numIntCells+1) = 0.0e0
+        utflx  (guard+numIntCells+1) = 0.0e0
+        uttflx (guard+numIntCells+1) = 0.0e0
+        eflx   (guard+numIntCells+1) = 0.0e0
+        eintflx(guard+numIntCells+1) = 0.0e0
+      endif
+    endif
 
+    ! consistent Multi-fluid Advection (Plewa & Mueller 1999, CMA   Eq. 13)
     ! mass fractions renormalization and optional limiting (not if CMA)
-
     if ( NSPECIES > 1  ) then
 
-       scrch1(5:numIntCells5) = 0.e0
+      scrch1 = 0.0
 
-       do n = 1, NSPECIES
+      do n = 1, NSPECIES
 
-          ! renormalize and limit mass fractions: note that limiting introduces
-          ! non-conservation of species
+        ! renormalize and limit mass fractions: note that limiting introduces
+        ! non-conservation of species
+        if ( .not.hy_useCmaAdvection ) then
+          do i = 1, numFluxActv
+            xnav(i,n) = max(hy_smallx, min(1.e0, xnav(i,n)))
+          end do
+        end if
 
-          if ( .not.hy_useCmaAdvection ) then
-             do i = 5, numIntCells5
-                xnav(i,n) = max(hy_smallx, min(1.e0, xnav(i,n)))
-             end do
-          end if
+        do i = 1, numFluxActv
+          scrch1(i) = scrch1(i) + xnav(i,n)
+        enddo
 
-          do i = 5, numIntCells5
-             scrch1(i) = scrch1(i) + xnav(i,n)
-          end do
-       end do
+      enddo
 
-       do i = 5, numIntCells5
-          if ( scrch1(i) /= 0.e0 ) scrch1(i) = 1.e0 / scrch1(i)
-       end do
-
-       do n = 1, NSPECIES
-          do i = 5, numIntCells5
-             xnav(i,n) = xnav(i,n) * scrch1(i)
-          end do
-       end do
+      do i = 1, numFluxActv
+        if ( scrch1(i) /= 0.e0 ) scrch1(i) = 1.e0 / scrch1(i)
+      enddo
 
-    end if
+      do n = 1, NSPECIES
+        do i = 1, numFluxActv
+          xnav(i,n) = xnav(i,n) * scrch1(i)
+        end do
+      enddo
 
-    !--------------------------------------------------------------------------
-    ! Save old grid information and move the grid using the previously computed 
-    ! grid velocities (for artificial dissipation purposes).
+    end if
 
     do i = 1, numIntCells8
 !       xlold(i) = primaryLeftCoord(i) !  Use of xlold is commented out below.
@@ -496,102 +463,64 @@
 !       aold(i)  = area(i)       ! aold is never used.
     enddo
 
-    if (hy_movingGrid) then !! this is not defined yet
-!!$       do i = 2, numIntCells8
-!!$          primaryLeftCoord(i)   = xlold(i) + dt * ugrdl(i)
-!!$          primaryRghtCoord(i-1) = primaryLeftCoord(i)
-!!$       enddo
-!!$       
-!!$       do i = 2, numIntCells8
-!!$          primaryCoord(i)  = 0.5e0 * (primaryRghtCoord(i) + primaryLeftCoord(i))    
-!!$          primaryDx(i) = primaryRghtCoord(i) - primaryLeftCoord(i)
-!!$       enddo
-
-!!  This 2nd call to geom should not be necessary - the geometry better not
-!! have changed since the first call above - unless the grid is moving !
-!! The following geom call and the geom implementation may not be correct 
-!! for a moving grid anyway.
-!!$    call hy_ppm_geom (numIntCells, numCells,jCell, kCell, xyzswp, igeom, &
-!!$         &     areaLeft, arear, area, primaryDx, dvol, &
-!!$               primaryLeftCoord, primaryRghtCoord,  &
-!!$               radialCoord, thirdCoord)
-    endif
-
-    !------------------------------------------------------------------------------
-    ! Compute unmodified fluxes for each of the conserved quantities.
-    !
-    !For different ppmEnerFluxConstructionMeth methods, energy fluxes are
-    !constructed here from the following rieman outputs:
-    !
-    !        |                  Rieman results (assuming that urell==uav)
-    ! Method |    used for eintflx         |    used for eflx
-    !==============================================================================
-    !   0    | rhoav,uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   1,2* | rhoav,uav,eintAv,pav        | rhoav,uav,eintAv,pav       ,utav,uttav
-    !   4    | rhoav,uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   5,6* | rhoav,uav,eintAv,    gameav | rhoav,uav,eintAv,    gameav,utav,uttav
-    !Possible optimization:
-    !   0    |       uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   1,2* | rhoav,uav,eintAv,pav        | rhoav,uav,eintAv,pav       ,utav,uttav
-    !   4    |       uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   5,6* | rhoav,uav,eintAv,    gameav | rhoav,uav,eintAv,    gameav,utav,uttav
-    !==============================================================================
-    ! * For methods 2 and 6, PPM reconstruction, interpolation, and advection for
-    !   eintAv is applied to a conserved internal energy variable (i.e., internal
-    !   energy expressed in per-volume form). Otherwise, the primitive (specific)
-    !   internal energy is used.
-
-
-    do i = 5, numIntCells5
-       rhoflx(i) = rhoav (i) * urell(i)
-       uflx(i)   = rhoflx(i) * uav  (i)
-       utflx(i)  = rhoflx(i) * utav (i)
-       uttflx(i) = rhoflx(i) * uttav(i)
-
-       select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,4)
+    ! check fluxes for CFL violations
+    cfl_max = max( maxval(abs(uav(:)*dtdx(5))), &
+                   maxval(abs(u(5:numIntCells5)*dtdx(5))) ) 
+    !cfl_max = maxval(abs(uav(:)*dtdx(5)))
+    hy_cfl_max(CW_FLX) = max(cfl_max, hy_cfl_max(CW_FLX))
+    if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_FLX) = .true.
+
+    ! compute unmodified fluxes for each of the conserved quantities.
+    if(local_RiemannSolver == EXACTRS) then
+
+      ! loop through active fluxes
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        rhoflx(k) = rhoav(i)  * uav(i)
+        uflx(k)   = rhoflx(k) * uav(i)
+        utflx(k)  = rhoflx(k) * utav(i)
+        uttflx(k) = rhoflx(k) * uttav(i)
+        pflx(k) = pav(i)
+
+        ! compute the internal energy flux
+        select case (hy_ppmEnerFluxConstructionMeth)
+        case(0,3)
           scrch1(i) = pav(i) / ( rhoav(i) * (gameav(i)-1.e0) )
-       case(1,5)
-          scrch1(i) = eintAv(i)
-       case(2,6)
-          scrch1(i) = eintAv(i) / rhoav(i)
-       end select
+        case(1,4)
+          scrch1(i) = eintav(i)
+        case(2,5)
+          scrch1(i) = eintav(i) / rhoav(i)
+        end select
+
+        ! compute the internal energy flux
+        select case (hy_ppmEnerFluxConstructionMeth)
+        case(0,1,2)
+          eintflx(k) = rhoflx(k) * scrch1(i) + uav(i) * pav(i)
+        case(3,4,5)
+          eintflx(k) = rhoflx(k) * scrch1(i) * gameav(i)
+        end select
 
-       ! compute the internal energy flux
-       
-       select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,1,2)
-          eintflx(i) = rhoflx(i) * scrch1(i) + uav(i) * pav(i)
-       case(4,5,6)
-          eintflx(i) = rhoflx(i) * scrch1(i) * gameav(i) 
-       end select
+        ! add the kinetic energy
+        scrchEkin = 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
 
-       ! add the kinetic energy 
-!!$       scrch1(i) = scrch1(i) &
-!!$            &        + 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
-       scrchEkin(i) = 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
-
-       ! compute the total energy flux
-!!$       eflx(i)   = rhoflx(i) * scrch1(i) + uav(i) * pav(i)
-       eflx(i)   = eintflx(i) + rhoflx(i) * scrchEkin(i)
+        ! compute the total energy flux
+        eflx(k) = eintflx(k) + rhoflx(k) * scrchEkin
 
-       ! initialize the artificial viscosity coefficient
-    enddo
-999 format(A7,I3,':',9(1P,G16.9,1x))
-!!$    print 999,'eintflx',blockID,eintflx(5:numIntCells5)
-    avis = 0.0
-    ! recompute the internal energy, over the whole structure
-    do i = 1,numIntCells8 
-       eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
-       eint(i) = max(eint(i),hy_smallp/rho(i))
-    enddo
+      enddo
 
-    !------------------------------------------------------------------------------
-    ! Compute quantities needed for artificial viscosity.  Unfortunately in 
-    ! multidimensions this requires some direction-dependent code.
+      ! recompute the internal energy, over the whole structure
+      do i = 1,numIntCells8
+         eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
+         eint(i) = max(eint(i),hy_smallp/rho(i))
+      enddo
 
+    endif
 
-    if (hy_cvisc > 0.e0)  then 
+    if (hy_cvisc > 0.e0)  then
 
        if (xyzswp == SWEEP_X)  then
           xzn(:) = primaryCoord(:)
@@ -610,134 +539,209 @@
        endif
 
        call avisco( jCell, kCell , avis,                              &
-            hy_dirGeom, xyzswp, 5, numIntCells5, NDIM,    &
-            xtop, xbot, ytop, ybot, ylft, yrgt,           &
-            zlft, zrgt,                                       &
-            primaryCoord, primaryLeftCoord, xzn, yzn, zzn,     &
-            u, uttp, utbt, utrt, utlt, hy_cvisc  )
-       
-       ! there should be no flux through a reflecting boundary, so force the 
-       ! artificial viscosity there to 0
+                    hy_dirGeom, xyzswp, 5, numIntCells5, NDIM,    &
+                    xtop, xbot, ytop, ybot, ylft, yrgt,           &
+                    zlft, zrgt,                                       &
+                    primaryCoord, primaryLeftCoord, xzn, yzn, zzn,     &
+                    u, uttp, utbt, utrt, utlt, hy_cvisc  )
 
-       if (xyzswp == SWEEP_X) then
-          if (bcs(LOW,IAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,IAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
+       ! there should be no flux through a reflecting boundary, so force the
+       ! artificial viscosity there to 0
 
-       if (xyzswp == SWEEP_Y) then
-          if (bcs(LOW,JAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,JAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
-       
-       if (xyzswp == SWEEP_Z) then
-          if (bcs(LOW,KAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,KAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
+       if ( xl_noflow ) avis(guard+1) = 0.e0
+       if ( xr_noflow ) avis(guard+numIntCells+1) = 0.e0
 
        avis(5:numIntCells5) = avis(5:numIntCells5)*alold(5:numIntCells5)
+
+    else
+
+       avis = 0.e0
+
     endif
 
     ! odd-even decoupling fix
     !
     ! now that we've called the accurate Riemann solver, loop over all the zones,
-    ! and for any that is inside a shock, call the HLLE Riemann solver, and 
+    ! and for any that is inside a shock, call the HLLE Riemann solver, and
     ! replace the fluxes computed above with those.  This fixes the odd-even
     ! decoupling problem (see Quirk 1997)
 
-    if (hy_hybridRiemann) then
+    if (hy_hybridRiemann .OR. hy_forceApproxRiemann) then
 
-       do i = 5, numIntCells5
+      ! loop through active flux interfaces
+      do i = 1, numFluxActv
 
-          ! check for the presence of shocks by looking at the artificial viscosity
-          ! and the pressure jump
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        ! check for the presence of shocks by looking at the artificial viscosity
+        ! and the pressure jump
+
+        !!pres_jump = abs(p(i) - p(i-1))/min(p(i),p(i-1))
+
+        !!if (pres_jump >= dp_sh .AND. avis(i) /= 0.e0) then
+        if (((shock_multid(k-1)==1 .OR. shock_multid(k)==1) .AND. (avis(k) /= 0.e0)) .OR. (hy_forceApproxRiemann)) then
+
+          ! the interface between zones i and i-1 is a shock.  Use the HLLE solver
+          ! and replace the fluxes computed above
+
+          !call riemann_hlle(1.e0/vlft(i), 1.e0/vrght(i), &
+          !                  ulft(i),     urght(i),       &
+          !                  utlft(i),    utrght(i),      &
+          !                  uttlft(i),   uttrght(i),     &
+          !                  plft(i),     prght(i),       &
+          !                  e(k-1),      e(k),     &
+          !                  eilft(i),    eirght(i),      &
+          !                  gmelft(i),   gmerght(i),     &
+          !                  gmclft(i),   gmcrght(i),     &
+          !                  0.e0,        0.e0,           &
+          !                  dt,                          &
+          !                  rhoflx(k), uflx(k), utflx(k),&
+          !                  uttflx(k), eflx(k), eintflx(k))
+
+          call riemann_hlle(rho(k-1),    rho(k),    &
+                             u(k-1),      u(k),     &
+                             ut(k-1),     ut(k),    &
+                             utt(k-1),    utt(k),   &
+                             p(k-1),      p(k),     &
+                             e(k-1),      e(k),     &
+                             eint(k-1),   eint(k),  &
+                             game(k-1),   game(k),  &
+                             gamc(k-1),   gamc(k),  &
+                             0.,          0.,       &
+                             dt,                    &
+                             rhoflx(k), uflx(k),    &
+                             utflx(k), uttflx(k),   &
+                             eflx(k), eintflx(k))
 
-!          pres_jump = abs(p(i) - p(i-1))/min(p(i),p(i-1))
+        endif
 
-!          if (pres_jump >= dp_sh .AND. avis(i) /= 0.e0) then
-          if ((shock_multid(i-1)==1 .OR. shock_multid(i)==1) .AND. avis(i) /= 0.e0) then
-
-             ! the interface between zones i and i-1 is a shock.  Use the HLLE solver
-             ! and replace the fluxes computed above
-
-             call riemann_hlle( &
-                  rho(i-1), rho(i), &
-                  u(i-1), u(i), &
-                  ut(i-1), ut(i), &
-                  utt(i-1), utt(i), &
-                  p(i-1), p(i), &
-                  e(i-1), e(i), &
-                  eint(i-1), eint(i), &
-                  game(i-1), game(i), &
-                  gamc(i-1), gamc(i), &
-                  hgrav(i-1), hgrav(i), &
-                  dt, &
-                  rhoflx(i), uflx(i), utflx(i), uttflx(i), eflx(i), eintflx(i))
-             
-          endif
-          
-       enddo
+      enddo
 
-    endif
+      ! For no-flow boundaries, ensure that the fluxes are zero if this is triggered near the boundary
+      if(xl_noflow) then
+        rhoflx (guard+1) = 0.e0
+        uflx   (guard+1) = 0.e0
+        utflx  (guard+1) = 0.e0
+        uttflx (guard+1) = 0.e0
+        eflx   (guard+1) = 0.e0
+        eintflx(guard+1) = 0.e0
+      endif
+
+      if(xr_noflow) then
+        rhoflx (guard+numIntCells+1) = 0.e0
+        uflx   (guard+numIntCells+1) = 0.e0
+        utflx  (guard+numIntCells+1) = 0.e0
+        uttflx (guard+numIntCells+1) = 0.e0
+        eflx   (guard+numIntCells+1) = 0.e0
+        eintflx(guard+numIntCells+1) = 0.e0
+      endif
 
-    ! Do the elemental abundance fluxes.
+    endif ! this is the end of hybrid riemann section
 
+    ! do the elemental abundance fluxes.
     do n = 1, hy_numXn
-       do i = 5, numIntCells5
-          xnflx(i,n) = xnav(i,n) * rhoflx(i)
-       enddo
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        xnflx(k,n) = xnav(i,n) * rhoflx(k)
+
+      enddo
     enddo
 
     !---------------------------------------------------------------
     ! Apply the diffusive fluxes to the unmodified conserved fluxes.
 
-    do i = 5, numIntCells5
-       rhoflx(i) = rhoflx(i) * alold(i)
-       uflx  (i) = uflx  (i) * alold(i)
-       utflx (i) = utflx (i) * alold(i)
-       uttflx(i) = uttflx(i) * alold(i)
-       eflx  (i) = eflx  (i) * alold(i)
-
-       eintflx(i) = eintflx(i)*alold(i)
-
-       rhoflx(i)  = rhoflx(i)  + avis(i) * (rho(i-1)           - rho(i))  
-       uflx  (i)  = uflx  (i)  + avis(i) * (rho(i-1)*u(i-1)    - rho(i)*u(i))
-       utflx (i)  = utflx (i)  + avis(i) * (rho(i-1)*ut(i-1)   - rho(i)*ut(i))
-       uttflx(i)  = uttflx(i)  + avis(i) * (rho(i-1)*utt(i-1)  - rho(i)*utt(i))
-       eflx  (i)  = eflx  (i)  + avis(i) * (rho(i-1)*e(i-1)    - rho(i)*e(i))
-       eintflx(i) = eintflx(i) + avis(i) * (rho(i-1)*eint(i-1) - rho(i)*eint(i))
+    do i = 1, numFluxActv
+
+      ! compute interface indices
+      j = fluxKey(i)
+      k = intrfcKey(j)
+
+      rhoflx(k)  = rhoflx(k)  * alold(k)
+      uflx  (k)  = uflx  (k)  * alold(k)
+      utflx (k)  = utflx (k)  * alold(k)
+      uttflx(k)  = uttflx(k)  * alold(k)
+      eflx  (k)  = eflx  (k)  * alold(k)
+      eintflx(k) = eintflx(k) * alold(k)
+
+      rhoflx(k)  = rhoflx(k)  + avis(k) * (rho(k-1)           - rho(k))
+      uflx  (k)  = uflx  (k)  + avis(k) * (rho(k-1)*u(k-1)    - rho(k)*u(k))
+      utflx (k)  = utflx (k)  + avis(k) * (rho(k-1)*ut(k-1)   - rho(k)*ut(k))
+      uttflx(k)  = uttflx(k)  + avis(k) * (rho(k-1)*utt(k-1)  - rho(k)*utt(k))
+      eflx  (k)  = eflx  (k)  + avis(k) * (rho(k-1)*e(k-1)    - rho(k)*e(k))
+      eintflx(k) = eintflx(k) + avis(k) * (rho(k-1)*eint(k-1) - rho(k)*eint(k))
+
     enddo
 
     do n = 1, hy_numXn
-       do i = 5, numIntCells5
-          xnflx(i,n) = xnflx(i,n) * alold(i)
-          xnflx(i,n) = xnflx(i,n) + &
-                       avis(i) * (rho(i-1)*xn(i-1,n) - rho(i)*xn(i,n))
-       enddo
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        xnflx(k,n) = xnflx(k,n) * alold(k)
+        xnflx(k,n) = xnflx(k,n) + &
+                      avis(k) * (rho(k-1)*xn(k-1,n) - rho(k)*xn(k,n))
+
+      enddo
     enddo
 
-    else
-       fict = 0.0
-    end if
+    ! fill in missing fluxes (decompress the flux calculations)
+    !call Timers_start("ppm_decode")
+    call ppm_decode(numCells, numIntrfcActv, numFluxActv, hy_numXn, hy_fluxmask, &
+                      rhoflx, uflx, utflx, uttflx, &
+                      pflx, eintflx, eflx, xnflx)
+    !call Timers_stop("ppm_decode")
+
+  else
+    fict = 0
+  endif
+
     !------------------------------------------------------------------------------
     ! Store dt/dx, geometry factors, and the modified fluxes in 'global' arrays
     ! for use in updating the solution after all of the 1D sweeps in this direction
     ! are done. Note that dt/dx is not constant in non-Cartesian geometries, so it
     ! is saved for each zone in the tempDtDx() array.
+#ifdef DEBUG_HYDRO
+
+    do i = 5, numIntCells4
+       if (dvol(i) == 0.) print *,'[ppm_hydro] ERROR: dvol == 0, i= ',i,', numIntCells4=',numIntCells4
+    enddo
+#endif
 
     do i = 5, numIntCells4
-       if (dvol(i) == 0.) then
-          print *,' ERROR: dvol == 0 '
-       end if
        dtdx(i) = dt/dvol(i)
+#ifdef DEBUG_HYDRO
+       if ( dtdx(i) /= 0.e0 ) then
+          print *,               '[ppm_hydro] ERROR: dvol=0 '
+          call Driver_abortFlash("[ppm_hydro] ERROR: dvol=0")
+       end if
+#endif
     enddo
+#ifdef ZERO_HYDRO_FLUXES
+
+    ! the same can be achieved by setting updateHydroFluxes false
 
-!===================================================================
-    
-    return
-  end subroutine hydro_1d
+    rhoflx   = 0.e0
+    uflx     = 0.e0
+    utflx    = 0.e0
+    uttflx   = 0.e0
+    eflx     = 0.e0
+    eintflx  = 0.e0
+    xnflx    = 0.e0
+    pav      = 0.e0
+    dtdx     = 0.e0
+    area     = 0.e0
+    grav     = 0.e0
+    ngrav    = 0.e0
+    fict     = 0.e0
+    areaLeft = 1.e0
+#endif
+                         
+end subroutine ppm_hydro
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90	2021-02-23 17:50:19.882763940 -0500
@@ -1,4 +1,4 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/interp_char
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char
 !!
 !! NAME
 !! 
@@ -41,6 +41,12 @@
 !!
 !!  Modifies array hy_dela, which is referenced in subroutine detect.
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
 !!***
 
 #define HY_FASTLEFT 1
@@ -57,14 +63,14 @@
 #define HY_GAMC 6
 #define HY_GAME 7
 
-subroutine interp_char(sweepDir,numIntCells, numCells, &
+subroutine ppm_interp_char(sweepDir,numIntCells, numCells, &
+                       numIntrfcActv, key, & 
                        rhol, rho, rhor, &
                        ul,   u,   ur,   &
                        utl,  ut,  utr,  &
                        uttl, utt, uttr, &
                        pl,   p,   pr,   &
-                       gamc, game,       &
-                       coeff1, coeff2, coeff3, coeff4, coeff5)
+                       gamc, game)
 
 
   use Hydro_data, ONLY:  hy_dela
@@ -74,193 +80,196 @@
 #include "constants.h"
 #include "Flash.h"
 
-  integer, intent(IN) :: sweepDir,numIntCells, numCells
-  real, intent(IN), DIMENSION(numCells)  ::  coeff1, coeff2, coeff3, coeff4, coeff5
-  real, intent(IN), DIMENSION(numCells)  ::  rho,u,ut,utt,p,gamc,game
-  real, intent(OUT), DIMENSION(numCells) ::  rhol,rhor,ul,ur,utl,utr,uttl,uttr,pl,pr
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4
-  integer :: i, numIntCells5, numIntCells6, numIntCells8
-
+  ! args
+  integer, intent(in) :: sweepDir, numIntCells, numCells, numIntrfcActv
+  integer, intent(in), dimension(numIntrfcActv) :: key
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, gamc, game
+  real, intent(out), dimension(numIntrfcActv) ::  rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr
 
+  ! local
+  integer :: i, j, k
   integer :: numVars,nWave
+  real :: del1, del2, u1, u2, u3, u4
   real, dimension(5,5) :: reigL,reig0,reigR,leigL,leig0,leigR
   real, dimension(5)   :: lambdaL,lambda0,lambdaR,delbarL,delbar0,delbarR
   real, dimension(7)   :: wLL,wL,w0,wR,wRR
 
-
-  numIntCells5 = numIntCells + 5
-  numIntCells6 = numIntCells + 6
-  numIntCells8 = numIntCells + 8
-
   numVars = 7 ! rho,u,ut,utt,p,gamc,game
 
-  rhol=0.
-  rhor=0.
-  ul=0.
-  ur=0.
-  utl=0.
-  utr=0.
-  uttl=0.
-  uttr=0.
-  pl=0.
-  pr=0.
-
-  do i = 2, numIntCells8
-     scrch1(i) = rho(i) - rho(i-1)
-     scrch2(i) = abs ( scrch1(i) + scrch1(i) )
-     scrch4(i) = sign (1.e00, scrch1(i))
-  end do
-
+  ! set solution vars to zero
+  rhol = 0.
+  rhor = 0.
+  ul   = 0.
+  ur   = 0.
+  utl  = 0.
+  utr  = 0.
+  uttl = 0.
+  uttr = 0.
+  pl   = 0.
+  pr   = 0.
+
+  ! loop through active interfaces
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed interface index
+    i = key(j)
+
+    ! compute differences
+    u1 = rho(i-1) - rho(i-2)
+    u2 = rho(i) - rho(i-1)
+    u3 = rho(i+1) - rho(i)
+    u4 = rho(i-1) + rho(i)
+
+    ! compute average slopes
+    del1 = 0.5e0*(u2 + u1)
+    del2 = 0.5e0*(u3 + u2)
+
+    if (del1.lt.0.0e0) then
+      del1 = -min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    else
+      del1 = min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    endif
+
+    if (-sign(1.0,u1)*sign(1.0,u2).ge.0.0e0) del1 = 0.0e0
+
+    if (del2.lt.0.0e0) then
+      del2 = -min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    else
+      del2 = min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    endif
 
-  ! apply Eq. 1.8 of Colella & Woodward -- guarantee that a(i+1/2) lies
-  ! between a(i) and a(i+1)
-    
-  do i = 2, numIntCells6+1
-     hy_dela(i)   = coeff1(i) * scrch1(i+1) + coeff2(i) * scrch1(i)
-       
-     if (hy_dela(i) .LT. 0.e0) then
-        scrch3(i) = -1.e0
-     else
-        scrch3(i) = 1.e0
-     endif
-
-     ! This hy_dela for density is used in detect.F90 for contact steepening
-     ! and is initialized here.
-     ! Note: This hy_dela should be initialized before calling detect.F90
-     !       for contact steepening
-     hy_dela(i)   = min(abs(hy_dela(i)), scrch2(i), scrch2(i+1))* scrch3(i)
+    if (-sign(1.0,u2)*sign(1.0,u3).ge.0.0e0) del2 = 0.0e0
 
-     if (-scrch4(i)*scrch4(i+1) >= 0.e0) hy_dela(i) = 0.e0
-       
   end do
 
-
   ! compute some common factors
   !!* We solve eqns (7) and (8) in Colella & Sekora, instead of solving eqn 1.6 from
   !!  Colella & Woodward (or eqn 12 from Colella & Sekora)
   !!* We apply limitings to characteristic variables, NOT to primitive variables
 
-  do i = 3, numIntCells8-2
+  !do i = 3, numIntCells8-2 (3:22)
 
-     select case(sweepDir)
-     case(1)
-        wLL=(/rho(i-2),u(i-2),ut(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
-        wL =(/rho(i-1),u(i-1),ut(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
-        w0 =(/rho( i ),u( i ),ut( i ),utt( i ),p( i ),gamc( i ),game( i )/)
-        wR =(/rho(i+1),u(i+1),ut(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
-        wRR=(/rho(i+2),u(i+2),ut(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
-
-     case(2)
-        wLL=(/rho(i-2),ut(i-2),u(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
-        wL =(/rho(i-1),ut(i-1),u(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
-        w0 =(/rho( i ),ut( i ),u( i ),utt( i ),p( i ),gamc( i ),game( i )/)
-        wR =(/rho(i+1),ut(i+1),u(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
-        wRR=(/rho(i+2),ut(i+2),u(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
-
-     case(3)
-        wLL=(/rho(i-2),ut(i-2),utt(i-2),u(i-2),p(i-2),gamc(i-2),game(i-2)/)
-        wL =(/rho(i-1),ut(i-1),utt(i-1),u(i-1),p(i-1),gamc(i-1),game(i-1)/)
-        w0 =(/rho( i ),ut( i ),utt( i ),u( i ),p( i ),gamc( i ),game( i )/)
-        wR =(/rho(i+1),ut(i+1),utt(i+1),u(i+1),p(i+1),gamc(i+1),game(i+1)/)
-        wRR=(/rho(i+2),ut(i+2),utt(i+2),u(i+2),p(i+2),gamc(i+2),game(i+2)/)
-     end select
-
-     call eigensystem(sweepDir,wL,reigL,leigL,lambdaL)
-     call eigensystem(sweepDir,w0,reig0,leig0,lambda0)
-     call eigensystem(sweepDir,wR,reigR,leigR,lambdaR)
-
-
-     ! One can use a different slope limiter - default is MC limiter
-     do nWave = HY_FASTLEFT,HY_FASTRGHT
-        delbarL(nWave) = &
-             mc(dot_product(leigL(nWave,HY_DENS:HY_PRES),wL(HY_DENS:HY_PRES)-wLL(HY_DENS:HY_PRES)),&
-                dot_product(leigL(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL (HY_DENS:HY_PRES)))
-
-
-        delbar0(nWave) = &
-             mc(dot_product(leig0(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL(HY_DENS:HY_PRES)),&
-                dot_product(leig0(nWave,HY_DENS:HY_PRES),wR(HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)))
-
-
-        delbarR(nWave) = &
-             mc(dot_product(leigR(nWave,HY_DENS:HY_PRES),wR (HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)),&
-                dot_product(leigR(nWave,HY_DENS:HY_PRES),wRR(HY_DENS:HY_PRES)-wR(HY_DENS:HY_PRES)))
-     enddo
-
-
-     delbarL(HY_DENS:HY_PRES) = reigL(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarL(HY_FASTLEFT)+&
-                                reigL(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarL(HY_SLOWLEFT)+&
-                                reigL(HY_DENS:HY_PRES,HY_ENTROPY) *delbarL(HY_ENTROPY) +&
-                                reigL(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarL(HY_SLOWRGHT)+&
-                                reigL(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarL(HY_FASTRGHT)
-
-
-     delbar0(HY_DENS:HY_PRES) = reig0(HY_DENS:HY_PRES,HY_FASTLEFT)*delbar0(HY_FASTLEFT)+&
-                                reig0(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbar0(HY_SLOWLEFT)+&
-                                reig0(HY_DENS:HY_PRES,HY_ENTROPY) *delbar0(HY_ENTROPY) +&
-                                reig0(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbar0(HY_SLOWRGHT)+&
-                                reig0(HY_DENS:HY_PRES,HY_FASTRGHT)*delbar0(HY_FASTRGHT)
-
-     delbarR(HY_DENS:HY_PRES) = reigR(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarR(HY_FASTLEFT)+&
-                                reigR(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarR(HY_SLOWLEFT)+&
-                                reigR(HY_DENS:HY_PRES,HY_ENTROPY) *delbarR(HY_ENTROPY) +&
-                                reigR(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarR(HY_SLOWRGHT)+&
-                                reigR(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarR(HY_FASTRGHT)
-
-
-
-     ! Parabolic interpolation at the left and right cell interfaces
-     ! Colella-Woodward Eqn 1.9, Sekora-Colella Eqn 7, Stone et al Eqn 46
-     wLL(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wL(HY_DENS:HY_PRES)) &
-          - (delbar0(HY_DENS:HY_PRES)-delbarL(HY_DENS:HY_PRES))/6.
-
-     wRR(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wR(HY_DENS:HY_PRES)) &
-          - (delbarR(HY_DENS:HY_PRES)-delbar0(HY_DENS:HY_PRES))/6.
-
-
-     ! Ensure that the interpolated values lie between the cell-centered values
-     do nWave=HY_DENS,HY_PRES
-        wLL(nWave) = max(min(w0(nWave),wL(nWave)),wLL(nWave))
-        wLL(nWave) = min(max(w0(nWave),wL(nWave)),wLL(nWave))
-        wRR(nWave) = max(min(w0(nWave),wR(nWave)),wRR(nWave))
-        wRR(nWave) = min(max(w0(nWave),wR(nWave)),wRR(nWave))
-     enddo
-
-
-     ! Prepare outputs
-     rhol(i) = wLL(HY_DENS)
-     pl(i)   = wLL(HY_PRES)
-
-     rhor(i) = wRR(HY_DENS)
-     pr(i)   = wRR(HY_PRES)
-
-     select case(sweepDir)
-     case(1)
-        ul(i)   = wLL(HY_VELX)
-        utl(i)  = wLL(HY_VELY)
-        uttl(i) = wLL(HY_VELZ)
-
-        ur(i)   = wRR(HY_VELX)
-        utr(i)  = wRR(HY_VELY)
-        uttr(i) = wRR(HY_VELZ)
-
-     case(2)
-        ul(i)   = wLL(HY_VELY)
-        utl(i)  = wLL(HY_VELX)
-        uttl(i) = wLL(HY_VELZ)
-
-        ur(i)   = wRR(HY_VELY)
-        utr(i)  = wRR(HY_VELX)
-        uttr(i) = wRR(HY_VELZ)
-     case(3)
-        ul(i)   = wLL(HY_VELZ)
-        utl(i)  = wLL(HY_VELX)
-        uttl(i) = wLL(HY_VELY)
-
-        ur(i)   = wRR(HY_VELZ)
-        utr(i)  = wRR(HY_VELX)
-        uttr(i) = wRR(HY_VELY)
-     end select
+  do j = 1, numIntrfcActv ! (4:22)
+
+    ! compute uncompressed interface index
+    k = key(j)
+    i = k-1
+
+    select case(sweepDir)
+    case(1)
+       wLL=(/rho(i-2),u(i-2),ut(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),u(i-1),ut(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),u( i ),ut( i ),utt( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),u(i+1),ut(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),u(i+2),ut(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
+
+    case(2)
+       wLL=(/rho(i-2),ut(i-2),u(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),ut(i-1),u(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),ut( i ),u( i ),utt( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),ut(i+1),u(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),ut(i+2),u(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
+
+    case(3)
+       wLL=(/rho(i-2),ut(i-2),utt(i-2),u(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),ut(i-1),utt(i-1),u(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),ut( i ),utt( i ),u( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),ut(i+1),utt(i+1),u(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),ut(i+2),utt(i+2),u(i+2),p(i+2),gamc(i+2),game(i+2)/)
+    end select
+
+    call eigensystem(sweepDir,wL,reigL,leigL,lambdaL)
+    call eigensystem(sweepDir,w0,reig0,leig0,lambda0)
+    call eigensystem(sweepDir,wR,reigR,leigR,lambdaR)
+
+    ! One can use a different slope limiter - default is MC limiter
+    do nWave = HY_FASTLEFT,HY_FASTRGHT
+       delbarL(nWave) = &
+            mc(dot_product(leigL(nWave,HY_DENS:HY_PRES),wL(HY_DENS:HY_PRES)-wLL(HY_DENS:HY_PRES)),&
+               dot_product(leigL(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL (HY_DENS:HY_PRES)))
+
+
+       delbar0(nWave) = &
+            mc(dot_product(leig0(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL(HY_DENS:HY_PRES)),&
+               dot_product(leig0(nWave,HY_DENS:HY_PRES),wR(HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)))
+
+
+       delbarR(nWave) = &
+            mc(dot_product(leigR(nWave,HY_DENS:HY_PRES),wR (HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)),&
+               dot_product(leigR(nWave,HY_DENS:HY_PRES),wRR(HY_DENS:HY_PRES)-wR(HY_DENS:HY_PRES)))
+    enddo
+
+
+    delbarL(HY_DENS:HY_PRES) = reigL(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarL(HY_FASTLEFT)+&
+                               reigL(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarL(HY_SLOWLEFT)+&
+                               reigL(HY_DENS:HY_PRES,HY_ENTROPY) *delbarL(HY_ENTROPY) +&
+                               reigL(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarL(HY_SLOWRGHT)+&
+                               reigL(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarL(HY_FASTRGHT)
+
+
+    delbar0(HY_DENS:HY_PRES) = reig0(HY_DENS:HY_PRES,HY_FASTLEFT)*delbar0(HY_FASTLEFT)+&
+                               reig0(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbar0(HY_SLOWLEFT)+&
+                               reig0(HY_DENS:HY_PRES,HY_ENTROPY) *delbar0(HY_ENTROPY) +&
+                               reig0(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbar0(HY_SLOWRGHT)+&
+                               reig0(HY_DENS:HY_PRES,HY_FASTRGHT)*delbar0(HY_FASTRGHT)
+
+    delbarR(HY_DENS:HY_PRES) = reigR(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarR(HY_FASTLEFT)+&
+                               reigR(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarR(HY_SLOWLEFT)+&
+                               reigR(HY_DENS:HY_PRES,HY_ENTROPY) *delbarR(HY_ENTROPY) +&
+                               reigR(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarR(HY_SLOWRGHT)+&
+                               reigR(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarR(HY_FASTRGHT)
+
+    ! Parabolic interpolation at the left and right cell interfaces
+    ! Colella-Woodward Eqn 1.9, Sekora-Colella Eqn 7, Stone et al Eqn 46
+    wLL(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wL(HY_DENS:HY_PRES)) &
+         - (delbar0(HY_DENS:HY_PRES)-delbarL(HY_DENS:HY_PRES))/6.
+
+    wRR(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wR(HY_DENS:HY_PRES)) &
+         - (delbarR(HY_DENS:HY_PRES)-delbar0(HY_DENS:HY_PRES))/6.
+
+
+    ! Ensure that the interpolated values lie between the cell-centered values
+    do nWave=HY_DENS,HY_PRES
+       wLL(nWave) = max(min(w0(nWave),wL(nWave)),wLL(nWave))
+       wLL(nWave) = min(max(w0(nWave),wL(nWave)),wLL(nWave))
+       wRR(nWave) = max(min(w0(nWave),wR(nWave)),wRR(nWave))
+       wRR(nWave) = min(max(w0(nWave),wR(nWave)),wRR(nWave))
+    enddo
+
+    ! Prepare outputs
+    if (j.gt.1) rhor(j-1) = wLL(HY_DENS)
+    if (j.gt.1) pr(j-1)   = wLL(HY_PRES)
+
+    rhol(j) = wRR(HY_DENS)
+    pl(j)   = wRR(HY_PRES)
+
+    select case(sweepDir)
+    case(1)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELX)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELY)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELZ)
+
+       ul(j)   = wRR(HY_VELX)
+       utl(j)  = wRR(HY_VELY)
+       uttl(j) = wRR(HY_VELZ)
+
+    case(2)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELY)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELX)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELZ)
+
+       ul(j)   = wRR(HY_VELY)
+       utl(j)  = wRR(HY_VELX)
+       uttl(j) = wRR(HY_VELZ)
+    case(3)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELZ)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELX)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELY)
+
+       ul(j)   = wRR(HY_VELZ)
+       utl(j)  = wRR(HY_VELX)
+       uttl(j) = wRR(HY_VELY)
+    end select
 
   enddo
 
@@ -410,10 +419,4 @@
 
 
 
-  end subroutine interp_char
-
-
-
-
-
-
+  end subroutine ppm_interp_char
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90	2021-02-23 17:50:59.441914725 -0500
@@ -0,0 +1,110 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/interp
+!!
+!! NAME
+!! 
+!!  interp
+!!
+!! SYNOPSIS
+!!
+!!  call interp(integer(in) :: numIntCells,
+!!              integer(in) :: numCells,
+!!              real(out)   :: al(numCells), 
+!!              real(in)    :: a(numCells), 
+!!              real(in)    :: dx(numCells), 
+!!              real(out)   :: ar(numCells), 
+!!              real(in)    :: coeff1(numCells), 
+!!              real(in)    :: coeff2(numCells), 
+!!              real(in)    :: coeff3(numCells), 
+!!              real(in)    :: coeff4(numCells), 
+!!              real(in)    :: coeff5(numCells))
+!!
+!! DESCRIPTION
+!!
+!!  Interpolate interface values and monotonize
+!!
+!! ARGUMENTS
+!!
+!! numIntCells :
+!! numCells :
+!! al :
+!! a :
+!! dx :
+!! ar :
+!! coeff1 :
+!! coeff2 :
+!! coeff3 :
+!! coeff4 :
+!! coeff5 :
+!!
+!!
+!! SIDE EFFECTS
+!!
+!!  Modifies array hy_dela, which is referenced in subroutine detect.
+!!
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!!***
+
+subroutine ppm_interp(numCells, numIntrfcActv, al, a, ar, key)
+
+  !-----------------------------------------------------------------------------
+
+  implicit none
+
+  ! arguments
+  integer, intent(in) :: numCells, numIntrfcActv
+  integer, intent(in), dimension(numIntrfcActv) :: key
+  real, intent(in), dimension(numCells) ::  a
+  real, intent(out), dimension(numIntrfcActv) ::  al, ar
+
+  ! local
+  real :: del1, del2, u1, u2, u3, u4
+  integer :: i, j
+
+  !-----------------------------------------------------------------------------
+
+  ! loop through active interfaces
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed interface index
+    i = key(j)
+
+    ! compute differences
+    u1 = a(i-1) - a(i-2)
+    u2 = a(i) - a(i-1)
+    u3 = a(i+1) - a(i)
+    u4 = a(i-1) + a(i)
+
+    ! compute average slopes
+    del1 = 0.5e0*(u2 + u1)
+    del2 = 0.5e0*(u3 + u2)
+
+    ! enforce eq. 1.8 for da_{j}
+    if (del1.lt.0.0e0) then
+      del1 = -min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    else
+      del1 = min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    endif
+
+    if (-sign(1.0,u1)*sign(1.0,u2).ge.0.0e0) del1 = 0.0e0
+
+    if (del2.lt.0.0e0) then
+      del2 = -min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    else
+      del2 = min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    endif
+
+    if (-sign(1.0,u2)*sign(1.0,u3).ge.0.0e0) del2 = 0.0e0
+
+    ! compute final right and left states (of the target interface)
+    al(j) = 0.5e0*u4 + (del1 - del2) * 0.166666666666666666e0
+    ar(j) = al(j)
+
+  enddo
+
+end subroutine ppm_interp
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90	2021-02-23 17:22:00.831264970 -0500
@@ -1,61 +1,20 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/intrfc
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc
 !!
 !! NAME
-!! 
-!!  subroutine intrfc
-!!
 !!
 !! SYNOPSIS
 !!
-!!  call intrfc(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells,
-!!              integer(IN) :: guard,
-!!              real(IN)    :: rho(numCells),
-!!              real(IN)    :: u(numCells),
-!!              real(IN)    :: ut(numCells),
-!!              real(IN)    :: utt(numCells),
-!!              real(IN)    :: p(numCells),
-!!              real(INOUT) :: rhol(numCells),
-!!              real(INOUT) :: rhor(numCells),
-!!              real(INOUT) :: ul(numCells),
-!!              real(INOUT) :: ur(numCells),
-!!              real(INOUT) :: utl(numCells),
-!!              real(INOUT) :: utr(numCells),
-!!              real(INOUT) :: uttl(numCells),
-!!              real(INOUT) :: uttr(numCells),
-!!              real(INOUT) :: pl(numCells),
-!!              real(INOUT) :: pr(numCells),
-!!              real(OUT)   :: vl(numCells),
-!!              real(OUT)   :: vr(numCells),
-!!              real(INOUT) :: gamcl(numCells),
-!!              real(INOUT) :: gamcr(numCells),
-!!              real(IN)    :: game(numCells),
-!!              real(INOUT) :: gamel(numCells),
-!!              real(INOUT) :: gamer(numCells),
-!!              real(IN)    :: gamc(numCells),
-!!              real(IN)    :: grav(numCells),
-!!              real(IN)    :: eint(numCells),
-!!              real(INOUT) :: eintl(numCells),
-!!              real(INOUT) :: eintr(numCells),
-!!              real(IN)    :: xn(numCells, hy_numXn),
-!!              real(INOUT) :: xnl(numCells, hy_numXn),
-!!              real(INOUT) :: xnr(numCells, hy_numXn),
-!!              real(OUT)   :: v(numCells),
-!!              real(IN)    :: dx(numCells),
-!!              real(IN)    :: x(numCells))
-!!
-!! 
 !! DESCRIPTION
-!!  
+!!
 !!  Calculate zone interface values of all variables.  Start by using a
 !!  high order polynomial to interpolate the zone average values to the
-!!  interface (Fry. Eq. 24).  The coefficients of this polynomial are 
-!!  constructed (by coeff() ) such that the polynomial reproduces the 
+!!  interface (Fry. Eq. 24).  The coefficients of this polynomial are
+!!  constructed (by coeff() ) such that the polynomial reproduces the
 !!  correct average values in each zone.
 !!
-!!  Once the coefficients are computed, the first guess at the interface 
-!!  values are made, and monotonicity must be enforced.  We need to ensure 
-!!  that the interface value does not fall outside the range of the 
+!!  Once the coefficients are computed, the first guess at the interface
+!!  values are made, and ppm_profileonicity must be enforced.  We need to ensure
+!!  that the interface value does not fall outside the range of the
 !!  adjacent zone average values --  this procedure is handled by interp()
 !!
 !!  intrfc() then looks for contact discontinuities (through detect() ) and
@@ -63,320 +22,254 @@
 !!  mass fractions.
 !!
 !!  Next, shocks are flattened if they are too thin, via flaten().  Shocks
-!!  that are too thin are not treated accurately, and oscillations can result. 
+!!  that are too thin are not treated accurately, and oscillations can result.
 !!  Flattening is applied to any shocks which are only one zone wide.
 !!  No flattening should be used for gravitational accelerations.
 !!
 !!  Finally, we need to ensure that the parabolic reconstruction of the
-!!  zone data is monotonic -- each point in the parabolic is required to
-!!  fall between the two zone interface values -- this procedure is 
-!!  handled by monot().
+!!  zone data is ppm_profileonic -- each point in the parabolic is required to
+!!  fall between the two zone interface values -- this procedure is
+!!  handled by ppm_profile().
 !!
 !! ARGUMENTS
 !!
-!!  numIntCells :
-!!  numCells :
-!!  guard :
-!!  rho(numCells) :
-!!  u(numCells) :
-!!  ut(numCells) :
-!!  utt(numCells) :
-!!  p(numCells) :
-!!  rhol(numCells) :
-!!  rhor(numCells) :
-!!  ul(numCells) :
-!!  ur(numCells) :
-!!  utl(numCells) :
-!!  utr(numCells) :
-!!  uttl(numCells) :
-!!  uttr(numCells) :
-!!  pl(numCells) :
-!!  pr(numCells) :
-!!  vl(numCells) :
-!!  vr(numCells) :
-!!  gamcl(numCells) :
-!!  gamcr(numCells) :
-!!  game(numCells) :
-!!  gamel(numCells) :
-!!  gamer(numCells) :
-!!  gamc(numCells) :
-!!  grav(numCells) :
-!!  eint(numCells) :
-!!  eintl(numCells) :
-!!  eintr(numCells) :
-!!  xn :
-!!  xnl :
-!!  xnr :
-!!  v :
-!!  dx(numCells) :
-!!  x(numCells) :
+!! NOTES
+!!
+!! DISCLAIMER
 !!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
 !!***
 
-  subroutine intrfc(sweepDir,numIntCells, numCells, guard, &
-       &            rho, u, ut, utt, p, &
-       &            rhol, rhor, ul, ur, &
-       &            utl, utr, uttl, uttr, &
-       &            pl, pr, vl, vr, gamcl, &
-       &            gamcr, game, &
-       &            gamel,gamer,gamc,grav, eint, eintl, eintr, xn, &
-       &            xnl, xnr, v, dx, x,tmp)
-
-  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, hy_gravl, &
-                           hy_drho, hy_rho6, &
-                           hy_du, hy_u6, hy_dut, hy_ut6, &
-                           hy_dutt, hy_utt6, hy_dp, hy_dgame, hy_game6, &
-                           hy_gravr, hy_p6, hy_dgamc, hy_gamc6, hy_dgrav, &
-                           hy_grav6, hy_dxn, hy_xn6, &
-                           hy_deint, hy_eint6, &
-                           hy_pwcubic, hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, &
-                           hy_ppmModifystates, &
-                           hy_useSteepening, hy_useCmaFlattening,&
-                           hy_epsiln, hy_omg1, hy_omg2, hy_charLimiting
-
+  subroutine ppm_intrfc(sweepDir, numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, dx, x, &
+                          rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                          rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr, &
+                          eintl, eintr, gravl, gravr, vl, vr, gamcl, gamcr, &
+                          gamel, gamer, pwl, pwr, xnl, xnr, drhol, drhor, rho6l, &
+                          rho6r, dul, dur, u6l, u6r, dutl, dutr, ut6l, ut6r, duttl, &
+                          duttr, utt6l, utt6r, dpl, dpr, p6l, p6r, deintl, &
+                          deintr, eint6l, eint6r, dgamel, dgamer, game6l, &
+                          game6r, dgamcl, dgamcr, gamc6l, gamc6r, dgravl, &
+                          dgravr, grav6l, grav6r, dpwl, dpwr, pw6l, pw6r, &
+                          dxnl, dxnr, xn6l, xn6r)
+
+  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, &
+                           hy_ppmModifystates, hy_useSteepening, &
+                           hy_useCmaFlattening, hy_enrFlattening, hy_epsiln, &
+                           hy_omg1, hy_omg2, hy_charLimiting, hy_flatn, &
+                           hy_igodu, hy_useFlattening
+
+!  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, &
+!                           hy_pwcubic, hy_pwl, hy_pwr, hy_ppmModifystates, &
+!                           hy_useSteepening, hy_useCmaFlattening, hy_enrFlattening, &
+!                           hy_epsiln, hy_omg1, hy_omg2, hy_charLimiting
 
+  !use Timers_interface, ONLY : Timers_start, Timers_stop
 
   implicit none
-!!------ARGUMENTS-------------------
-#include "Flash.h"
 
+#include "Flash.h"
 
-  integer, intent(IN) :: sweepDir,numIntCells, numCells, guard
-  real, intent(IN),    DIMENSION(numCells,hy_numXn) :: xn
-  real, intent(INOUT), DIMENSION(numCells,hy_numXn) :: xnl, xnr
-  real, intent(IN), DIMENSION(numCells) :: &
-       rho, u, ut, utt, p, gamc, game, grav, eint, dx, x,tmp
-  real, intent(INOUT), DIMENSION(numCells) :: &
-       rhol, rhor, &
-       ul, ur, &
-       utl, utr, &
-       uttl, uttr, &
-       pl, pr,&
-       gamcl, gamcr, &
-       gamel, gamer, &
-       eintl, eintr
-  real, intent(OUT), DIMENSION(numCells) :: &
-       v, vl, vr
-       
-
-!! ----LOCAL ----------------
-  real,dimension(numCells) :: rhog, rhogl, rhogr, drhog, rg6,&
-                              coeff1, coeff2, coeff3, coeff4, coeff5, &
-                              flatn, flatn1
-
-  
-  integer :: i, j, k, n, numIntCells5
-  
+  ! arguments associated with cell-average data
+  integer, intent(in) :: sweepDir, numFluxActv, numIntrfcActv, numCells
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, &
+                                            gamc, game, grav, eint, dx, x
+  real, intent(in), dimension(numCells,hy_numXn) :: xn
+
+  ! arguments for compressed fluxes/reconstruction
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  real, intent(inout), dimension(numIntrfcActv) :: rhol, rhor, ul, ur, &
+                                                   utl, utr, uttl, uttr, &
+                                                   pl, pr, eintl, eintr, &
+                                                   gravl, gravr, vl, vr, &
+                                                   gamcl, gamcr, gamel, &
+                                                   gamer, pwl, pwr
+  real, intent(inout), dimension(numIntrfcActv,hy_numXn) :: xnl, xnr
+  real, intent(inout), dimension(numFluxActv) :: drhol, drhor, rho6l, rho6r, &
+                                                  dul, dur, u6l, u6r, dutl, dutr, &
+                                                  ut6l, ut6r, duttl, duttr, utt6l, &
+                                                  utt6r, dpl, dpr, p6l, p6r, deintl, &
+                                                  deintr, eint6l, eint6r, dgamel, &
+                                                  dgamer, game6l, game6r, dgamcl, &
+                                                  dgamcr, gamc6l, gamc6r, dgravl, &
+                                                  dgravr, grav6l, grav6r, dpwl, dpwr, &
+                                                  pw6l, pw6r
+  real, intent(inout), dimension(numFluxActv,hy_numXn) :: dxnl, dxnr, xn6l, xn6r
+  !real, intent(out), DIMENSION(numCells) :: v
+
+  ! local
+  integer :: i, j, k, n
+  real, dimension(numCells) :: etot, flatn1
   real :: checkl, checkr, check, &
-       dcheckl, dcheckr, dcheck  
+       dcheckl, dcheckr, dcheck
 
-  logical :: charLimiting
+  !***** needed for now (testing)
+  integer numIntCells5, numIntCells
+  numIntCells = numCells-8
+  numIntCells5 = numIntCells + 5
+
+  ! check if using characteristic or primitive variables for reconstruction
+  if ( hy_charLimiting ) then
+
+    ! Apply the limiting using the characteristic variables - this method project
+    ! the primitive variables (density, velocity fields, and pressure) onto the
+    ! chracteristic variables, apply limitings, and then project them back to the
+    ! primitive variables.
+
+    call ppm_interp_char(sweepDir, numIntCells, numCells, &
+                     numIntrfcActv, intrfcKey, &
+                     rhol, rho, rhor, &
+                     ul,   u,   ur,   &
+                     utl,  ut,  utr,  &
+                     uttl, utt, uttr, &
+                     pl,   p,   pr,   &
+                     gamc, game)
+
+    ! interpolate the mass fractions and look for contacts
+    do n = 1, hy_numXn
+      call ppm_interp(numCells, numIntrfcActv, xnl(:,n), xn(:,n), xnr(:,n), intrfcKey)
+    end do
 
-  numIntCells5 = numIntCells + 5 
-  
-! get the coefficients of the quartic polynomial through the zones neighboring
-! each zone.  The polynomial used is Eq. 1.6 in Colella & Woodward. 
-
-  do i = 1, numCells
-     coeff1(i) = 0.e0
-     coeff2(i) = 0.e0
-     coeff3(i) = 0.e0     
-     coeff4(i) = 0.e0
-     coeff5(i) = 0.e0
-     rhog(i) = 0.e0
-     rhogl(i) = 0.e0
-     rhogr(i) = 0.e0     
-     drhog(i) = 0.e0
-     rg6(i) = 0.e0
-     flatn(i) = 0.e0
-     flatn1(i) = 0.e0
-  end do
+  else
 
-  call coeff(numIntCells,numCells, dx, coeff1, coeff2, coeff3, coeff4, coeff5)
+    ! apply the limiting using the primitive variables
+    !call Timers_start("ppm_interp")
+    call ppm_interp(numCells, numIntrfcActv, rhol, rho, rhor, intrfcKey)
+
+    ! interpolate the mass fractions and look for contacts
+    do n = 1, hy_numXn
+      call ppm_interp(numCells, numIntrfcActv, xnl(:,n), xn(:,n), xnr(:,n), intrfcKey)
+    end do
+
+    ! interpolate the remainder of the variables
+    call ppm_interp(numCells, numIntrfcActv, ul, u, ur, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, utl, ut, utr, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, uttl, utt, uttr, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, pl, p, pr, intrfcKey)
 
+  endif
 
-! interpolate the density to find the interface values, rhol and rhor for
-! each zone
+  ! interpolate the adiabatic indices (game and gamc) and gravity
+  call ppm_interp(numCells, numIntrfcActv, eintl, eint, eintr, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gamel, game, gamer, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gamcl, gamc, gamcr, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gravl, grav, gravr, intrfcKey)
+  !call Timers_stop("ppm_interp")
 
+  !call Timers_start("flattening")
+  if ( hy_igodu == 1 ) then
 
-  if (hy_charLimiting) then
-     ! Apply the limiting using the characteristic variables - this method project
-     ! the primitive variables (density, velocity fields, and pressure) onto the
-     ! chracteristic variables, apply limitings, and then project them back to the
-     ! primitive variables.
-
-     call interp_char(sweepDir, numIntCells, numCells, &
-                      rhol, rho, rhor, &
-                      ul,   u,   ur,   &
-                      utl,  ut,  utr,  &
-                      uttl, utt, uttr, &
-                      pl,   p,   pr,   &
-                      gamc, game,      &
-                      coeff1,coeff2,coeff3,coeff4,coeff5)
-
-     if (hy_useSteepening) &
-          call detect(numIntCells,numCells,rhol, rho, rhor, &
-                      hy_smlrho, rho, p, game, dx, x)
-
-
-     ! interpolate the mass fractions and look for contacts
-     do n = 1, hy_numXn
-
-        call interp(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n),  &
-                    coeff1, coeff2, coeff3, coeff4, coeff5)
-     
-        if (hy_useSteepening .and. n <= NSPECIES) & 
-             call detect(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n), hy_smallx,  &
-                         rho, p, game, dx, x)
-     
-     end do
+     ! select Godunov method, if desired
+     hy_flatn(4:numIntCells5) = 1.e0
 
   else
 
-     ! Apply the limiting using the primitive variables - original version of PPM
-     call interp(numIntCells,numCells,rhol, rho, rhor, coeff1, coeff2, coeff3, coeff4, coeff5)
+     if ( hy_useFlattening ) then
 
-     ! search for contact discontinuities, and steepen the profile if we find them
-     ! -- this prevents the contact from spreading out over too many zones as it
-     ! propagates
-     if (hy_useSteepening) &
-          call detect(numIntCells,numCells,rhol, rho, rhor, &
-                      hy_smlrho, rho, p, game, dx, x)
-    
-
-     ! interpolate the mass fractions and look for contacts
-     do n = 1, hy_numXn
-     
-        call interp(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n),  &
-                    coeff1, coeff2, coeff3, coeff4, coeff5)
-     
-        if (hy_useSteepening .and. n <= NSPECIES) & 
-             call detect(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n), hy_smallx,  &
-                         rho, p, game, dx, x)
-     
-     end do
-      
-     ! interpolate the remainder of the variables 
-     call interp(numIntCells,numCells,ul,   u,   ur,   coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,utl,  ut,  utr,  coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,uttl, utt, uttr, coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,pl,   p,   pr,   coeff1,coeff2,coeff3,coeff4,coeff5)
+        ! look for shocks and flatten the structure if they are too thin
 
-  endif
+        ! TAH (3/16/2016): Pass total energy to the flaten call for energy steepness correction
+        if ( hy_enrFlattening ) &
+             etot(:) =  eint(:) + 0.5e0*(u(:)**2 + K2D*ut(:)**2 + K3D*utt(:)**2)
+
+        call flaten( numIntCells, numCells, u, p, etot, hy_flatn )
+
+        do i = 4, numIntCells5
+           flatn1(i) = 1.e0 - hy_flatn(i)
+        end do
+
+        ! modify left and right states using flattening
+        do i = 1, numIntrfcActv
+
+          ! compute uncompressed index
+          k = intrfcKey(i)
+
+          if ((k-1).ge.4) then
+            rhol (i) = hy_flatn(k-1) * rho (k-1) + flatn1(k-1) * rhol (i)
+            ul   (i) = hy_flatn(k-1) * u   (k-1) + flatn1(k-1) * ul   (i)
+            utl  (i) = hy_flatn(k-1) * ut  (k-1) + flatn1(k-1) * utl  (i)
+            uttl (i) = hy_flatn(k-1) * utt (k-1) + flatn1(k-1) * uttl (i)
+            pl   (i) = hy_flatn(k-1) * p   (k-1) + flatn1(k-1) * pl   (i)
+            gamel(i) = hy_flatn(k-1) * game(k-1) + flatn1(k-1) * gamel(i)
+            gamcl(i) = hy_flatn(k-1) * gamc(k-1) + flatn1(k-1) * gamcl(i)
+            eintl(i) = hy_flatn(k-1) * eint(k-1) + flatn1(k-1) * eintl(i)
+          endif
+
+          if (k.le.numIntCells5) then
+            rhor (i) = hy_flatn(k) * rho (k) + flatn1(k) * rhor (i)
+            ur   (i) = hy_flatn(k) * u   (k) + flatn1(k) * ur   (i)
+            utr  (i) = hy_flatn(k) * ut  (k) + flatn1(k) * utr  (i)
+            uttr (i) = hy_flatn(k) * utt (k) + flatn1(k) * uttr (i)
+            pr   (i) = hy_flatn(k) * p   (k) + flatn1(k) * pr   (i)
+            gamer(i) = hy_flatn(k) * game(k) + flatn1(k) * gamer(i)
+            gamcr(i) = hy_flatn(k) * gamc(k) + flatn1(k) * gamcr(i)
+            eintr(i) = hy_flatn(k) * eint(k) + flatn1(k) * eintr(i)
+          endif
+
+        end do
+
+        do n = 1, hy_numXn
+          do i = 1, numIntrfcActv
+            k = intrfcKey(i)
+            if ((k-1).ge.4) xnl(i,n) = hy_flatn(k-1) * xn(k-1,n) + flatn1(k-1) * xnl(i,n)
+            if (k.le.numIntCells5) xnr(i,n) = hy_flatn(k) * xn(k,n) + flatn1(k) * xnr(i,n)
+          enddo
+        end do
+        !call Timers_stop("flattening")
+
+     else
+
+        hy_flatn(4:numIntCells5) = 0.e0
+
+     end if
+
+  end if
+
+  ! monotonize and compute the final coefficients for the profile
+  !call Timers_start("ppm_profile")
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    rhol, rho, rhor, drhol, drhor, rho6l, rho6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    ul, u, ur, dul, dur, u6l, u6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    utl, ut, utr, dutl, dutr, ut6l, ut6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    uttl, utt, uttr, duttl, duttr, utt6l, utt6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    pl, p, pr, dpl, dpr, p6l, p6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    eintl, eint, eintr, deintl, deintr, eint6l, eint6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gamcl, gamc, gamcr, dgamcl, dgamcr, gamc6l, gamc6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gamel, game, gamer, dgamel, dgamer, game6l, game6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gravl, grav, gravr, dgravl, dgravr, grav6l, grav6r)
 
-  ! interpolate the adiabatic indices (game and gamc) and gravity
-  call interp(numIntCells,numCells,gamel,   game,gamer,   coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells,numCells,gamcl,   gamc,gamcr,   coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells,numCells,hy_gravl,grav,hy_gravr,coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells, numCells,eintl, eint, eintr,&
-              coeff1,coeff2,coeff3,coeff4,coeff5)
-
-
-  ! look for shocks and flatten the structure if they are too thin    
-  call flaten(numIntCells, numCells, u, p, flatn, flatn1)
-
-  do i = 4, numIntCells5
-     rhol (i) = flatn(i) * rho (i) + flatn1(i) * rhol (i)
-     rhor (i) = flatn(i) * rho (i) + flatn1(i) * rhor (i)
-     
-     ul   (i) = flatn(i) * u   (i) + flatn1(i) * ul   (i)
-     ur   (i) = flatn(i) * u   (i) + flatn1(i) * ur   (i)
-     
-     utl  (i) = flatn(i) * ut  (i) + flatn1(i) * utl  (i)
-     utr  (i) = flatn(i) * ut  (i) + flatn1(i) * utr  (i)
-     
-     uttl (i) = flatn(i) * utt (i) + flatn1(i) * uttl (i)
-     uttr (i) = flatn(i) * utt (i) + flatn1(i) * uttr (i)
-     
-     pl   (i) = flatn(i) * p   (i) + flatn1(i) * pl   (i)
-     pr   (i) = flatn(i) * p   (i) + flatn1(i) * pr   (i)
-     
-     gamel(i) = flatn(i) * game(i) + flatn1(i) * gamel(i)
-     gamer(i) = flatn(i) * game(i) + flatn1(i) * gamer(i)
-     
-     gamcl(i) = flatn(i) * gamc(i) + flatn1(i) * gamcl(i)
-     gamcr(i) = flatn(i) * gamc(i) + flatn1(i) * gamcr(i)
-
-     eintl(i) = flatn(i) * eint(i) + flatn1(i) * eintl(i)
-     eintr(i) = flatn(i) * eint(i) + flatn1(i) * eintr(i)
-  end do
-    
   do n = 1, hy_numXn
-     do  i = 4, numIntCells5
-        xnl(i,n) = flatn(i) * xn(i,n) + flatn1(i) * xnl(i,n)
-        xnr(i,n) = flatn(i) * xn(i,n) + flatn1(i) * xnr(i,n)
-     end do
+    call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                      xnl(:,n), xn(:,n), xnr(:,n), dxnl(:,n), dxnr(:,n), &
+                      xn6l(:,n), xn6r(:,n))
   end do
+  !call Timers_stop("ppm_profile")
 
-
-  ! make sure every thing is monotonic -- no new maxima or minima
-  ! should have been introduced (see Colella & Woodward Eq. 1.10)
-
-  call monot(numIntCells, numCells,rhol,     rho,  rhor,     hy_drho,  hy_rho6 )
-  call monot(numIntCells, numCells,ul,       u,    ur,       hy_du,    hy_u6   )
-  call monot(numIntCells, numCells,utl,      ut,   utr,      hy_dut,   hy_ut6  )
-  call monot(numIntCells, numCells,uttl,     utt,  uttr,     hy_dutt,  hy_utt6 )
-  call monot(numIntCells, numCells,pl,       p,    pr,       hy_dp,    hy_p6   )
-  call monot(numIntCells, numCells,gamel,    game, gamer,    hy_dgame, hy_game6)
-  call monot(numIntCells, numCells,gamcl,    gamc, gamcr,    hy_dgamc, hy_gamc6)
-  call monot(numIntCells, numCells,eintl,    eint, eintr,    hy_deint, hy_eint6)
-  call monot(numIntCells, numCells,hy_gravl, grav, hy_gravr, hy_dgrav, hy_grav6)
-  
-  do n = 1, hy_numXn
-     call monot(numIntCells, numCells,xnl(1,n),xn(1,n),xnr(1,n),hy_dxn(1,n), hy_xn6(1,n))
-  end do
-    
-  do i = 4, numIntCells5
-     vl(i) = 1.e0 / rhol(i)
-     v (i) = 1.e0 / rho (i)
-     vr(i) = 1.e0 / rhor(i)
+  ! set the wave-generating pressure values (no 'modifystates')
+  pwr = pr
+  pwl = pl
+  dpwr = dpr
+  dpwl = dpl
+  pw6r = p6r
+  pw6l = p6l
+
+  !do i = 4, numIntCells5
+  !   v(i) = 1.e0 / rho(i)
+  !enddo
+  do i = 1, numIntrfcActv
+    vl(i) = 1.e0 / rhol(i)
+    vr(i) = 1.e0 / rhor(i)
   end do
 
-! if we are doing the modified states version of PPM, subtract the 
-! rho*g contribution off the pressure.
-!
-!  eqns (27)--(31), Zingale et al (2002) ApJ
-!
-
-  hy_pwl(4:numIntCells5)  = pl(4:numIntCells5)
-  hy_pwr(4:numIntCells5)  = pr(4:numIntCells5)
-  
-  if (hy_ppmModifystates) then
-
-! for the modified states formalism, interpolate the quantity rho*g, which
-! will be removed from the pressure when computing the wave structure
-
-     rhog = rho*grav
-     
-     call interp(numIntCells, numCells,rhogl, rhog, rhogr, &
-                 coeff1,coeff2,coeff3,coeff4,coeff5)
-     
-     do i = 4, numIntCells5
-        rhogl(i) = flatn(i) * rhog(i) + flatn1(i) * rhogl(i)
-        rhogr(i) = flatn(i) * rhog(i) + flatn1(i) * rhogr(i)
-     end do
-     
-     call monot(numIntCells, numCells,rhogl, rhog, rhogr, drhog, rg6)
-     
-     hy_pwcubic = dx/3.e0*rg6
-     hy_pw6r    = hy_p6 + 0.5e0*dx*(drhog+rg6)
-     hy_pw6l    = hy_p6 + 0.5e0*dx*(drhog-rg6)
-     hy_dpw     = hy_dp - dx*(rhogl + 0.5e0*(drhog+rg6))
-     
-  else
-     
-     hy_pwcubic = 0.e0
-     hy_dpw     = hy_dp
-     hy_pw6l    = hy_p6
-     hy_pw6r    = hy_p6
-     
-  endif
-
-! if we are doing the CMA flattening of the abundances, do it now
-  if (hy_useCmaFlattening) &
-       call cma_flatten(numIntCells, numCells, guard,xn, xnl, xnr, hy_dxn, hy_xn6)
-
-
-end subroutine intrfc
-
+end subroutine ppm_intrfc
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90	2021-02-23 17:19:16.106458576 -0500
@@ -0,0 +1,263 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask
+!!
+!! NAME
+!!
+!!  ppm_mask
+!!
+!! DESCRIPTION
+!!
+!!  Computes a mask for the 1D pencil of data going through ppm_hydro (hydro_1d).
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!!  A mask for the 1D pencil of data going through ppm_hydro (hydro_1d).
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine ppm_mask(lb, numCells, primDim, secCell, terCell, &
+                      numintrfc, numflx, mask, intrfcmask, flxmask)
+  
+  ! declare modules used
+  use Hydro_data, ONLY : hy_fluxmask, hy_lstart, hy_simpleMask, &
+                          hy_numAdaptiveFlux, hy_numTotFlux
+  use wvlt_data, ONLY : iCellsInt, jCellsInt, intrfcKey, &
+                        fluxKey, hydroSweepLvl, wvlt_maxLvl, &
+                        numFluxActv, numIntrfcActv, wvlt_interpHydro
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! arguments
+  integer, intent(in) :: lb, numCells, primDim, secCell, terCell
+  integer, intent(inout) :: numflx, numintrfc
+  real, dimension(numCells, 2), intent(in) :: mask
+  integer, allocatable, intent(inout) :: intrfcmask(:), flxmask(:)
+
+  ! local
+  integer :: l, i, j, k, itot, dl! n2
+  integer :: ng = 4
+  integer :: lstart
+  logical :: flag
+  logical, dimension(numCells) :: tmpmask1, tmpmask2
+
+  ! initialize values
+  numflx = 0
+  numintrfc = 0
+  tmpmask1 = .false.
+
+  if (wvlt_interpHydro) then
+
+    if (hy_simpleMask) then
+
+#if NDIM == 1
+      lstart = hydroSweepLvl(1,1,1,lb)
+#endif
+
+#if NDIM == 2
+      lstart = hydroSweepLvl(secCell,primDim,1,lb)
+#endif
+
+      ! emergency precaution (lstart is junk when restarting simulation)
+      ! this is not a perfect fix; if junk is 1 or 2... problem
+      flag = .false.
+      do l = 1, wvlt_maxLvl
+        if (lstart.eq.l) then
+          flag = .true.
+        endif
+      enddo
+      if (.not.flag) then
+        lstart = wvlt_maxLvl
+      endif
+
+      ! get number of interfaces and fluxes
+      numintrfc = numIntrfcActv(lstart)
+      numflx = numFluxActv(lstart)
+
+      ! allocate memory for intrfcmask and fluxmask
+      allocate(flxmask(numflx))
+      allocate(intrfcmask(numintrfc))
+
+      ! get the associated intrfckey & fluxkey
+      intrfcmask = intrfcKey(1:numintrfc,lstart)
+      flxmask = fluxKey(1:numflx,lstart)
+
+      ! set hydro_data lstart value
+      hy_lstart = lstart
+
+    ! compute custom mask
+    else
+
+      !------- first need to compute the mask for direct fluxes -------!
+
+      ! loop through hierarchy
+      do l = 1, wvlt_maxLvl-1
+      
+        ! put all coarse interfaces in mask
+        if (l.eq.1) then
+
+          ! current level difference
+          dl = wvlt_maxLvl - l
+
+          do i = 1, iCellsInt(l)+1
+
+            ! compute total index on fine grid
+            itot = 2**dl * (i-1) + 1 + ng
+
+            ! put in the mask
+            tmpmask1(itot) = .true.
+
+            numflx = numflx + 1
+
+          enddo
+
+        endif
+
+        ! recompute difference for level above
+        dl = wvlt_maxLvl - (l+1)
+
+        ! now check for even-indexed cells at level above
+        do i = 1, iCellsInt(l)
+
+          ! compute fine-grid index for target interface
+          itot = 2**dl * (2*i-1) + 1 + ng
+
+          ! evaluate if tmpmask1 is true or false
+          if (mask(itot,l).gt.0) then
+
+            ! set tmpmask1 and increment
+            tmpmask1(itot) = .true.
+
+            ! increment
+            numflx = numflx + 1
+
+          endif
+
+        enddo
+
+      enddo
+
+      !------- proceed to create compressed arrays -------!
+
+      ! zero out the ends of first mask (ghost regions)
+      tmpmask1(1:4) = .false.
+      tmpmask1((numCells-2):numCells) = .false.
+
+      ! intialize interface mask
+      tmpmask2 = .false.
+
+      ! loop over interior interfaces
+      do i = 2, numCells-1
+
+        ! check if fluxMask is active
+        if (tmpmask1(i)) then
+
+          ! need interfaces to left and right to be active as well
+          tmpmask2(i-1:i+1) = .true.
+
+        endif
+
+      enddo
+
+      ! now count up the number of interfaces active
+      numintrfc = count(tmpmask2)
+
+      ! allocate memory for intrfcmask and fluxmask
+      allocate(flxmask(numflx))
+      allocate(intrfcmask(numintrfc))
+
+      ! fill in these arrays with mappings
+      j = 1
+      k = 1
+      do i = 1, numCells
+
+        ! check tmpmask2 active 
+        if (tmpmask2(i)) then
+
+          ! set interface key value
+          intrfcmask(j) = i
+
+          if (tmpmask1(i)) then
+
+            ! set flux key value
+            flxmask(k) = j
+
+            ! increment
+            k = k + 1
+
+          endif
+
+          ! increment counter
+          j = j + 1
+
+        endif
+
+      enddo
+
+      ! copy into hydro_data vector
+      hy_fluxmask = tmpmask1
+
+    endif
+
+  else
+
+    ! this needs to be on for ppm_decode
+    hy_simpleMask = .true.
+
+    ! fluxes computed at finest level of local MR hierarchy
+    lstart = wvlt_maxLvl
+
+    ! get number of interfaces and fluxes
+    numintrfc = numIntrfcActv(lstart)
+    numflx = numFluxActv(lstart)
+
+    ! allocate memory for intrfcmask and fluxmask
+    allocate(flxmask(numflx))
+    allocate(intrfcmask(numintrfc))
+
+    ! get the associated intrfckey & fluxkey
+    intrfcmask = intrfcKey(1:numintrfc,lstart)
+    flxmask = fluxKey(1:numflx,lstart)
+
+    ! set hydro_data lstart value
+    hy_lstart = lstart
+
+  endif
+
+  ! set counters
+  hy_numAdaptiveFlux = hy_numAdaptiveFlux + numflx
+  hy_numTotFlux = hy_numTotFlux + numFluxActv(wvlt_maxLvl)
+
+end subroutine ppm_mask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90	2021-02-23 17:58:37.373237823 -0500
@@ -0,0 +1,154 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile
+!!
+!! NAME
+!! 
+!!  ppm_profile
+!!
+!! DESCRIPTION
+!!
+!!  Apply monotonicity constraint to interpolation parabola -- constrain
+!!  the parabolic distribution of each variable so that all points in the
+!!  parabola fall between the zone interface values.
+!!
+!! ARGUMENTS
+!!
+!! RESULT
+!!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
+!!
+!! LICENSE
+!!
+!!  This file is part of the Hybrid adaptive multiresolution patch for FLASH
+!!  (HAMR-FLASH).
+!!
+!!  This program is free software: you can redistribute it and/or modify
+!!  it under the terms of the GNU General Public License as published by
+!!  the Free Software Foundation, either version 3 of the License, or
+!!  (at your option) any later version.
+!!  
+!!  This program is distributed in the hope that it will be useful, but WITHOUT ANY
+!!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+!!  PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+!!  
+!!  You should have received a copy of the GNU General Public License along with
+!!  this program.  If not, see <https://www.gnu.org/licenses/>.
+!!
+!! AUTHOR
+!!
+!!  Brandon Gusto (email: blg13@my.fsu.edu),
+!!  Department of Scientific Computing,
+!!  Florida State University
+!!  
+!!***
+
+subroutine ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, &
+                       intrfcKey, al, a, ar, dal, dar, a6l, a6r)
+
+  implicit none
+
+  ! arguments
+  integer, intent(in) :: numCells, numIntrfcActv, numFluxActv
+  real, intent(inout), dimension(numIntrfcActv) :: al, ar
+  real, intent(in),    dimension(numCells) :: a
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  real, intent(inout), dimension(numFluxActv) :: dal, dar, a6l, a6r
+
+  ! local
+  integer :: i, j, flag, k, jlo, jhi
+  real :: s1, s2, s3, ulo, uhi
+
+  !-----------------------------------------------------------------------------
+
+  ! set flag
+  flag = 0
+
+  ! monotonize profile in cells bordering active flux 
+  do i = 1, numFluxActv
+
+    ! compute indices in compressed space of neighboring interfaces
+    j = fluxKey(i)
+    jlo = j - 1
+    jhi = j + 1
+
+    ! fine-grid (right cell index of interface)
+    k = intrfcKey(j)
+
+    ! get left and right cell of target interface
+    ulo = a(k-1)
+    uhi = a(k)
+
+    if (flag.ne.(k-1)) then
+
+      dal(i) = al(j) - ar(jlo)
+
+      dal(i) = sign(1.e0,dal(i))
+
+      s1 = (al(j) - ulo)*(ar(jlo) - ulo)
+
+      if (s1.ge.0.e0) then
+         ar(jlo) = ulo 
+         al(j) = ulo
+      end if
+
+      s1 = (al(j) - ulo)*(ar(jlo) - ulo)
+
+      if (s1/=0.e0) then
+         s2 = 3.e0*ulo - 2.e0*al(j)
+         s3 = 3.e0*ulo - 2.e0*ar(jlo)
+      else
+         s2 = ar(jlo)
+         s3 = al(j)
+      end if
+
+      if ( dal(i)*(ar(jlo) - s2) < 0.e0) ar(jlo) = s2
+      if ( dal(i)*(s3 - al(j)) < 0.e0) al(j) = s3
+
+      dal(i) = al(j) - ar(jlo)
+      a6l(i) = 6.0*ulo - 3.0e0*(ar(jlo) + al(j))
+
+    else
+
+      dal(i) = dar(i-1)
+      a6l(i) = a6r(i-1)
+
+    endif ! checking flag
+
+    ! set flag
+    flag = k-1
+
+    ! if using this routine for Richardson-based LTE estimation, don't use monotonization
+    dar(i) = al(jhi) - ar(j)
+
+    dar(i) = sign(1.e0,dar(i))
+
+    s1 = (al(jhi) - uhi)*(ar(j) - uhi)
+
+    if (s1.ge.0.e0) then
+       ar(j) = uhi 
+       al(jhi) = uhi
+    end if
+
+    s1 = (al(jhi) - uhi)*(ar(j) - uhi)
+
+    if (s1/=0.e0) then
+       s2 = 3.e0*uhi - 2.e0*al(jhi)
+       s3 = 3.e0*uhi - 2.e0*ar(j)
+    else
+       s2 = ar(j)
+       s3 = al(jhi)
+    end if
+
+    if ( dar(i)*(ar(j) - s2) < 0.e0) ar(j) = s2
+    if ( dar(i)*(s3 - al(jhi)) < 0.e0) al(jhi) = s3
+
+    dar(i) = al(jhi) - ar(j)
+    a6r(i) = 6.0*uhi - 3.0e0*(ar(j) + al(jhi))
+
+  enddo
+
+end subroutine ppm_profile
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90	2021-02-23 18:16:43.506798020 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90	2021-02-23 17:59:25.157628247 -0500
@@ -1,27 +1,11 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/rieman
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann
 !!
 !! NAME
 !! 
-!!  rieman
+!!  ppm_riemann
 !!
 !! SYNOPSIS
 !!
-!!       call rieman ( integer(IN) :: numIntCells, 
-!!                     integer(IN) :: numCells, 
-!!                     real(OUT)   :: rhoav(numCells), 
-!!                     real(OUT)   :: uav(numCells), 
-!!                     real(OUT)   :: utav(numCells), 
-!!                     real(OUT)   :: uttav(numCells), 
-!!                     real(OUT)   :: pav(numCells), 
-!!                     real(OUT)   :: urell(numCells), 
-!!                     real(IN)    :: ugrdl(numCells), 
-!!                     real(IN)    :: game(numCells), 
-!!                     real(OUT)   :: gameav(numCells), 
-!!                     real(OUT)   :: eintAv(numCells),
-!!                     real(OUT)   :: xnav(numCells, hy_numXn), 
-!!                     real(IN) :: x(numCells))
-!!                 
-!!
 !!
 !! DESCRIPTION
 !!  
@@ -71,422 +55,404 @@
 !!
 !! ARGUMENTS
 !!
-!! numIntCells :
-!! numCells :
-!! rhoav :
-!! uav :
-!! utav :
-!! uttav :
-!! pav :
-!! urell :
-!! ugrdl :
-!! game :
-!! gameav :
-!! eintAv :
-!! xnav :
-!! x :
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
+!! DISCLAIMER
 !!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
 !!***
-subroutine rieman (numIntCells, numCells, &
-                   rhoav, uav, utav, uttav, pav, &
-                   urell, ugrdl, game, gameav, eintAv, xnav, x)
+subroutine ppm_riemann(numCells, numFluxActv, numIntrfcActv, &
+                         fluxKey, intrfcKey, rhoav, uav, utav, uttav, pav, &
+                         eintav, xnav, gameav, clft, crght, &
+                          ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                          prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                          vlft, vrght, xnlft, xnrght, game)
                    
-
   use Hydro_data, ONLY: hy_numXn, &
-                        hy_gmelft, hy_gmergt, &
-                        hy_plft,   hy_prght,  &
-                        hy_clft,   hy_crght,  &
-                        hy_ulft,   hy_urght,  &
-                        hy_vlft,   hy_vrght,  &
-                        hy_utlft,  hy_utrght, &
-                        hy_uttlft, hy_uttrgt, &
-                        hy_eiLft,  hy_eiRght, &
-                        hy_xnlft,  hy_xnrght, &
                         hy_smallp, hy_smallu, &
                         hy_smlrho, hy_nriem,  &
-                        hy_gmclft, hy_gmcrgt,hy_pstor, &
-                        hy_riemanTol
+                        hy_ptrial, hy_perror, &
+                        hy_wlft,   hy_wrght,  &
+                        hy_riemanTol, hy_riemanTolAbort, hy_rieman_printDiag
   use Driver_interface, ONLY : Driver_abortFlash
 
-
   implicit none
-!! Arguments ---------------------------------- 
-
-  integer, intent (IN) :: numIntCells,numCells
-  real, intent(IN), DIMENSION(numCells) :: x
-  real, intent(IN), DIMENSION(numCells) :: ugrdl, game
-  real, intent(OUT), DIMENSION(numCells) :: uav, rhoav, utav, uttav, pav, &
-                               urell, gameav, eintAv
-  real, intent(OUT), DIMENSION(numCells,hy_numXn) :: xnav
 
+#include "constants.h"
 
-!! Local variable ---------------------------------
-  real, DIMENSION(numCells) :: wlft, wrght, pstar, ustar, vstar, cestar, &
-       rhostr, westar, ps, us, uts, utts, vs, rhos, ces, ws, wes, &
-       gmstar, games, gamcs
+  ! arguments
+  integer, intent(in) :: numCells, numFluxActv, numIntrfcActv
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  real, intent(in), dimension(numCells) :: game
+  real, intent(in), dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                                  utrght, uttlft, uttrght, plft, &
+                                                  prght, eilft, eirght, gmelft, &
+                                                  gmerght, gmclft, gmcrght, &
+                                                  vlft, vrght
+  real, intent(in), dimension(numFluxActv, hy_numXn) :: xnlft, xnrght
+  real, intent(out), dimension(numFluxActv) :: uav, rhoav, utav, uttav, pav, &
+                                                gameav, eintav
+  real, intent(out), dimension(numFluxActv,hy_numXn) :: xnav
+
+
+  ! local data
+  real, dimension(numFluxActv) :: wlft, wrght, pstar, ustar, vstar, cestar, &
+                                  rhostr, westar, ps, us, uts, utts, vs, &
+                                  rhos, ces, ws, wes, gmstar, games, gamcs
+  real, dimension(numFluxActv) :: pstar1, pstar2, gmstrl, gmstrr, &
+                                  wlft1, wrght1, gmin, gmax, &
+                                  gamfac, aux, scrch1, scrch2, &
+                                  scrch3, scrch4
+  real  :: ge, gc, ustrl1, ustrr1, ustrl2, ustrr2, &
+           delu1, delu2, pres_err
+  integer :: i, j, k, n
+  integer :: perr_minloc(1)
+  real, parameter :: small_dp = 1.e2 * epsilon(1.e0)
 
   
-  real, DIMENSION(numCells) :: pstar1, pstar2, gmstrl, gmstrr, &
-       &   wlft1, wrght1, gmin, gmax, &
-       &   gamfac, aux
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4
+  ! We carry around two adiabatic indices (gammas).  gamc is usually
+  ! referred to as gamma_1, and is d(log P)/d(log rho) (CG Eq. 7).  game
+  ! is CG Eq. 8.      
 
-  real  ::  ge, gc, ustrl1, ustrr1, ustrl2, ustrr2, &
-       & delu1, delu2, pres_err
-  
-  integer :: i, j, k, n, numIntCells5, ierr
-  
-  
-  character(len=1), save :: dirs(3) = (/ 'x', 'y', 'z' /)
-  
-  real, parameter :: small_dp = 1.e2 * epsilon(1.e0)
+  ! calculate limits on gamma based on the values in the neighboring zones
+  ! gamfac is the max gamma factor in CG Eq. 31, and is used over and over,
+  ! so store it for efficiency.
+  do i = 1, numFluxActv
 
-  
-    !--------------------------------------------------------------------------
+    ! compute interface indices
+    j = fluxKey(i)
+    k = intrfcKey(j)
+
+    ! compute values
+    aux(i)    = sqrt (0.5e0 * (game(k) - 1.0e0) / game(k))
+    ge        = 0.5e0 * (gmelft(i) + gmerght(i))
+    gc        = 0.5e0 * (gmclft(i) + gmcrght(i))
+    gamfac(i) = (1.e0 - ge / gc) * (ge - 1.e0)
+    gmin(i)   = min(game(k-2), game(k-1), game(k), game(k+1))
+    gmax(i)   = max(game(k-2), game(k-1), game(k), game(k+1))
 
-    ! We carry around two adiabatic indices (gammas).  gamc is usually
-    ! referred to as gamma_1, and is d(log P)/d(log rho) (CG Eq. 7).  game
-    ! is CG Eq. 8.      
-
-    ! calculate limits on gamma based on the values in the neighboring zones
-    ! gamfac is the max gamma factor in CG Eq. 31, and is used over and over,
-    ! so store it for efficiency.
-
-  numIntCells5 = numIntCells + 5
-
-  do i = 5, numIntCells5
-     aux(i)    = sqrt (0.5e0 * (game(i) - 1.0e0) / game(i))
-     ge        = 0.5e0 * (hy_gmelft(i) + hy_gmergt(i))
-     gc        = 0.5e0 * (hy_gmclft(i) + hy_gmcrgt(i))
-     gamfac(i) = (1.e0 - ge / gc) * (ge - 1.e0)
-     gmin(i)   = min (game(i-1), game(i), game(i+1))
-     gmax(i)   = max (game(i-1), game(i), game(i+1))
   enddo
   
-    ! construct first guess for secant iteration by assuming that the nonlinear 
-    ! wave speed is equal to the sound speed -- the resulting expression is the
-    ! same as Toro, Eq. 9.28 in the Primitive Variable Riemann Solver (PVRS).
-    ! See also Fry Eq. 72.
-    
-  do i = 5, numIntCells5
-     pstar1(i) = hy_prght(i) - hy_plft(i) - hy_crght(i) * (hy_urght(i) - hy_ulft(i))
-     pstar1(i) = hy_plft(i) + pstar1(i) * (hy_clft(i) / (hy_clft(i) + hy_crght(i)))
-     pstar1(i) = max (hy_smallp, pstar1(i))
-  enddo
+  ! construct first guess for secant iteration by assuming that the nonlinear 
+  ! wave speed is equal to the sound speed -- the resulting expression is the
+  ! same as Toro, Eq. 9.28 in the Primitive Variable Riemann Solver (PVRS).
+  ! see also Fry Eq. 72.
+  do i = 1, numFluxActv
+
+    ! compute values
+    pstar1(i) = prght(i) - plft(i) - crght(i) * (urght(i) - ulft(i))
+    pstar1(i) = plft(i) + pstar1(i) * (clft(i) / (clft(i) + crght(i)))
+    pstar1(i) = max (hy_smallp, pstar1(i))
 
-    ! calculate approximation jump in gamma acrosss the interface based on the 
-    ! first guess for the pressure jump.  There is a left and right 'star' region,
-    ! so we need gamma add both places.  Use CG Eq. 31 and 32, with definitions
-    ! as in CG Eq. 33.
-    
-  do i = 5, numIntCells5
-     gmstrl(i) = gamfac(i) * (pstar1(i) - hy_plft(i))
-     gmstrl(i) = hy_gmelft(i) + 2.e0 * gmstrl(i) / (pstar1(i) + hy_plft(i))
-     
-     gmstrr(i) = gamfac(i) * (pstar1(i) - hy_prght(i))
-     gmstrr(i) = hy_gmergt(i) + 2.e0 * gmstrr(i) / (pstar1(i) + hy_prght(i))
-     
-     gmstrl(i) = max (gmin(i), min( gmstrl(i), gmax(i)))
-     gmstrr(i) = max (gmin(i), min( gmstrr(i), gmax(i)))
   enddo
 
-    ! calculate nonlinear wave speeds for the left and right moving waves based
-    ! on the first guess for the pressure jump.  Again, there is a left and a 
-    ! right wave speed.  Compute this using CG Eq. 34.
-    
-  do i = 5, numIntCells5
-     scrch1(i) = pstar1(i) - (gmstrl(i) - 1.e0) * hy_plft(i) &
-          & / (hy_gmelft(i) - 1.e0)
-     if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
-     
-     wlft1(i)  = pstar1(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
-          & * (pstar1(i) + hy_plft(i))
-     wlft1(i)  = (pstar1(i) - hy_plft(i)) * wlft1(i) / (hy_vlft(i) * scrch1(i))
-     wlft1(i)  = sqrt(abs(wlft1(i)))
-     
+  ! calculate approximation jump in gamma acrosss the interface based on the 
+  ! first guess for the pressure jump.  There is a left and right 'star' region,
+  ! so we need gamma add both places.  Use CG Eq. 31 and 32, with definitions
+  ! as in CG Eq. 33.
+  do i = 1, numFluxActv
 
-     scrch2(i) = pstar1(i) - (gmstrr(i) - 1.e0) * hy_prght(i) /(hy_gmergt(i) - 1.e0)
-     
-     if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
-     
-     wrght1(i) = pstar1(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
-          & * (pstar1(i) + hy_prght(i))
-     wrght1(i) = (pstar1(i) - hy_prght(i)) * wrght1(i) / (hy_vrght(i) * scrch2(i))
-     wrght1(i) = sqrt(abs(wrght1(i)))
-     
-       ! if the pressure jump is small, the wave speed is just the sound speed
+    ! compute values
+    gmstrl(i) = gamfac(i) * (pstar1(i) - plft(i))
+    gmstrl(i) = gmelft(i) + 2.e0 * gmstrl(i) / (pstar1(i) + plft(i))
 
-     if (abs (pstar1(i) - hy_plft(i)) < small_dp*(pstar1(i) + hy_plft(i))) wlft1(i) = hy_clft(i)
-     wlft1(i)  = max (wlft1(i),  aux(i) * hy_clft(i))
-     
-     if (abs (pstar1(i) - hy_prght(i)) < small_dp*((pstar1(i) + hy_prght(i)))) wrght1(i) = hy_crght(i)
-     wrght1(i) = max (wrght1(i), aux(i) * hy_crght(i))
-  enddo
+    gmstrr(i) = gamfac(i) * (pstar1(i) - prght(i))
+    gmstrr(i) = gmerght(i) + 2.e0 * gmstrr(i) / (pstar1(i) + prght(i))
 
-    ! construct second guess for the pressure using the nonlinear wave speeds
-    ! from the first guess.  This is basically the same thing we did to get
-    ! pstar1, except now we are using the better wave speeds instead of the 
-    ! sound speed.
+    gmstrl(i) = max (gmin(i), min (gmax(i), gmstrl(i) ))
+    gmstrr(i) = max (gmin(i), min (gmax(i), gmstrr(i) ))
 
-  do i = 5, numIntCells5
-     pstar2(i) = hy_prght(i) - hy_plft(i) - wrght1(i) * (hy_urght(i) - hy_ulft(i))
-     pstar2(i) = hy_plft(i) + pstar2(i) * wlft1(i) / (wlft1(i) + wrght1(i))
-     pstar2(i) = max (hy_smallp, pstar2(i))
   enddo
 
-    ! begin the secant iteration -- see CG Eq. 17 for details.  We will continue to
-    ! interate for convergence until the error falls below tol (in which case, 
-    ! things are good), or we hit hy_nriem iterations (in which case we have a 
-    ! problem, and we spit out an error).
+  ! calculate nonlinear wave speeds for the left and right moving waves based
+  ! on the first guess for the pressure jump.  Again, there is a left and a 
+  ! right wave speed.  Compute this using CG Eq. 34.
+  do i = 1, numFluxActv
 
-  do i = 5, numIntCells5
-     
-     hy_pstor(1) = pstar1(i)
-     hy_pstor(2) = pstar2(i)
-     
-     do n = 1, hy_nriem
-        
-        ! new values for the gamma at the "star" state -- again, using CG Eq. 31
-          
-        gmstrl(i) = gamfac(i) * (pstar2(i) - hy_plft(i))
-        gmstrl(i) = hy_gmelft(i) + 2.e0 * gmstrl(i) / (pstar2(i) + hy_plft(i))
-        
-        gmstrr(i) = gamfac(i) * (pstar2(i) - hy_prght(i))
-        gmstrr(i) = hy_gmergt(i) + 2.e0 * gmstrr(i) / (pstar2(i) + hy_prght(i))
-        
-        gmstrl(i) = max (gmin(i), min (gmax(i), gmstrl(i)))
-        gmstrr(i) = max (gmin(i), min (gmax(i), gmstrr(i)))
-        
-        ! new nonlinear wave speeds, using CG Eq. 34 and the updated gammas
-          
-        scrch1(i) = pstar2(i) - (gmstrl(i) - 1.e0) * hy_plft(i) &
-             & / (hy_gmelft(i) - 1.e0)
-        if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
-        
-        wlft(i)   = pstar2(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
-             & * (pstar2(i) + hy_plft(i))
-        wlft(i)   = (pstar2(i) - hy_plft(i)) * wlft(i) / (hy_vlft(i) * scrch1(i))
-        wlft(i)   = sqrt(abs(wlft(i)))
-
-        scrch2(i) = pstar2(i) - (gmstrr(i) - 1.e0) * hy_prght(i) /(hy_gmergt(i) - 1.e0)
-
-        if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
-        
-        wrght(i)  = pstar2(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
-             & * (pstar2(i) + hy_prght(i))
-        wrght(i)  = (pstar2(i) - hy_prght(i)) * wrght(i) / (hy_vrght(i) * scrch2(i))
-        wrght(i)  = sqrt(abs(wrght(i)))
-        
-        ! if the pressure jump is small, the wave speed is just the sound speed
-
-        if (abs (pstar2(i) - hy_plft(i)) < small_dp*(pstar2(i) + hy_plft(i))) wlft(i) = hy_clft(i)
-        wlft(i)  = max (wlft(i), aux(i) * hy_clft(i))
-        
-        if (abs (pstar2(i) - hy_prght(i)) < small_dp*(pstar2(i) + hy_prght(i))) wrght(i) = hy_crght(i)
-        wrght(i) = max (wrght(i), aux(i) * hy_crght(i))
-
-        ! compute the velocities in the "star" state -- using CG Eq. 18 -- ustrl2 and
-        ! ustrr2 are the velocities they define there.  ustrl1 and ustrl2 seem to be
-        ! the velocities at the last time, since pstar1 is the old 'star' pressure, and
-        ! wlft1 is the old wave speed.
-        
-        ustrl1    =  hy_ulft(i) - (pstar1(i) -  hy_plft(i)) /  wlft1(i)
-        ustrr1    = hy_urght(i) + (pstar1(i) - hy_prght(i)) / wrght1(i)
-        ustrl2    =  hy_ulft(i) - (pstar2(i) -  hy_plft(i)) /   wlft(i)
-        ustrr2    = hy_urght(i) + (pstar2(i) - hy_prght(i)) /  wrght(i)
-        
-        delu1     = ustrl1 - ustrr1
-        delu2     = ustrl2 - ustrr2
-        scrch1(i) = delu2  - delu1
-        
-        if (abs(pstar2(i)-pstar1(i)) .le. hy_smallp) scrch1(i) = 0.e0
-        
-        if (abs(scrch1(i)) .lt. hy_smallu) then
-           delu2 = 0.e0
-           scrch1(i) = 1.e0
-        endif
-
-        ! pressure at the "star" state -- using CG Eq. 18
-
-        pstar(i)  = pstar2(i) - delu2 * (pstar2(i) - pstar1(i)) / scrch1(i)
-        pstar(i)  = max (hy_smallp, pstar(i))
-        
-        ! check for convergence of iteration, hy_riemanTol is a run-time parameter
-        
-        pres_err = abs(pstar(i)-pstar2(i)) / pstar(i)
-        if (pres_err .lt. hy_riemanTol) goto 10
-        
-        ! reset variables for next iteration
-          
-        pstar1(i) = pstar2(i)
-        pstar2(i) = pstar(i)
-        hy_pstor(n+2) = pstar(i)
-        
-        wlft1(i)  = wlft(i)
-        wrght1(i) = wrght(i)
-        
-     enddo
-     
-     n = n - 1
-     
-     ! print error message and stop code if iteration fails to converge
-     
-     print *, ' '
-     print *, 'Nonconvergence in subroutine rieman'
-     print *, ' '
-     print *, 'Zone index       = ', i
-     print *, 'Zone center      = ', x(i)
-     print *, 'Iterations tried = ', n+2
-     print *, 'Pressure error   = ', pres_err
-     print *, 'rieman_tol       = ', hy_riemanTol
-     print *, ' '
-     print *, 'pL       = ', hy_plft(i),   ' pR       =', hy_prght(i)
-     print *, 'uL       = ', hy_ulft(i),   ' uR       =', hy_urght(i)
-     print *, 'cL       = ', hy_clft(i),   ' cR       =', hy_crght(i)
-     print *, 'gamma_eL = ', hy_gmelft(i), ' gamma_eR =', hy_gmergt(i)
-     print *, 'gamma_cL = ', hy_gmclft(i), ' gamma_cR =', hy_gmcrgt(i)
-     print *, ' '
-     print *, 'Iteration history:'
-     print *, ' '
-     print '(A4, 2X, A20)', 'n', 'p*'
-     do j = 1, n+2
-        print '(I4, 2X, E20.12)', j, hy_pstor(j)
-     enddo
-     print *, ' '
-     print *, 'Terminating execution.'
-     call Driver_abortFlash('Nonconvergence in subroutine rieman')
-       
-       ! land here if the iterations have converged
-       
-10     continue
-     
-  enddo
+    ! compute values
+    scrch1(i) = pstar1(i) - (gmstrl(i) - 1.e0) * plft(i) &
+                  / (gmelft(i) - 1.e0)
+    if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
 
-! end of secant iteration
+    wlft1(i)  = pstar1(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
+                  * (pstar1(i) + plft(i))
+    wlft1(i)  = (pstar1(i) - plft(i)) * wlft1(i) / (vlft(i) * scrch1(i))
+    wlft1(i)  = sqrt(abs(wlft1(i)))
 
-! calculate fluid velocity for the "star" state -- this comes from the shock
-! jump equations, Fry Eq. 68 and 69.  The ustar velocity can be computed
-! using either the jump eq. for a left moving or right moving shock -- we use
-! the average of the two.
-! NOTE: Also look at Fry Eqn. 75 and 76.
+    scrch2(i) = pstar1(i) - (gmstrr(i) - 1.e0) * prght(i) /(gmerght(i) - 1.e0)
 
-  do i = 5, numIntCells5
-     scrch3(i) = hy_ulft (i) - (pstar(i) -  hy_plft(i)) /  wlft(i)
-     scrch4(i) = hy_urght(i) + (pstar(i) - hy_prght(i)) / wrght(i)
-     ustar(i)  = 0.5e0 * (scrch3(i) + scrch4(i))
-  enddo
+    if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
+
+    wrght1(i) = pstar1(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
+                  * (pstar1(i) + prght(i))
+    wrght1(i) = (pstar1(i) - prght(i)) * wrght1(i) / (vrght(i) * scrch2(i))
+    wrght1(i) = sqrt(abs(wrght1(i)))
+
+    ! if the pressure jump is small, the wave speed is just the sound speed
+    if (abs (pstar1(i) - plft(i)) < small_dp*(pstar1(i) + plft(i))) wlft1(i) = clft(i)
+    wlft1(i)  = max (wlft1(i),  aux(i) * clft(i))
 
-! account for grid velocity
+    if (abs (pstar1(i) - prght(i)) < small_dp*((pstar1(i) + prght(i)))) wrght1(i) = crght(i)
+    wrght1(i) = max (wrght1(i), aux(i) * crght(i))
 
-  do i = 5, numIntCells5
-     urell(i)   = ustar(i) - ugrdl(i)
-!!$     scrch1(i)  = sign (1.e0, urell(i))
-     scrch1(i)  = sign (0.5, urell(i)) - sign(0.5,-urell(i))     
   enddo
 
-! decide which state is located at the zone iterface based on the values 
-! of the wave speeds.  This is just saying that if ustar > 0, then the state
-! is U_L.  if ustar < 0, then the state on the axis is U_R.
+  ! construct second guess for the pressure using the nonlinear wave speeds
+  ! from the first guess.  This is basically the same thing we did to get
+  ! pstar1, except now we are using the better wave speeds instead of the 
+  ! sound speed.
+  do i = 1, numFluxActv
 
-  do i = 5, numIntCells5
-     
-     scrch2(i) = 0.5e0 * ( 1.e0 + scrch1(i))
-     scrch3(i) = 0.5e0 * ( 1.e0 - scrch1(i))
-     
-     ps(i)    = hy_plft(i)   * scrch2(i) + hy_prght(i)  * scrch3(i)
-     us(i)    = hy_ulft(i)   * scrch2(i) + hy_urght(i)  * scrch3(i)
-     uts(i)   = hy_utlft(i)  * scrch2(i) + hy_utrght(i) * scrch3(i)
-     utts(i)  = hy_uttlft(i) * scrch2(i) + hy_uttrgt(i) * scrch3(i)
-     vs(i)    = hy_vlft(i)   * scrch2(i) + hy_vrght(i)  * scrch3(i) !v for v=1/rho
-     games(i) = hy_gmelft(i) * scrch2(i) + hy_gmergt(i) * scrch3(i)
-     gamcs(i) = hy_gmclft(i) * scrch2(i) + hy_gmcrgt(i) * scrch3(i)
-     
-     rhos(i)  = 1.e0 / vs(i)
-     rhos(i)  = max (hy_smlrho, rhos(i))
-     
-     vs(i)    = 1.e0 / rhos(i)
-     ws(i)    = wlft(i) * scrch2(i) + wrght(i) * scrch3(i)
-     ces(i)   = sqrt (gamcs(i) * ps(i) * vs(i))
-     
-     ! compute rhostar, using the shock jump condition (Fry Eq. 80)
-     
-     vstar(i)  = vs(i) - (pstar(i) - ps(i)) / ws(i) / ws(i)
-     rhostr(i) = 1.e0 / vstar(i)
-     cestar(i) = sqrt (gamcs(i) * pstar(i) * vstar(i))
-     
-! compute some factors, Fry Eq. 81 and 82       
+    ! compute values
+    pstar2(i) = prght(i) - plft(i) - wrght1(i) * (urght(i) - ulft(i))
+    pstar2(i) = plft(i) + pstar2(i) * wlft1(i) / (wlft1(i) + wrght1(i))
+    pstar2(i) = max(hy_smallp, pstar2(i))
 
-     wes(i)    = ces(i)    - scrch1(i) * us(i)
-     westar(i) = cestar(i) - scrch1(i) * ustar(i)
-     
-     scrch4(i) = ws(i) * vs(i) - scrch1(i) * us(i)
-     
-     
-     if (pstar(i) - ps(i) .ge. 0.e0) then
-        wes(i)    = scrch4(i)
-        westar(i) = scrch4(i)
-     endif
-     
-     wes(i)    = wes(i)    + scrch1(i) * ugrdl(i)
-     westar(i) = westar(i) + scrch1(i) * ugrdl(i)
   enddo
 
+  ! begin the secant iteration -- see CG Eq. 17 for details.  We will continue to
+  ! interate for convergence until the error falls below tol (in which case, 
+  ! things are good), or we hit hy_nriem iterations (in which case, Houston, we
+  ! have a problem, and we spit out an error).
+  hy_perror(1:2) = 1.e0
+  do i = 1, numFluxActv
+
+    hy_ptrial(1) = pstar1(i)
+    hy_ptrial(2) = pstar2(i)
+    
+    ! nonlinear solve
+    do n = 1, hy_nriem
+      
+      ! new values for the gamma at the "star" state -- again, using CG Eq. 31
+      gmstrl(i) = gamfac(i) * (pstar2(i) - plft(i))
+      gmstrl(i) = gmelft(i) + 2.e0 * gmstrl(i) / (pstar2(i) + plft(i))
+      
+      gmstrr(i) = gamfac(i) * (pstar2(i) - prght(i))
+      gmstrr(i) = gmerght(i) + 2.e0 * gmstrr(i) / (pstar2(i) + prght(i))
+      
+      gmstrl(i) = max(gmin(i), min(gmax(i), gmstrl(i)))
+      gmstrr(i) = max(gmin(i), min(gmax(i), gmstrr(i)))
+      
+      ! new nonlinear wave speeds, using CG Eq. 34 and the updated gammas
+      scrch1(i) = pstar2(i) - (gmstrl(i) - 1.e0) * plft(i) &
+                    / (gmelft(i) - 1.e0)
+      if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
+      
+      wlft(i)   = pstar2(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
+           & * (pstar2(i) + plft(i))
+      wlft(i)   = (pstar2(i) - plft(i)) * wlft(i) / (vlft(i) * scrch1(i))
+      wlft(i)   = sqrt(abs(wlft(i)))
+
+      scrch2(i) = pstar2(i) - (gmstrr(i) - 1.e0) * prght(i) /(gmerght(i) - 1.e0)
+
+      if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
+      
+      wrght(i)  = pstar2(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
+                    * (pstar2(i) + prght(i))
+      wrght(i)  = (pstar2(i) - prght(i)) * wrght(i) / (vrght(i) * scrch2(i))
+      wrght(i)  = sqrt(abs(wrght(i)))
+      
+      ! if the pressure jump is small, the wave speed is just the sound speed
+      if (abs (pstar2(i) - plft(i)) < small_dp*(pstar2(i) + plft(i))) wlft(i) = clft(i)
+      wlft(i)  = max (wlft(i), aux(i) * clft(i))
+      
+      if (abs (pstar2(i) - prght(i)) < small_dp*(pstar2(i) + prght(i))) wrght(i) = crght(i)
+      wrght(i) = max (wrght(i), aux(i) * crght(i))
+
+      ! compute the velocities in the "star" state -- using CG Eq. 18 -- ustrl2 and
+      ! ustrr2 are the velocities they define there.  ustrl1 and ustrl2 seem to be
+      ! the velocities at the last time, since pstar1 is the old 'star' pressure, and
+      ! wlft1 is the old wave speed.
+      ustrl1 = ulft(i) - (pstar1(i) -  plft(i)) /  wlft1(i)
+      ustrr1 = urght(i) + (pstar1(i) - prght(i)) / wrght1(i)
+      ustrl2 = ulft(i) - (pstar2(i) -  plft(i)) /   wlft(i)
+      ustrr2 = urght(i) + (pstar2(i) - prght(i)) /  wrght(i)
+      
+      delu1     = ustrl1 - ustrr1
+      delu2     = ustrl2 - ustrr2
+      scrch1(i) = delu2  - delu1
+      
+      if (abs(pstar2(i)-pstar1(i)) .le. hy_smallp) scrch1(i) = 0.e0
+      
+      if (abs(scrch1(i)) .lt. hy_smallu) then
+         delu2 = 0.e0
+         scrch1(i) = 1.e0
+      endif
+
+      ! pressure at the "star" state -- using CG Eq. 18
+      pstar(i)  = pstar2(i) - delu2 * (pstar2(i) - pstar1(i)) / scrch1(i)
+      pstar(i)  = max (hy_smallp, pstar(i))
+      
+      ! check for convergence of iteration, hy_riemanTol is a run-time parameter
+      pres_err = abs(pstar(i)-pstar2(i)) / pstar(i)
+      if (pres_err .lt. hy_riemanTol) goto 10
+      
+      ! reset variables for next iteration
+      pstar1(i) = pstar2(i)
+      pstar2(i) = pstar(i)
+
+      hy_ptrial(n+2) = pstar(i)
+      hy_perror(n+2) = pres_err
+      hy_wlft(n+2)   = wlft(i)
+      hy_wrght(n+2)  = wrght(i)
+      
+      wlft1(i)  = wlft(i)
+      wrght1(i) = wrght(i)
+      
+    enddo
+
+    n = n - 1
+
+    ! accept the solution if the error is reasonable...
+    if ( minval(hy_perror) <= hy_riemanTolAbort ) then
+
+      perr_minloc = minloc(hy_perror)
+
+      pstar(i) = hy_ptrial(perr_minloc(1))
+      wlft(i)  = hy_wlft(perr_minloc(1))
+      wrght(i) = hy_wrght(perr_minloc(1))
+
+      write(*,*) 'adopted'
+      write(*,'(i2, es13.5, es10.2)') perr_minloc(1), pstar(i), hy_perror(perr_minloc(1))
+      write(*,*)
+
+    else ! otherwise abort
+
+      write(*,*)
+      write(*,*)             '[RIEMAN] ERROR: Nonconvergence.'
+      call Driver_abortFlash('[RIEMAN] ERROR: Nonconvergence.')
+
+    end if
+     
+    ! land here if the iterations have converged
+    10   continue
+
+  end do
+
+  ! calculate fluid velocity for the "star" state -- this comes from the shock
+  ! jump equations, Fry Eq. 68 and 69.  The ustar velocity can be computed
+  ! using either the jump eq. for a left moving or right moving shock -- we use
+  ! the average of the two.
+  ! NOTE: Also look at Fry Eqn. 75 and 76.
+  do i = 1, numFluxActv
+
+    ! compute values
+    scrch3(i) = ulft(i) - (pstar(i) -  plft(i)) /  wlft(i)
+    scrch4(i) = urght(i) + (pstar(i) - prght(i)) / wrght(i)
+    ustar(i)  = 0.5e0 * (scrch3(i) + scrch4(i))
+
+  enddo
+
+  ! decide which state is located at the zone iterface based on the values 
+  ! of the wave speeds.  This is just saying that if ustar > 0, then the state
+  ! is U_L.  if ustar < 0, then the state on the axis is U_R.
+  do i = 1, numFluxActv
+
+    ! compute values
+    scrch1(i) = sign(1.e0, ustar(i))
+    scrch2(i) = 0.5e0 * ( 1.e0 + scrch1(i))
+    scrch3(i) = 0.5e0 * ( 1.e0 - scrch1(i))
+
+    ps(i)    = plft(i)   * scrch2(i) + prght(i)  * scrch3(i)
+    us(i)    = ulft(i)   * scrch2(i) + urght(i)  * scrch3(i)
+    uts(i)   = utlft(i)  * scrch2(i) + utrght(i) * scrch3(i)
+    utts(i)  = uttlft(i) * scrch2(i) + uttrght(i) * scrch3(i)
+    vs(i)    = vlft(i)   * scrch2(i) + vrght(i)  * scrch3(i)
+    games(i) = gmelft(i) * scrch2(i) + gmerght(i) * scrch3(i)
+    gamcs(i) = gmclft(i) * scrch2(i) + gmcrght(i) * scrch3(i)
+
+    rhos(i)  = 1.e0 / vs(i)
+    rhos(i)  = max (hy_smlrho, rhos(i))
+
+    vs(i)    = 1.e0 / rhos(i)
+    ws(i)    = wlft(i) * scrch2(i) + wrght(i) * scrch3(i)
+    ces(i)   = sqrt (gamcs(i) * ps(i) * vs(i))
+
+    ! compute rhostar, using the shock jump condition (Fry Eq. 80)
+    vstar(i)  = vs(i) - (pstar(i) - ps(i)) / ws(i) / ws(i)
+    rhostr(i) = 1.e0 / vstar(i)
+    cestar(i) = sqrt (gamcs(i) * pstar(i) * vstar(i))
+
+    ! compute some factors, Fry Eq. 81 and 82       
+    wes(i)    = ces(i)    - scrch1(i) * us(i)
+    westar(i) = cestar(i) - scrch1(i) * ustar(i)
+
+    scrch4(i) = ws(i) * vs(i) - scrch1(i) * us(i)
+
+
+    if (pstar(i) - ps(i) .ge. 0.e0) then
+      wes(i)    = scrch4(i)
+      westar(i) = scrch4(i)
+    endif
+
+    wes(i)    = wes(i)
+    westar(i) = westar(i)
 
+  enddo
+  
   ! compute Fry Eq. 86
-  do i = 5, numIntCells5
-     gamfac(i) = (1.e0 - games(i) / gamcs(i)) * (games(i) - 1.e0)
-     gmstar(i) = gamfac(i) * (pstar(i) - ps(i))
-     gmstar(i) = games(i) + 2.e0 * gmstar(i) / (pstar(i) + ps(i))
-     gmstar(i) = max (gmin(i), min (gmax(i), gmstar(i)))
+  do i = 1, numFluxActv
+
+    ! comput values
+    gamfac(i) = (1.e0 - games(i) / gamcs(i)) * (games(i) - 1.e0)
+    gmstar(i) = gamfac(i) * (pstar(i) - ps(i))
+    gmstar(i) = games(i) + 2.e0 * gmstar(i) / (pstar(i) + ps(i))
+    gmstar(i) = max (gmin(i), min (gmax(i), gmstar(i)))
+
   enddo
 
-  do i = 5, numIntCells5
-     eintAv(i) = hy_eiLft(i) * scrch2(i) + hy_eiRght(i) * scrch3(i)
+  do i = 1, numFluxActv
+    eintAv(i) = eilft(i) * scrch2(i) + eirght(i) * scrch3(i)
   enddo
   
   do n = 1, hy_numXn 
-     do i = 5, numIntCells5
-        xnav(i,n) = hy_xnlft(i,n) * scrch2(i) + hy_xnrght(i,n) * scrch3(i)
-     enddo
+    do i = 1, numFluxActv
+      xnav(i,n) = xnlft(i,n) * scrch2(i) + xnrght(i,n) * scrch3(i)
+    enddo
   enddo
   
-! compute correct state for rarefaction fan by linear interpolation
+  ! compute correct state for rarefaction fan by linear interpolation
+  do i = 1, numFluxActv
+
+    scrch1(i) = max (wes(i) - westar(i), wes(i) + westar(i), hy_smallu)
+    scrch1(i) =     (wes(i) + westar(i)) / scrch1(i)
+
+    scrch1(i) = 0.5e0 * (1.e0 + scrch1(i))
+    scrch2(i) =          1.e0 - scrch1(i)
+
+    rhoav(i)  = scrch1(i) * rhostr(i) + scrch2(i) * rhos (i)
+    uav  (i)  = scrch1(i) * ustar(i)  + scrch2(i) * us(i)
+    utav (i)  = uts(i)
+    uttav(i)  = utts(i)
+    pav(i) = scrch1(i) * pstar(i)  + scrch2(i) * ps(i)
+    gameav(i) = scrch1(i) * gmstar(i) + scrch2(i) * games(i)
 
-  do i = 5, numIntCells5
-     scrch1(i) = max (wes(i) - westar(i), wes(i) + westar(i), hy_smallu)
-     scrch1(i) =     (wes(i) + westar(i)) / scrch1(i)
-     
-     scrch1(i) = 0.5e0 * (1.e0 + scrch1(i))
-     scrch2(i) =          1.e0 - scrch1(i)
-     
-     rhoav(i)  = scrch1(i) * rhostr(i) + scrch2(i) * rhos (i)
-     uav  (i)  = scrch1(i) * ustar(i)  + scrch2(i) * us(i)
-     utav (i)  = uts(i)
-     uttav(i)  = utts(i)
-     pav   (i) = scrch1(i) * pstar(i)  + scrch2(i) * ps(i)
-     gameav(i) = scrch1(i) * gmstar(i) + scrch2(i) * games(i)
   enddo
   
-  do i = 5, numIntCells5
-     if (westar(i) .ge. 0.e0) then
-        rhoav(i)  = rhostr(i)
-        uav(i)    = ustar(i)
-        pav(i)    = pstar(i)
-        gameav(i) = gmstar(i)
-     endif
-     
-     if (wes(i) .lt. 0.e0) then
-        rhoav(i)  = rhos(i)
-        uav(i)    = us(i)
-        pav(i)    = ps(i)
-        gameav(i) = games(i)
-     endif
-     
-     urell(i) = uav(i) - ugrdl(i)
-  enddo
+  do i = 1, numFluxActv
 
-  return
-end subroutine rieman
-  
+    if (westar(i) .ge. 0.e0) then
+      rhoav(i)  = rhostr(i)
+      uav(i)    = ustar(i)
+      pav(i)    = pstar(i)
+      gameav(i) = gmstar(i)
+    endif
+
+    if (wes(i) .lt. 0.e0) then
+      rhoav(i)  = rhos(i)
+      uav(i)    = us(i)
+      pav(i)    = ps(i)
+      gameav(i) = games(i)
+    endif
+
+  end do
+
+end subroutine ppm_riemann
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90	2021-02-23 17:22:18.153770420 -0500
@@ -1,53 +1,15 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/states
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states
 !!
 !! NAME
 !! 
-!!  states
+!!  ppm_states
 !!
 !! SYNOPSIS
 !!
-!!  call states(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells,
-!!              integer(IN) :: j,
-!!              integer(IN) :: igeom,
-!!              real(IN)    :: rho(numCells),
-!!              real(IN)    :: u(numCells),
-!!              real(INOUT) :: rhol(numCells),
-!!              real(INOUT) :: rhor(numCells),
-!!              real(INOUT) :: ul(numCells),
-!!              real(INOUT) :: ur(numCells),
-!!              real(INOUT) :: utl(numCells),
-!!              real(INOUT) :: utr(numCells),
-!!              real(INOUT) :: uttl(numCells),
-!!              real(INOUT) :: uttr(numCells),
-!!              real(IN)    :: p(numCells),
-!!              real(INOUT) :: pl(numCells),
-!!              real(INOUT) :: pr(numCells),
-!!              real(IN) ::    gamcl(numCells),
-!!              real(IN) ::    gamcr(numCells),
-!!              real(IN)    :: ugrid(numCells),
-!!              real(IN) ::    ce(numCells),
-!!              real(IN) ::    game(numCells),
-!!              real(IN) ::    gamer(numCells),
-!!              real(IN) ::    gamc(numCells),
-!!              real(IN) ::    gamel(numCells),
-!!              real(IN)    :: eintl(numCells),
-!!              real(IN)    :: eintr(numCells),
-!!              real(IN)    :: xnl(numCells, hy_numXn),
-!!              real(IN)    :: xnr(numCells, hy_numXn),
-!!              real(IN)    :: dtdx(numCells),
-!!              real(IN)    :: dt,
-!!              real(IN)    :: x(numCells),
-!!              real(IN)    :: xl(numCells),
-!!              real(IN)    :: radial_coord(numCells),
-!!              real(IN) ::    grav(numCells),
-!!              real(IN) ::    fict(numCells))
-!!
-!! 
 !! DESCRIPTION
 !!  
-!!  Computes effective left and right states for input to Riemann
-!!  problems in PPM.  Naive guesses for these states based on the
+!!  Computes effective left and right ppm_states for input to Riemann
+!!  problems in PPM.  Naive guesses for these ppm_states based on the
 !!  left and right limits of the cubic interpolants are corrected
 !!  by taking into account information which reaches each cell
 !!  interface via the different characteristics.  This is done by
@@ -57,128 +19,95 @@
 !!
 !! SIDE EFFECTS
 !!
-!!  Modifies the following arrays exported by Hydro_data:
-!!   hy_clft,    hy_crght,
-!!   hy_plft,    hy_prght,
-!!   hy_ulft,    hy_urght,
-!!   hy_vlft,    hy_vrght,
-!!   hy_utlft,   hy_utrght,
-!!   hy_uttlft,  hy_uttrgt,
-!!   hy_gmelft,  hy_gmergt,
-!!   hy_gmclft,  hy_gmcrgt,
-!!   hy_eiLft,   hy_eiRght
-!!
 !! ARGUMENTS
 !!
-!! numIntCells :
-!! numCells :
-!! j :
-!! igeom :
-!! rho :
-!! u :
-!! rhol :
-!! rhor :
-!! ul :
-!! ur :
-!! utl :
-!! utr :
-!! uttl :
-!! uttr :
-!! p :
-!! pl :
-!! pr :
-!! gamcl :
-!! gamcr :
-!! ugrid :
-!! ce :
-!! game :
-!! gamer :
-!! gamc :
-!! gamel :
-!! eintl :
-!! eintr :
-!! xnl :
-!! xnr :
-!! dtdx :
-!! dt :
-!! x :
-!! xl :
-!! radial_coord :
-!! grav :
-!! fict :
+!! DISCLAIMER
 !!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
 !!***
-subroutine states (numIntCells, numCells, &
-                   j, igeom,&
-                   rho, u, rhol, rhor, ul, ur, &
-                   utl, utr, uttl, uttr, p, pl, pr, &
-                   gamcl, gamcr, &
-                   ugrid, ce, game, gamer, gamc, gamel, &
-                   eintl, eintr, &
-                   xnl, xnr, &
-                   dtdx, dt, &
-                   x, xl, radial_coord, grav, fict)
-
 
-
-!=====================================================================
-!     compute left and right states for input to rieman problem
-  use Hydro_data, ONLY : hy_numXn
-  use Hydro_data, ONLY : hy_clft, hy_plft, hy_ulft, hy_utlft, hy_gmelft, hy_gmclft, &
-                         hy_dp, hy_p6, hy_du, hy_u6, hy_drho, hy_rho6, &
-                         hy_gravr, hy_dgrav, hy_grav6, hy_smallp, hy_smlrho, &
-                         hy_vlft, hy_uttlft, hy_xnlft, hy_crght, hy_prght, hy_urght, &
-                         hy_vrght, hy_utrght, hy_uttrgt, hy_gmergt, hy_gmcrgt, &
-                         hy_xnrght, hy_deint, hy_eint6, hy_eiLft, hy_eiRght, &
-                         hy_dut, hy_dutt, hy_utt6, hy_dgame, hy_game6, hy_dgamc, hy_gamc6, &
-                         hy_dxn, hy_xn6, hy_gravl, hy_ut6, &
-                         hy_ppmModifystates, hy_leveque, &
-                         hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic 
+subroutine ppm_states(numCells, numIntCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                          rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                          rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr, &
+                          eintl, eintr, pwl, pwr, gamel, gamer, gamcl, gamcr, &
+                          gravl, gravr, xnl, xnr, drhol, drhor, rho6l, rho6r, &
+                          dul, dur, u6l, u6r, dutl, dutr, ut6l, ut6r, duttl, &
+                          duttr, utt6l, utt6r, dpl, dpr, p6l, p6r, deintl, &
+                          deintr, eint6l, eint6r, dpwl, dpwr, pw6l, pw6r, &
+                          dgamel, dgamer, game6l, game6r, dgamcl, dgamcr, &
+                          gamc6l, gamc6r, dgravl, dgravr, grav6l, grav6r, &
+                          dxnl, dxnr, xn6l, xn6r, clft, crght, &
+                          ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                          prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                          vlft, vrght, xnlft, xnrght, jcell, igeom, ugrid, ce, &
+                          dtdx, dt, x, radial_coord, fict)
+
+  ! inputs from hydro module
+  use Hydro_data, ONLY : hy_ppmModifystates, hy_leveque, hy_numXn, &
+                         hy_cfl_crit, hy_cfl_warning, hy_cfl_max, CW_STATES, &
+                         hy_smallp, hy_smlrho
 
   implicit none
 
+  ! arguments
+  integer, intent(in) :: jcell, igeom, numIntCells, numCells, numFluxActv, &
+                          numIntrfcActv
+  real, intent(in) :: dt
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, &
+                                            gamc, game, grav, eint
+  real, intent(in), dimension(numCells,hy_numXn) :: xn
+  real, intent(in), dimension(numIntrfcActv) :: rhol, rhor, ul, ur, utl, utr, &
+                                                 uttl, uttr, pl, pr, eintl, &
+                                                 eintr, pwl, pwr, gamel, &
+                                                 gamer, gamcl, gamcr, gravl, &
+                                                 gravr
+  real, intent(in), dimension(numIntrfcActv,hy_numXn) :: xnl, xnr
+  real, intent(in), dimension(numFluxActv) :: drhol, drhor, rho6l, rho6r, &
+                                               dul, dur, u6l, u6r, dutl, dutr, &
+                                               ut6l, ut6r, duttl, duttr, utt6l, &
+                                               utt6r, dpl, dpr, p6l, p6r, deintl, &
+                                               deintr, eint6l, eint6r, dgamel, &
+                                               dgamer, game6l, game6r, dgamcl, &
+                                               dgamcr, gamc6l, gamc6r, dgravl, &
+                                               dgravr, grav6l, grav6r, dpwl, dpwr, &
+                                               pw6l, pw6r
+  real, intent(in), dimension(numFluxActv,hy_numXn) :: dxnl, dxnr, xn6l, xn6r
+  real, intent(inout), dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                                  utrght, uttlft, uttrght, plft, &
+                                                  prght, eilft, eirght, gmelft, &
+                                                  gmerght, gmclft, gmcrght, &
+                                                  vlft, vrght
+  real, intent(inout), dimension(numFluxActv, hy_numXn) :: xnlft, xnrght
+  real, intent(in), dimension(numCells) :: ugrid, x, radial_coord
+  real, intent(in), dimension(numCells) :: dtdx, fict, ce
+
+  ! local
+  integer :: j, jlo, jhi, klo, khi
+  real, dimension(numFluxActv) :: pallpl, pallml
+  real, dimension(numFluxActv) :: ppl, pml, p0l
+  real, dimension(numFluxActv) :: upl, uml, u0l
+  real, dimension(numFluxActv) :: ut0l, utt0l
+  real, dimension(numFluxActv) :: rhopl, rhoml, rho0l
+  real, dimension(numFluxActv) :: gravpl, gravml
+  real, dimension(numFluxActv) :: game0l, gamc0l
+  real, dimension(numFluxActv) :: eint0l
+  real, dimension(numFluxActv, hy_numXn) :: xn0l
+  real, dimension(numFluxActv) :: scrch1, scrch2, scrch3, scrch4, cflno
+  real, dimension(numFluxActv) :: cel, cer, urell, urelr
+  real, dimension(numCells) :: dloga, urel ! need this?
 
-!!! ------ARGUMENTS -------------------------
-  integer, intent(IN):: j, igeom, numIntCells, numCells
-  real, intent(IN) :: dt
-  real, intent(IN), dimension(numCells) :: rho, u, p, ugrid, x, xl, &
-       radial_coord
-  real, intent(INOUT), dimension(numCells) :: rhol, rhor, ul, ur
-  real, intent(INOUT), dimension(numCells) :: utl, utr, uttl, uttr, pl, pr
-  real, intent(IN),    dimension(numCells) :: gamcl, gamc, gamcr
-  real, intent(IN),    dimension(numCells) :: ce, game, gamer, gamel
-  real, intent(IN),    dimension(numCells) :: eintl, eintr
-  real, intent(IN),    dimension(numCells) :: dtdx
-  real, intent(IN),    dimension(numCells) :: grav, fict
-  real, intent(INOUT), dimension(numCells, hy_numXn) :: xnl, xnr
-  
-
-
-!!! ---------LOCAL -----------------------------
-  real, dimension(numCells) :: pallpl, pallml
-  real, dimension(numCells) :: ppl, pml, p0l
-  real, dimension(numCells) :: upl, uml, u0l
-  real, dimension(numCells) :: ut0l, utt0l
-  real, dimension(numCells) :: rhopl, rhoml, rho0l
-  real, dimension(numCells) :: gravpl, gravml
-  real, dimension(numCells) :: game0l, gamc0l
-  real, dimension(numCells) :: eint0l
-  
-  real, dimension(numCells, hy_numXn) :: xn0l
-  
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4,&
-                               dloga,cflno,urel
-
-
-
-!!  local
   integer :: numIntCells5, numIntCells6, numIntCells7, numIntCells8
   integer :: i, n
 
   real :: eta
   real :: clft_inv, crght_inv
   real :: qdt, hdt, fdt, slamm, slamp, scrch1_,  scrch2_
+  real :: const_dtdx
 
   real, PARAMETER :: forthd = 4.e00 / 3.e00
     
@@ -192,6 +121,7 @@
   real :: eplus, eminus
   real :: dele, delrho
 
+  real :: cfl_max
 
   numIntCells5 = numIntCells+5
   numIntCells6 = numIntCells+6
@@ -201,174 +131,128 @@
   qdt  = 0.25e0*dt
   hdt  = 0.50e0*dt
 
-!======================================================================
-!  Compute fluid velocities relative to the grid, which may be moving.
+  ! set constant dtdx to random
+  const_dtdx = dtdx(5)
 
-  do i = 1,numIntCells8
-     urel(i)  = u(i) - ugrid(i)
-     cflno(i) = 0.e0
+  !do i = 1,numIntCells8
+  !   urel(i)  = u(i) - ugrid(i)
+  !enddo
+
+  ! convert ce to two arrays
+  do i = 1, numFluxActv
+    j = fluxKey(i)
+    khi = intrfcKey(j)
+    cel(i) = ce(khi-1)
+    cer(i) = ce(khi)
+    urell(i) = u(khi-1)
+    urelr(i) = u(khi)
   enddo
 
-!!
-!!   LeVeque and Bale, 1988    Proc 7th Intl Conf on Hyperbolic Problems 
-!!   but the expressions below are closer to ``Accurate Simulation of
-!!   Rayleigh-Taylor-Instabilities'', Ralf Deiterding, Technical University
-!!   Cottbus.   Some of L&B's expressions aren't dimensionally correct??!
-!!
-  if (hy_leveque) then 
-     do i = 1,numIntCells8
-        capGamma = (game(i)*game(i)-game(i)+2.)/(game(i)-1.)
-        m     = rho(i)*u(i)
-        ei    = p(i)/(game(i)-1.)+(m*m/(2.*rho(i)))
-        if(i<numCells) h = xl(i+1)-xl(i)
-        
-        delrho = grav(i)*h/((game(i)-1.)*(m/rho(i)*m/rho(i)*capGamma - &
-             &      2.*game(i)*ei/rho(i)))
-        dele   = -rho(i)*grav(i)*h/(2.*ei*(game(i)-1))* &
-             &              ( 1. - m*m*(3.-game(i))/   &
-             & ((game(i)-1.)*(capGamma*m*m-2.*ei*game(i)*rho(i))))
-        
-        eplus  = ei*(1. + dele)
-        eminus = ei*(1. - dele)
-        
-        rplus  = rho(i)*(1. + delrho)
-        rminus = rho(i)*(1. - delrho)
-        rdelta = rho(i)*delrho
-        
-        pplus  = (game(i)-1.)*(eplus  - m*m/(2.*rplus))
-        pminus = (game(i)-1.)*(eminus - m*m/(2.*rminus))
-        pdelta = (pplus-pminus)/2.
-        
-        uplus  = m/rplus
-        uminus = m/rminus
-        udelta = (uplus-uminus)/2.
-        
-        pl(i) = pl(i) + pdelta
-        pr(i) = pr(i) - pdelta
-        
-        rhol(i) = rhol(i) + rdelta
-        rhor(i) = rhor(i) - rdelta
-        
-        ul(i) = ul(i) + udelta
-        ur(i) = ur(i) - udelta
-     enddo
-  endif
-
-! 1. FOR LEFT STATES : FRYXELL SECTION 3.1.5, EQNS 58 - 59
-!----------------------------------------------------------------------
-!       Compute averages for the left side of each interface.
-
-!       scrch#() here are domain factors used to compute the interpolant
-!       averages.  See Colella & Woodward (1984), eq. 1.12.
-
-!       Compute averages over the domain of dependence of the u+c characteri-
-!       stic, if it reaches the left sides of the interfaces.
-
-!
-!       the pressure is calculated twice.  One will only contain
-!       the `wave generating' pressure -- pressure in excess of 
-!       hydrostatic -- if ppm_modifystates is .true.   The other
-!       contains the full pressure; this is needed for the sound speed.
-!
-!       p{l,r},hy_dp,hy_p6 are the coefficients for the reconstruction of
-!                    the total pressure;
-!       pw{l,r},hy_dpw,pw6{l,r},hy_pwcubic are the coefficients for the 
-!                    reconstruction of the wave-generating pressure.
-!
-
-  ! 1-(a): u+c characteristic
-  do i = 5, numIntCells5
-     scrch1(i) = dtdx(i-1) * (urel(i-1) + ce(i-1)) ! eqn 59
-     cflno(i)  = max (0.e00, scrch1(i))            ! eqn 59
-     scrch1(i) = 0.5e00 * min (1.e00, cflno(i))    ! eqn 59: 1/2*beta
-     scrch2(i) = 1.e00 - forthd * scrch1(i)        ! eqn 58: 1-2/3*beta
-
-     ! now solve eqn 58
-     ppl(i)   = hy_pwr(i-1) - &
-          & scrch1(i) * (hy_dpw(i-1)   - scrch2(i) * hy_pw6l(i-1))    &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-     
-     pallpl(i)   = pr(i-1) - &
-          & scrch1(i) * (hy_dp(i-1)   - scrch2(i) * hy_p6(i-1))   
-     
-     upl(i)   = ur(i-1) - &
-          & scrch1(i) * (hy_du(i-1)   - scrch2(i) * hy_u6(i-1))
-
-     rhopl(i) = rhor(i-1) - &
-          & scrch1(i) * (hy_drho(i-1) - scrch2(i) * hy_rho6(i-1))
-     
-     gravpl(i) = hy_gravr(i-1) - &
-          & scrch1(i) * (hy_dgrav(i-1) - scrch2(i) * hy_grav6(i-1))
-     
-     rhopl(i)    = max (hy_smlrho, rhopl(i))
-     pallpl(i)   = max (hy_smallp, pallpl(i))
+  ! compute fluid velocities relative to the grid, which may be moving
+  !********* in this adaptive version we are not doing moving grids *******
+  cflno(:) = 0.0
+
+  !------- left states -------!
+
+  ! compute max cfl (replacing urel with u)
+  !cfl_max = maxval( const_dtdx * (abs(u(4:numIntCells5)) + abs(ce(4:numIntCells5))) )
+  !hy_cfl_max(CW_STATES) = max(cfl_max, hy_cfl_max(CW_STATES))
+  !if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_STATES) = .true.
+  cfl_max = maxval( const_dtdx * (abs(urell) + abs(cel)) )
+  cfl_max = maxval( const_dtdx * (abs(urelr) + abs(cer)) )
+  hy_cfl_max(CW_STATES) = max(cfl_max, hy_cfl_max(CW_STATES))
+  if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_STATES) = .true.
+
+  ! u+c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch variables
+    scrch1(i) = const_dtdx * (urell(i) + cel(i)) ! eqn 59
+    cflno(i)  = max (0.e00, scrch1(i))            ! eqn 59
+    scrch1(i) = 0.5e00 * min (1.e00, cflno(i))    ! eqn 59: 1/2*beta
+    scrch2(i) = 1.e00 - forthd * scrch1(i)        ! eqn 58: 1-2/3*beta
+
+    ! now solve eqn 58
+    ppl(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    pallpl(i) = pl(j) - scrch1(i) * (dpl(i) - scrch2(i) * p6l(i))
+    upl(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    rhopl(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    gravpl(i) = gravl(j) - scrch1(i) * (dgravl(i) - scrch2(i) * grav6l(i))
+    rhopl(i) = max(hy_smlrho, rhopl(i))
+    pallpl(i) = max(hy_smallp, pallpl(i))
+
   end do
   
-!       Compute averages over the domain of dependence of the u-c characteri-
-!       stic, if it reaches the left sides of the interfaces.
+  ! u-c characteristic
+  do i = 1, numFluxActv 
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch vars
+    scrch3(i) = const_dtdx * (urell(i) - cel(i))            ! eqn 59
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i))) ! eqn 59: 1/2*beta
+    scrch2(i) = 1.e00 - forthd * scrch1(i)                   ! eqn 58: 1-2/3*beta
+
+    ! eq. 58
+    pml(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    uml(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    rhoml(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    gravml(i) = gravl(j) - scrch1(i) * (dgravl(i) - scrch2(i) * grav6l(i))
 
-  ! 1-(b): u-c characteristic
-  do i = 5, numIntCells5
-     scrch3(i) = dtdx(i-1) * (urel(i-1) - ce(i-1))            ! eqn 59
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i))) ! eqn 59: 1/2*beta
-     scrch2(i) = 1.e00 - forthd * scrch1(i)                   ! eqn 58: 1-2/3*beta
-     
-     pml(i)   = hy_pwr(i-1) - &
-          & scrch1(i) * (hy_dpw(i-1)   - scrch2(i) * hy_pw6l(i-1))    &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-
-     uml(i)   = ur(i-1) - &
-          & scrch1(i) * (hy_du(i-1)   - scrch2(i) * hy_u6(i-1))
-
-     rhoml(i) = rhor(i-1) - &
-          & scrch1(i) * (hy_drho(i-1) - scrch2(i) * hy_rho6(i-1))
-     
-     gravml(i) = hy_gravr(i-1) - &
-          & scrch1(i) * (hy_dgrav(i-1) - scrch2(i) * hy_grav6(i-1))
   end do
 
   ! 1-(c): u characteristic
-  do i = 5, numIntCells5
-     scrch4(i) = dtdx(i-1) * urel(i-1)
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     p0l(i)    = hy_pwr(i-1) &
-          & - scrch1(i) * (hy_dpw(i-1)    - scrch2(i) * hy_pw6l(i-1)) &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-     
-     rho0l(i)  = rhor(i-1) &
-          & - scrch1(i) * (hy_drho(i-1)  - scrch2(i) * hy_rho6(i-1))
-     u0l(i)    = ur (i-1) &
-          & - scrch1(i) * (hy_du(i-1)    - scrch2(i) * hy_u6(i-1))
-     ut0l(i)   = utr(i-1) &
-          & - scrch1(i) * (hy_dut(i-1)   - scrch2(i) * hy_ut6(i-1))
-     utt0l(i)  = uttr(i-1) &
-          & - scrch1(i) * (hy_dutt(i-1)  - scrch2(i) * hy_utt6(i-1))
-     game0l(i) = gamer(i-1) &
-          &- scrch1(i) * (hy_dgame(i-1) - scrch2(i) * hy_game6(i-1))
-     gamc0l(i) = gamcr(i-1) &
-          &- scrch1(i) * (hy_dgamc(i-1) - scrch2(i) * hy_gamc6(i-1))
-  end do
-
-  do i = 5, numIntCells5
-     eint0l(i) = eintr(i-1) &
-          & - scrch1(i) * (hy_deint(i-1) - scrch2(i) * hy_eint6(i-1))
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch vars
+    scrch4(i) = const_dtdx * urell(i)
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    ! eq. 58
+    p0l(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    rho0l(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    u0l(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    ut0l(i) = utl(j) - scrch1(i) * (dutl(i) - scrch2(i) * ut6l(i))
+    utt0l(i) = uttl(j) - scrch1(i) * (duttl(i) - scrch2(i) * utt6l(i))
+    game0l(i) = gamel(j) - scrch1(i) * (dgamel(i) - scrch2(i) * game6l(i))
+    gamc0l(i) = gamcl(j) - scrch1(i) * (dgamcl(i) - scrch2(i) * gamc6l(i))
+
+  end do
+
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! internal energy
+    eint0l(i) = eintl(j) - scrch1(i) * (deintl(i) - scrch2(i) * eint6l(i))
+
   end do
   
+  ! loop over species
   do n = 1, hy_numXn 
-     do i = 5, numIntCells5
-        xn0l(i,n) = xnr(i-1,n) &
-             & - scrch1(i) * (hy_dxn(i-1,n) - scrch2(i) * hy_xn6(i-1,n))
-     end do
-  end do
+
+    do i = 1, numFluxActv
+      j = fluxKey(i)
+      xn0l(i,n) = xnl(j,n) - scrch1(i) * (dxnl(i,n) - scrch2(i) * xn6l(i,n))
+    enddo
+
+  enddo
 
 ! 2. FOR LEFT STATES : FRYXELL SECTION 3.1.5, EQNS 62 - 67
 !-------------------------------------------------------------------------------
 !       Now compute the modified states for the left sides of cell interfaces,
 !       excluding the effects of source terms and geometry, which are taken
 !       into account later.  The computation of the Lagrangian sound speed
-!       (hy_clft) takes into account a bug correction relayed by E. Muller (was
+!       (clft) takes into account a bug correction relayed by E. Muller (was
 !       using gamc(i), should use gamc(i-1)).
 
 !       scrch1() and scrch2() here are, respectively, C*(beta+ +/- beta-) and
@@ -377,284 +261,305 @@
 !       domain of dependence to the size of the zone) for the u-c and u charac-
 !       teristics, respectively.
 
-  do i = 5, numIntCells5
-     hy_clft(i)  = sqrt (gamc(i-1) * pallpl(i) * rhopl(i))       ! (rho*c)
-     clft_inv = 1.e0 / hy_clft(i)                                ! 1./(rho*c)
-     
-     scrch1_   = 0.5e00 * (upl(i) - uml(i) - (ppl(i) - pml(i)) & ! C*beta^{-}_l -- a part of eqn Fry 62
-          * clft_inv)                                            ! NOTE: beta^{+}_l = 0.
-     
-     scrch2_   = (ppl(i) - p0l(i)) * clft_inv * clft_inv &       ! eqn Fry 63
-          + 1.e00/rhopl(i)
-     
-     scrch2_   = scrch2_ - 1.e00 / rho0l(i)                      ! beta^{0}, eqn Fry 63
-     
-     if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
-     if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
-     
-     hy_plft(i)   = ppl(i) + hy_clft(i) * scrch1_
-     hy_plft(i)   = max (hy_plft(i), hy_smallp)
-     
-     hy_ulft(i)   = upl(i) - scrch1_ + hdt*fict(i-1)
-     
-     hy_vlft(i)   = 1.e00 / rhopl(i) - scrch2_ - scrch1_ * clft_inv !v=1/rho
-     hy_vlft(i)   = min (hy_vlft(i), 1.e0/hy_smlrho)
-     
-     hy_utlft(i)  = ut0l(i)
-     hy_uttlft(i) = utt0l(i)
-     hy_gmelft(i) = game0l(i)
-     hy_gmclft(i) = gamc0l(i)
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(j) - 1
+
+    ! compute
+    clft(i) = sqrt(gamc(klo) * pallpl(i) * rhopl(i))       ! (rho*c)
+    clft_inv = 1.e0 / clft(i)                                ! 1./(rho*c)
+    scrch1_ = 0.5e00 * (upl(i) - uml(i) - (ppl(i) - pml(i)) & ! C*beta^{-}_l -- a part of eqn Fry 62
+                * clft_inv)                                            ! NOTE: beta^{+}_l = 0.
+    scrch2_ = (ppl(i) - p0l(i)) * clft_inv * clft_inv &       ! eqn Fry 63
+              + 1.e00/rhopl(i)
+    scrch2_ = scrch2_ - 1.e00 / rho0l(i)                      ! beta^{0}, eqn Fry 63
+
+    if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
+    if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
+
+    plft(i)   = ppl(i) + clft(i) * scrch1_
+    plft(i)   = max(plft(i), hy_smallp)
+
+    ulft(i)   = upl(i) - scrch1_ + hdt*fict(klo)
+
+    vlft(i)   = 1.e00 / rhopl(i) - scrch2_ - scrch1_ * clft_inv !v=1/rho
+    vlft(i)   = min(vlft(i), 1.e0/hy_smlrho)
+
+    utlft(i)  = ut0l(i)
+    uttlft(i) = utt0l(i)
+    gmelft(i) = game0l(i)
+    gmclft(i) = gamc0l(i)
+
   end do
-  do i = 5, numIntCells5
-     hy_eiLft(i) = eint0l(i)
+
+  do i = 1, numFluxActv
+    eilft(i) = eint0l(i)
   end do
+
+  ! loop over species
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        hy_xnlft(i,n) = xn0l(i,n)
-     end do
+    do i = 1, numFluxActv
+      xnlft(i,n) = xn0l(i,n)
+    end do
   end do
+
+  ! now correct the left states to include geometry terms
+  !if (igeom .eq. 0)   then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = 0.e00
+  !   end do
+  !else if (igeom .le. 2) then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = igeom / x(i)
+  !   end do
+  !else if (igeom .eq. 3  .or. igeom .eq. 5) then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = 0.e00
+  !   end do
+  !else
+  !   do i = 1, numIntCells8
+  !      dloga(i) = cos(x(i))/(sin(x(i)) * radial_coord(jcell))
+  !   enddo
+  !   
+  !end if
+ 
+  !if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
+  !   do i = 1, numIntCells8
+  !      scrch1_  = (abs (u(i) - ugrid(i)) + ce(i)) * const_dtdx
+  !      if ( dt < TINY(1.e0) ) then
+  !         eta = 1.e0
+  !      else
+  !         eta = (1.e00 - scrch1_) / (ce(i) * dt * abs (dloga(i)))
+  !      end if
+  !      eta      = min (eta, 1.e00)
+  !      dloga(i) = eta * dloga(i)
+  !   end do
+  !endif
   
-!       Now correct the left states to include geometry terms.
-  
-  
-  if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
-     if (igeom .eq. 1)   then
-        do i = 4, numIntCells5
-           dloga(i) = 1.0 / x(i)
-        end do
-     else if (igeom .eq. 2) then
-        do i = 4, numIntCells5
-           dloga(i) = 2.0 / x(i)
-        end do
-     else
-        do i = 4, numIntCells5
-           dloga(i) = cos(x(i))/(sin(x(i)) * radial_coord(j))
-        enddo
-     end if
-     do i = 4, numIntCells5
-        scrch1_  = (abs (u(i) - ugrid(i)) + ce(i)) * dtdx(i)
-        eta      = (1.e00 - scrch1_) / (ce(i) * dt * abs (dloga(i)))
-        eta      = min (eta, 1.e00)
-        dloga(i) = eta * dloga(i)
-     end do
-  
-     do i = 5, numIntCells5
-        scrch1_   = 0.5e00 * rho(i-1) * u(i-1) * dt * dloga(i-1)
-        hy_vlft(i)   = 1.e00 / hy_vlft(i) - scrch1_
-        hy_vlft(i)   = 1.e00 / hy_vlft(i)
-        hy_plft(i)   = hy_plft(i) - scrch1_ * ce(i-1)**2
-        hy_plft(i)   = max (hy_plft(i), hy_smallp)
-        hy_vlft(i)   = min (hy_vlft(i), 1.e0/hy_smlrho)
-     end do
-  end if
-  
-  if (.not. (hy_ppmModifystates .or. hy_leveque)) then
-     
-     do i = 5, numIntCells5
-        slamm = urel(i-1) - ce(i-1)
-        slamp = urel(i-1) + ce(i-1)
-        
-        if ( slamm.le.0.e0 ) gravml(i) = 0.e0
-        if ( slamp.le.0.e0 ) gravpl(i) = 0.e0
-        
-        if ( slamm.gt.0.e0 .and. slamp.gt.0.e0 ) then
-           fdt = qdt
-        else
-           fdt = hdt
-        end if
-        
-        hy_ulft(i) = hy_ulft(i) + fdt*(gravpl(i)+gravml(i))
-     end do
-     
-  end if
+  do i = 1, numFluxActv
 
-! 3. FOR RIGHT STATES : FRYXELL SECTION 3.1.5, EQNS 60 - 61
-!-------------------------------------------------------------------------------
-!       Compute averages for the right side of each interface.
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(j) - 1
+
+    scrch1_   = 0.0e0 ! 0.5e00 * rho(klo) * u(klo) * dt * dloga(klo)
+    vlft(i)   = 1.e00 / vlft(i) - scrch1_
+    vlft(i)   = 1.e00 / vlft(i)
+    plft(i)   = plft(i) - scrch1_ * cel(i)**2
+    plft(i)   = max (plft(i), hy_smallp)
+    vlft(i)   = min (vlft(i), 1.e0/hy_smlrho)
+
+  end do
+
+  ! done need this if not using gravity?? *******************
+  !if (.not. (hy_ppmModifystates.or.hy_leveque)) then
+
+  !  do i = 1, numFluxActv
 
-!       scrch#() here are geometry factors used to compute the interpolant
-!       averages.  See Colella & Woodward (1984), eq. 1.12.
+  !    ! compute interface mapping
+  !    j = fluxKey(i)
+  !    jlo = fluxKey(i) - 1
 
-!       Compute averages over the domain of dependence of the u+c characteri-
-!       stic, if it reaches the right sides of the interfaces.
+  !    ! compute cell indices left and right of target interface
+  !    klo = intrfcKey(jlo)
+  !    khi = intrfcKey(j)
+
+  !    slamm = urel(klo) - ce(klo)
+  !    slamp = urel(klo) + ce(klo)
+
+  !    if ( slamm.le.0.e0 ) gravml(i) = 0.e0
+  !    if ( slamp.le.0.e0 ) gravpl(i) = 0.e0
+
+  !    if ( slamm.gt.0.e0 .and. slamp.gt.0.e0 ) then
+  !      fdt = qdt
+  !    else
+  !      fdt = hdt
+  !    end if
+
+  !    ulft(khi) = ulft(khi) + fdt*(gravpl(i)+gravml(i))
+
+  !  end do
+
+  !end if
+
+  !------- right states -------!
+
+  ! u+c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute
+    scrch3(i) = -const_dtdx * (urelr(i) + cer(i))
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i)))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    ppl(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    upl(i) = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    rhopl(i) = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    gravpl(i) = gravr(j) + scrch1(i) * (dgravr(i) + scrch2(i) * grav6r(i))
+
+  end do
+
+  ! u-c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute
+    scrch1(i) = -const_dtdx * (urelr(i) - cer(i))
+    scrch1(i) = max(0.e00, scrch1(i))
+    cflno(i)  = max(cflno(i), scrch1(i))
+    scrch1(i) = 0.5e00 * min(1.e00, scrch1(i))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    pml(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    pallml(i) = pr(j) + scrch1(i) * (dpr(i) + scrch2(i) * p6r(i))
+    uml(i) = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    rhoml(i) = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    gravml(i) = gravr(j) + scrch1(i) * (dgravr(i) + scrch2(i) * grav6r(i))
+
+    pallml(i) = max(pallml(i), hy_smallp)
+    rhoml(i)  = max(rhoml(i), hy_smlrho)
+
+  end do
+
+  ! u characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    scrch4(i) = -const_dtdx * urelr(i)
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
+    scrch2(i) = 1.0e00 - forthd * scrch1(i)
+
+    p0l(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    rho0l(i)  = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    u0l(i)    = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    ut0l(i)   = utr(j) + scrch1(i) * (dutr(i) + scrch2(i) * ut6r(i))
+    utt0l(i)  = uttr(j) + scrch1(i) * (duttr(i) + scrch2(i) * utt6r(i))
+    game0l(i) = gamer(j) + scrch1(i) * (dgamer(i) + scrch2(i) * game6r(i))
+    gamc0l(i) = gamcr(j) + scrch1(i) * (dgamcr(i) + scrch2(i) * gamc6r(i))       
 
-!
-!       the pressure is calculated twice.  One will only contain
-!       the `wave generating' pressure -- pressure in excess of 
-!       hydrostatic -- if ppm_modifystates is .true.   The other
-!       contains the full pressure; this is needed for the sound speed.
-!
-!       p{l,r},hy_dp,hy_p6 are the coefficients for the reconstruction of
-!                    the total pressure;
-!       p{l,r},hy_dpw,pw6{l,r},hy_pwcubic are the coefficients for the 
-!                    reconstruction of the wave-generating pressure.
-!
-
-  ! 3-(a): u+c characteristic
-  do i= 5, numIntCells5
-     scrch3(i) = -dtdx(i) * (urel(i) + ce(i))
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i)))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     ppl(i)   = hy_pwl(i)   + scrch1(i) * (hy_dpw(i)   + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     upl(i)   = ul(i)   + scrch1(i) * (hy_du(i)   + scrch2(i) * hy_u6(i))
-     rhopl(i) = rhol(i) + scrch1(i) * (hy_drho(i) + scrch2(i) * hy_rho6(i))
-     
-     gravpl(i) = hy_gravl(i) +  &
-          & scrch1(i) * (hy_dgrav(i) + scrch2(i) * hy_grav6(i))
-  end do
-
-!       Compute averages over the domain of dependence of the u-c characteri-
-!       stic, if it reaches the right sides of the interfaces.
-  ! 3-(b): u-c characteristic
-  do i = 5, numIntCells5
-     scrch1(i) = -dtdx(i) * (urel(i) - ce(i))
-     scrch1(i) = max (0.e00, scrch1(i))
-     cflno(i)  = max (cflno(i), scrch1(i))
-     scrch1(i) = 0.5e00 * min (1.e00, scrch1(i))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     pml(i)   = hy_pwl(i)   + scrch1(i) * (hy_dpw(i)   + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     pallml(i)   = pl(i)   + scrch1(i) * (hy_dp(i)   + scrch2(i) * hy_p6(i))
-     
-     uml(i)   = ul(i)   + scrch1(i) * (hy_du(i)   + scrch2(i) * hy_u6(i))
-     rhoml(i) = rhol(i) + scrch1(i) * (hy_drho(i) + scrch2(i) * hy_rho6(i))
-     
-     gravml(i) = hy_gravl(i) + &
-          & scrch1(i) * (hy_dgrav(i) + scrch2(i) * hy_grav6(i))
-     
-     pallml(i) = max (pallml(i), hy_smallp)
-     rhoml(i)  = max (rhoml(i), hy_smlrho)
-  end do
-
-  ! 3-(c): u characteristic
-  do i = 5, numIntCells5
-     scrch4(i) = -dtdx(i) * urel(i)
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
-     scrch2(i) = 1.0e00 - forthd * scrch1(i)
-     
-     p0l(i)    = hy_pwl(i)   &
-          &        + scrch1(i) * (hy_dpw(i)    + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     rho0l(i)  = rhol(i) &
-          &        + scrch1(i) * (hy_drho(i)  + scrch2(i) * hy_rho6(i))
-     u0l(i)    = ul(i)   &
-          &        + scrch1(i) * (hy_du(i)    + scrch2(i) * hy_u6(i))
-     ut0l(i)   = utl(i)  &
-          &        + scrch1(i) * (hy_dut(i)   + scrch2(i) * hy_ut6(i))
-     utt0l(i)  = uttl(i) &
-          &        + scrch1(i) * (hy_dutt(i)  + scrch2(i) * hy_utt6(i))
-     game0l(i) = gamel(i) &
-          &        + scrch1(i) * (hy_dgame(i) + scrch2(i) * hy_game6(i))
-     gamc0l(i) = gamcl(i) &
-          &        + scrch1(i) * (hy_dgamc(i) + scrch2(i) * hy_gamc6(i))       
   end do
   
-  do i = 5, numIntCells5
-     eint0l(i) = eintl(i) &
-          &        + scrch1(i) * (hy_deint(i) + scrch2(i) * hy_eint6(i))
+  do i = 1, numFluxActv
+    j = fluxKey(i)
+    eint0l(i) = eintr(j) + scrch1(i) * (deintr(i) + scrch2(i) * eint6r(i))
   end do
 
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        xn0l(i,n) = xnl(i,n) &
-             &        + scrch1(i) * (hy_dxn(i,n) + scrch2(i) * hy_xn6(i,n))
-     end do
+
+    do i = 1, numFluxActv
+      j = fluxKey(i)
+      xn0l(i,n) = xnr(j,n) + scrch1(i) * (dxnr(i,n) + scrch2(i) * xn6r(i,n))
+    end do
+
   end do
   
-! 4. FOR RIGHT STATES : FRYXELL SECTION 3.1.5, EQNS 62 - 67
-!-------------------------------------------------------------------------------
-!       Now compute the modified states for the right sides of cell interfaces,
-!       excluding the effects of source terms and geometry, which are taken
-!       into account later.
+  !------- modifed states for right side -------!
 
-!       scrch1() and scrch2() here are, respectively, C*(beta+ +/- beta-) and
-!       beta0.  See Colella & Woodward (1984), eq. 3.6 and 3.7.  The arrays
-!       scrch3() and scrch4() are domain factors (the ratio of the size of the
-!       domain of dependence to the size of the zone) for the u+c and u charac-
-!       teristics, respectively.
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    khi = intrfcKey(j)
+
+    crght(i)  = sqrt(gamc(khi) * pallml(i) * rhoml(i))           ! (rho*c)
+    crght_inv = 1.e0 / crght(i)                                 ! 1./(rho*c)
+
+    scrch1_   = -0.5e00 * (uml(i) - upl(i) + (pml(i) - ppl(i))  &  ! C*beta^{+}_r -- a part of eqn Fry 62
+                  * crght_inv)                                              ! NOTE: beta^{-1}_r = 0.
+
+    scrch2_   = (pml(i) - p0l(i)) * crght_inv * crght_inv  &       ! eqn Fry 63
+        + 1.e00 / rhoml(i)
+
+    scrch2_   = scrch2_ - 1.e00 / rho0l(i)                         ! beta^{0}_r, eqn Fry 63
+
+    if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
+    if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
 
-  do i = 5, numIntCells5
-     hy_crght(i)  = sqrt (gamc(i) * pallml(i) * rhoml(i))           ! (rho*c)
-     crght_inv = 1.e0 / hy_crght(i)                                 ! 1./(rho*c)
-     
-     scrch1_   = -0.5e00 * (uml(i) - upl(i) + (pml(i) - ppl(i))  &  ! C*beta^{+}_r -- a part of eqn Fry 62
-          * crght_inv)                                              ! NOTE: beta^{-1}_r = 0.
-     
-     scrch2_   = (pml(i) - p0l(i)) * crght_inv * crght_inv  &       ! eqn Fry 63
-          + 1.e00 / rhoml(i)
-     
-     scrch2_   = scrch2_ - 1.e00 / rho0l(i)                         ! beta^{0}_r, eqn Fry 63
-     
-     if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
-     if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
-     
-     hy_prght(i)  = pml(i) + hy_crght(i) * scrch1_                  ! eqn Fry 65
-     hy_prght(i)  = max (hy_prght(i), hy_smallp)
-
-     hy_urght(i)  = uml(i) + scrch1_ + hdt*fict(i)                  ! eqn Fry 66
-     
-     hy_vrght(i)  = 1.e00 / rhoml(i) - scrch2_ - scrch1_ *crght_inv ! v=1/rho
-     hy_vrght(i)  = min (hy_vrght(i), 1.e0/hy_smlrho)
-     
-     hy_utrght(i) = ut0l(i)
-     hy_uttrgt(i) = utt0l(i)
-     hy_gmergt(i) = game0l(i)
-     hy_gmcrgt(i) = gamc0l(i)
+    prght(i)  = pml(i) + crght(i) * scrch1_                  ! eqn Fry 65
+    prght(i)  = max(prght(i), hy_smallp)
+    urght(i)  = uml(i) + scrch1_ + hdt*fict(khi)                  ! eqn Fry 66
+    vrght(i)  = 1.e00 / rhoml(i) - scrch2_ - scrch1_ *crght_inv ! v=1/rho
+    vrght(i)  = min (vrght(i), 1.e0/hy_smlrho)
+    utrght(i) = ut0l(i)
+    uttrght(i) = utt0l(i)
+    gmerght(i) = game0l(i)
+    gmcrght(i) = gamc0l(i)
 
   end do
 
-  do i = 5, numIntCells5
-     hy_eiRght(i) = eint0l(i)
+  do i = 1, numFluxActv
+    eirght(i) = eint0l(i)
   end do
 
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        hy_xnrght(i,n) = xn0l(i,n)
-     end do
+    do i = 1, numFluxActv
+      xnrght(i,n) = xn0l(i,n)
+    end do
   end do
   
-  !       Now correct the right states to include geometry terms.
+  ! Now correct the right states to include geometry terms.
+  do i = 1, numFluxActv
 
+    ! compute interface mapping
+    j = fluxKey(i)
 
-  if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
-     do i = 5, numIntCells5
-        scrch1_   = 0.5e00 * rho(i) * u(i) * dt * dloga(i)
-        hy_vrght(i)  = 1.e00 / hy_vrght(i) - scrch1_
-        hy_vrght(i)  = 1.e00 / hy_vrght(i)
-        hy_prght(i)  = hy_prght(i) - scrch1_ * ce(i)**2
-        hy_prght(i)  = max (hy_prght(i), hy_smallp)
-        hy_vrght(i)  = min (hy_vrght(i), 1.e0/hy_smlrho)
-     end do
-  end if
-
-  if (.not. (hy_ppmModifystates .or. hy_leveque)) then
-     
-     do i = 5, numIntCells5
-        slamm = urel(i) - ce(i)
-        slamp = urel(i) + ce(i)
-        
-        if ( slamm.ge.0.e0 ) gravml(i) = 0.e0
-        if ( slamp.ge.0.e0 ) gravpl(i) = 0.e0
-        
-        if ( slamm.lt.0.e0 .and. slamp.lt.0.e0 ) then
-           fdt = qdt
-        else
-           fdt = hdt
-        end if
-        
-        hy_urght(i) = hy_urght(i) + fdt*(gravpl(i)+gravml(i))
-     end do
-     
-  end if
+    ! compute cell indices left and right of target interface
+    khi = intrfcKey(j)
+
+    scrch1_   = 0.0 !0.5e00 * rho(khi) * u(khi) * dt * dloga(khi)
+    vrght(i)  = 1.e00 / vrght(i) - scrch1_
+    vrght(i)  = 1.e00 / vrght(i)
+    prght(i)  = prght(i) - scrch1_ * cer(i)**2
+    prght(i)  = max(prght(i), hy_smallp)
+    vrght(i)  = min(vrght(i), 1.e0/hy_smlrho)
+
+  end do
+ 
+  !if (.not. (hy_ppmModifystates .or. hy_leveque)) then
+
+  !  do i = 1, numFluxActv
+
+  !    ! compute interface mapping
+  !    j = fluxKey(i)
+  !    jlo = fluxKey(i) - 1
+
+  !    ! compute cell indices left and right of target interface
+  !    klo = intrfcKey(jlo)
+  !    khi = intrfcKey(j)
+
+  !    slamm = urel(khi) - ce(khi)
+  !    slamp = urel(khi) + ce(khi)
+
+  !    if ( slamm.ge.0.e0 ) gravml(i) = 0.e0
+  !    if ( slamp.ge.0.e0 ) gravpl(i) = 0.e0
+
+  !    if ( slamm.lt.0.e0 .and. slamp.lt.0.e0 ) then
+  !    fdt = qdt
+  !    else
+  !    fdt = hdt
+  !    end if
+
+  !    urght(khi) = urght(khi) + fdt*(gravpl(i)+gravml(i))
+
+  !  end do
+
+  !end if
 
-  if(xl(5) .ne. 0.e00) return
-  
   return
-end subroutine states
 
+end subroutine ppm_states
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90	2021-02-23 18:16:43.505797991 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90	2021-02-23 17:59:55.612514435 -0500
@@ -1,4 +1,5 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_hlle
+#define DEBUG_HLLE 0
+!!****if* source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle
 !!
 !! NAME
 !!
@@ -106,8 +107,12 @@
 !! e_flux: 
 !! ei_flux:
 !!
+!! DISCLAIMER
+!!
+!!  "This product includes software developed by and/or derived from the Flash
+!!  Center for Computational Science (http://flash.uchicago.edu) to which the U.S.
+!!  Government retains certain rights." 
 !!
-!!  
 !!***
 
 subroutine riemann_hlle(rho_left,  rho_right, &
@@ -121,7 +126,8 @@
                         gamc_left, gamc_right, &
                         grav_left, grav_right, &
                         dt, &
-                        rho_flux, u_flux, ut_flux, utt_flux, e_flux, ei_flux)
+                        rho_flux, u_flux, ut_flux, utt_flux, &
+                        e_flux, ei_flux)
 
   use Hydro_data, ONLY : hy_small
 
@@ -363,6 +369,9 @@
           bp*bm*(rho_right*ei_right - rho_left*ei_left))*bdifi
 
   end if
+#if DEBUG_HLLE > 0
+
+  write(*,*) 'fluxes', rho_flux, u_flux, ut_flux, utt_flux, e_flux, ei_flux
+#endif
 
-  return
 end subroutine riemann_hlle
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/PPM.h source/physics/Hydro/HydroMain/split/PPM/PPM.h
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/PPM.h	2021-02-23 18:16:25.600280068 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/PPM.h	2021-02-14 18:14:58.852204830 -0500
@@ -9,4 +9,12 @@
 #define UPDATE_BOUND 1
 #define UPDATE_ALL 2
 
-
+!!!!!-----------------------------!!
+!!!!!    RIEMANN SOLVER FLAGS     !!  
+!!!!!-----------------------------!!
+!!!#define EXACTRS 1
+!!!#define HLLE    2
+!!!#define AUSMP   3
+!!!#define AUSMPUP 4
+!!!#define AUSMPUPIT 5
+!!!#define ROEP 6
--- ../../../archive/FLASH4.6.2-hamr/bin/setup_shortcuts.txt	2021-02-23 18:16:25.457275932 -0500
+++ bin/setup_shortcuts.txt	2021-02-22 21:49:01.260527707 -0500
@@ -47,6 +47,12 @@
 chombo_ug:-unit=Grid/GridMain/Chombo/UG:-index-reorder:Grid=Chombo:-maxblocks=1:-nofbs:-makefile=chombo:chomboCompatibleHydro=True
 chombo_amr:-unit=Grid/GridMain/Chombo/AMR:-index-reorder:Grid=Chombo:-nofbs:-makefile=chombo:chomboCompatibleHydro=True
 
+# for multiresolution-driven adaptive mesh refinement
+amr_wvlt:--with-unit=Grid/GridSolvers/Multiresolution
+
+# for hybrid adaptive multiresolution
+mrppm:--with-unit=physics/Hydro/HydroMain/split/PPM/mrPPMKernel
+
 # pm4dev_clean indicates a version of Paramesh closer to the one
 # that can be downloaded from sourceforge.  pm4dev indicates a 
 # modified version of Paramesh that includes a more scalable way
