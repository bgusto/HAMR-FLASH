diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/Config source/Grid/GridMain/paramesh/Config
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/Config	2021-02-22 23:57:26.671116330 -0500
+++ source/Grid/GridMain/paramesh/Config	2021-02-19 18:01:48.483737366 -0500
@@ -14,7 +14,7 @@
 ENDIF
 
 # interpolation comes after paramesh4 source while linking so it can override!
-CHILDORDER paramesh4 interpolation
+CHILDORDER multiresolution paramesh4 interpolation
 
 CONFLICTS IO/IOMain/hdf5/parallel/UG
 CONFLICTS IO/IOMain/hdf5/serial/UG
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90 source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90	2021-02-22 23:57:38.573465054 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/gr_expandDomain.F90	2021-02-20 00:00:56.861052448 -0500
@@ -236,5 +236,8 @@
 
   call gr_ensureValidNeighborInfo(10)
 
+  ! if the mesh changed, need to recompute the MR mask(s)
+  call wvlt_encodeMesh()
+
   return
 end subroutine gr_expandDomain
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90	2021-02-22 23:57:38.573465054 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_data.F90	2021-02-20 00:00:56.861052448 -0500
@@ -152,6 +152,7 @@
   real, save :: gr_smallx
 
   integer, save :: gr_numRefineVars, gr_numRefineVarsMax
+  integer, save :: gr_numWvltRefineVars
   integer,allocatable,dimension(:) ,save :: gr_refineVars
   real ,save :: gr_imin,gr_imax,gr_jmin,gr_jmax,gr_kmin,gr_kmax
   real, save, dimension(LOW:HIGH,MDIM) :: gr_globalDomain
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90	2021-02-22 23:57:38.574465084 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_finalize.F90	2021-02-20 00:00:56.862052478 -0500
@@ -25,6 +25,7 @@
   use Grid_data, ONLY : gr_gsurr_blks
 #endif
   use gr_sbInterface, ONLY: gr_sbFinalize
+  use wvlt_interface, ONLY: wvlt_finalize
 
   implicit none
 
@@ -34,6 +35,7 @@
   if(allocated(gr_gsurr_blks))deallocate(gr_gsurr_blks)
 #endif
 
+  call wvlt_finalize()
   call gr_ptFinalize()
   call gr_solversFinalize()
   call gr_bcFinalize()
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90	2021-02-22 23:57:38.573465054 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_init.F90	2021-02-20 00:00:56.863052509 -0500
@@ -131,6 +131,7 @@
   use Simulation_interface, ONLY : Simulation_mapStrToInt, Simulation_getVarnameType
   use Grid_interface, only: Grid_getVarNonRep
   use paramesh_comm_data, ONLY : amr_mpi_meshComm
+  use wvlt_interface, ONLY : wvlt_init
 !  use gr_sbInterface, ONLY: gr_sbInit
   implicit none
 
@@ -423,6 +424,9 @@
 
   call RuntimeParameters_get("gr_restrictAllMethod", gr_restrictAllMethod)
 
+  ! initialize multiresolution module
+  call wvlt_init()
+
 #ifdef FLASH_PARTICLES
   call RuntimeParameters_get('useParticles',gr_useParticles)
   call RuntimeParameters_get('pt_maxPerProc',gr_maxParticlesPerProc)
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90	2021-02-22 23:57:38.574465084 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_markRefineDerefine.F90	2021-02-20 00:00:56.863052509 -0500
@@ -128,6 +128,9 @@
   end if
 #endif
 
+  ! call wavelet transform and block tagging
+  call Grid_markWaveletRefineDerefine()
+  
   if(gr_refineOnParticleCount)call gr_ptMarkRefineDerefine()
 
   if(gr_enforceMaxRefinement) call gr_enforceMaxRefine(gr_maxRefine)
@@ -144,7 +147,7 @@
      refine(:)   = .false.
      derefine(:) = .false.
   end where
-  
+
   return
 end subroutine Grid_markRefineDerefine
 
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_markWaveletRefineDerefine.F90	2021-02-19 13:15:29.335748474 -0500
@@ -0,0 +1,136 @@
+!!****h* source/Grid/GridSolvers/Multiresolution/wavelet/Grid_markWaveletRefineDerefine
+!!
+!! NAME
+!!  Grid_markWaveletRefineDerefine
+!!
+!! SYNOPSIS
+!!  
+!!  DESCRIPTION
+!!  
+!!    The forward wavelet transform (FWT) is performed on the desired variables.
+!!    This version uses average-interpolating wavelets of third order or fifth
+!!    order. Once wavelet transform performed, refinement flags are set.
+!!
+!!  ARGUMENTS 
+!!
+!!  NOTES
+!!  
+!!***
+
+subroutine Grid_markWaveletRefineDerefine()
+
+  use tree
+  use paramesh_dimensions
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, Grid_getBlkIndexLimits
+  use wvlt_data, ONLY : wvlt_numRefineVars
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! local vars
+  character(len=1024) :: filename
+  logical :: exist
+  logical :: test, expandBuffer
+  integer :: nstep
+  integer :: lb, l, i, j, k, p, bs
+  integer :: ilo, ihi, jlo, jhi, a, b, c
+  logical, dimension(NUNK_VARS) :: gcMask = .false.
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, pointer :: solnData(:,:,:,:) 
+
+  ! check if refinement variables are present
+  if ( wvlt_numRefineVars > 0 ) then
+
+    !------- clear mask everywhere -------!
+
+    ! loop through blocks
+    do lb = 1, MAXBLOCKS
+
+      ! get a pointer to solution data 
+      call Grid_getBlkPtr(lb, solnData)
+
+      ! evaluate mask for refinement
+      solnData(MSK1_VAR,:,:,:) = 0.e0
+      solnData(MSK2_VAR,:,:,:) = 0.e0
+      solnData(MSKA_VAR,:,:,:) = 0.e0
+      solnData(MSKB_VAR,:,:,:) = 0.e0
+      solnData(WVLT_VAR,:,:,:) = 0.e0
+
+      ! release pointer
+      call Grid_releaseBlkPtr(lb, solnData)
+
+    enddo
+
+    !------- perform the multiresolution encoding procedure -------!
+
+    ! call multiresolution encoding procedure
+    call wvlt_encodeMesh()
+  
+    !------- set refine/coarsen flags -------!
+
+    ! initialize these
+    refine(:) = .false.
+    derefine(:) = .false.
+    stay(:) = .false.
+
+    ! loop through blocks
+    do lb = 1, lnblocks
+
+      ! only analyze leaf blocks
+      if (nodetype(lb).eq.LEAF) then
+
+        ! get a pointer to solution data 
+        call Grid_getBlkPtr(lb, solnData)
+
+        ! get block dimensions
+        call Grid_getBlkIndexLimits(lb, blkLimits, blkLimitsGC)
+
+        ! evaluate mask for refinement
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            if (solnData(MSK1_VAR,i,j,1).gt.0.0e0) then
+              refine(lb) = .true.
+              stay(lb) = .false.
+            endif
+           enddo
+        enddo
+
+        ! evaluate mask for derefinement 
+        test = .true.
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            if (solnData(MSK2_VAR,i,j,1).gt.0.0e0) test = .false.
+          enddo
+        enddo
+        if (test) then
+          derefine(lb) = .true.
+          stay(lb) = .false.
+        endif
+
+        ! clear pointer
+        call Grid_releaseBlkPtr(lb,solnData)
+
+      endif ! if active block
+
+    enddo
+
+  else
+
+    ! no behavior, so as not to override other refinement criteria
+
+    !!!! loop through all local blocks
+    !!!do lb = 1, lnblocks
+
+    !!!  ! ensure no refinement/coarsening
+    !!!  stay(lb) = .true.
+    !!!  derefine(lb) = .false.
+    !!!  refine(lb) = .false.
+
+    !!!enddo
+
+  endif
+
+end subroutine Grid_markWaveletRefineDerefine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90 source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90	2021-02-22 23:57:38.574465084 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Grid_updateRefinement.F90	2021-02-20 00:00:56.864052539 -0500
@@ -48,6 +48,7 @@
   use gr_interface, ONLY : gr_updateRefinement
   use paramesh_interfaces, ONLY : amr_restrict
   use Logfile_interface, ONLY : Logfile_open,Logfile_close
+  use wvlt_data, ONLY: wvlt_useSolverAdaptivity, wvlt_printDiagnostic
  
 !!$  use tree, ONLY : newchild, lnblocks
 !!$  use paramesh_interfaces, ONLY : amr_refine_derefine, &
@@ -78,7 +79,6 @@
   !particles.  If particles are not included, this routine will be a stub
   call gr_ptFillBlkParticleInfo()
   
-  
   ! We only consider refinements every nrefs timesteps.
   if (mod(nstep, gr_nrefs) == 0) then
      
@@ -97,6 +97,10 @@
      
      call gr_updateRefinement(gridChanged)
 
+     ! if the mesh changed, need to recompute the MR mask(s) when using
+     ! solver-adaptivity
+     if ((wvlt_useSolverAdaptivity.or.wvlt_printDiagnostic).and.gridChanged) &
+       call wvlt_encodeMesh()
 
   else
      if (present(gridChanged)) gridChanged = .FALSE.
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Makefile source/Grid/GridMain/paramesh/multiresolution/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridMain/paramesh/multiresolution/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridMain/paramesh/multiresolution/Makefile	2021-02-19 15:51:14.497790093 -0500
@@ -0,0 +1 @@
+Grid +=	Grid_markWaveletRefineDerefine.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Config source/Grid/GridSolvers/Multiresolution/Config
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Config	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/Config	2021-02-19 18:04:38.736617958 -0500
@@ -0,0 +1,37 @@
+# this module requires paramesh, plus some modified paramesh files
+REQUIRES ../../GridMain/paramesh/multiresolution
+REQUIRES ../../GridMain/paramesh/paramesh4
+
+# required for amr
+PARAMETER wvlt_thresh  		  REAL	    0.e0 [0.e0 to ]
+PARAMETER wvlt_userelative 	BOOLEAN	  false  
+PARAMETER wvlt_nbuffer 	    INTEGER	  1 [0 to ]
+PARAMETER wvlt_maxlvl  		  INTEGER	  3 [3 to 3]
+PARAMETER wvlt_diagnostic   BOOLEAN   true
+PARAMETER wvlt_refine_var_1 STRING    "none"
+PARAMETER wvlt_refine_var_2 STRING    "none"
+PARAMETER wvlt_refine_var_3 STRING    "none"
+PARAMETER wvlt_refine_var_4 STRING    "none"
+PARAMETER wvlt_refine_var_5 STRING    "none"
+PARAMETER wvlt_refine_var_6 STRING    "none"
+
+# required for solver adaptivity
+PARAMETER wvlt_threshfactor           REAL	0.e0 [0.e0 to ]
+PARAMETER wvlt_interphydro 	          BOOLEAN	false
+PARAMETER wvlt_interpeos 	            BOOLEAN	false
+PARAMETER wvlt_interpburn 	          BOOLEAN	false
+
+# mask construction modes
+PPDEFINE AMR 1
+PPDEFINE SA 2
+
+# variables for parallel construction of mask
+VARIABLE MSK1
+VARIABLE MSK2
+VARIABLE WVLT
+
+# solver adaptive mask variables
+#IF withHAMR
+VARIABLE MSKA
+VARIABLE MSKB
+#D ENDIF
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Makefile source/Grid/GridSolvers/Multiresolution/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/Makefile	2021-02-19 17:42:37.336837990 -0500
@@ -0,0 +1,15 @@
+Grid +=	wvlt_data.o \
+				wvlt_interface.o \
+				wvlt_init.o \
+				wvlt_finalize.o \
+				wvlt_encodeMesh.o \
+				wvlt_encodeBlock.o \
+				wvlt_buildMask.o \
+				wvlt_expandBuffer.o \
+				wvlt_decomp1D.o \
+				wvlt_decomp2D.o \
+				wvlt_transform1D.o \
+				wvlt_transform2D.o \
+				wvlt_buildHydroMask.o \
+				wvlt_buildSourceMask.o \
+				wvlt_decompInterior.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/README.md source/Grid/GridSolvers/Multiresolution/README.md
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/README.md	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/README.md	2021-02-22 21:21:32.524238622 -0500
@@ -0,0 +1,50 @@
+README (DRAFT)
+
+!------- OVERVIEW -------!
+
+The hybrid adaptive multiresolution (HAMR) code is an add-on package for the
+FLASH simulation code, and can be downloaded freely at
+https://github.com/blg13/HAMR-FLASH. The HAMR approach uses multiresolution
+(MR) indicators not only to guide the refinement/coarsening of Cartesian meshes
+utilizing adaptive mesh refinement (AMR), but also to accelerate calculations
+of physical quantities in smooth regions. Note that the current implementation
+is limited to the Paramesh library. The HAMR code currently assumes that cells
+that are equally spaced in each direction.
+
+The HAMR-FLASH package is divided into two components: multiresolution-driven
+AMR (MrAMR) and HAMR. The first component can be used if one wants to use MR
+indicators for AMR purposes only. The latter component uses the former one, but
+also introduces solver-adaptivity; that is, using MR indicators to further
+accelerate the calculation of physical quantities using interpolation from
+coarser levels. The physical quantities currently considered by the algorithm
+are the hydrodynamic fluxes (split PPM), equation of state (EoS), and the reactive source
+terms.
+
+!------- DESCRIPTION -------!
+
+Runtime parameters associated with the package are described below:
+
+!------- INSTALLATION -------!
+
+How to install the HAMR package:
+
+1.) Download the package at https://github.com/blg13/HAMR-FLASH.
+
+2.) Run the included installer script, install_patch.pl (note that Perl is required).
+
+Once these steps are successfully completed, the modified FLASH code is ready
+to run. 
+
+!------- SETUPS -------!
+
+Some example problem setups can be found below:
+
+PATHTOFLASH/setup Blast2 \
+   -auto \
+   -1d \
+   -nxb=16 \
+   -maxblocks=2000 \
+   -with-unit=source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel \
+   +amr_wvlt \
+   +mrppm \
+   -objdir=object
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildHydroMask.F90	2021-02-15 23:17:25.342395340 -0500
@@ -0,0 +1,188 @@
+!!****if* source/flashUtilities/wvlt_buildHydroMask
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_buildHydroMask(blockID)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt, &
+                          blkLimits, solnPtr, hydroSweepLvl
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: blockID
+
+  ! local
+  logical :: flag1, flag2
+  integer :: l, i, j, k
+  integer :: ip, jp, kp, lstart
+  integer :: ivar
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(blockID,solnPtr)
+
+#if NDIM == 1
+
+  ! starting level is native grid level by default
+  lstart = wvlt_maxLvl
+
+  ! determine which multiresolution level is active
+  flag1 = .false.
+  flag2 = .true.
+  do while((.not.flag1).and.(lstart.ne.1))
+
+    ! level to analyze coefficients on
+    l = lstart-1
+
+    ! mask variable in 'unk'
+    if (l.eq.(wvlt_maxLvl-1)) then
+      ivar = MSKA_VAR
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      ivar = MSKB_VAR
+    endif
+
+    ! loop through cells
+    do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+      ! check if cell is active
+      if (solnPtr(ivar,i,1,1).gt.0.e0) then
+        flag2 = .false.
+        exit
+      endif
+    enddo
+    if (flag2) then
+      lstart = lstart - 1
+    else
+      flag1 = .true.
+    endif
+  enddo
+
+  ! set value of lstart for this block
+  hydroSweepLvl(1,1,1,blockID) = lstart
+
+#endif
+
+#if NDIM == 2
+
+  ! loop through IAXIS to get JAXIS values
+  do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+    ! starting level is native grid level by default
+    lstart = wvlt_maxLvl
+
+    ! determine which multiresolution level is active
+    flag1 = .false. ! stops the loop
+    flag2 = .true.  ! false if significant mask value found
+    do while((.not.flag1).and.(lstart.ne.1))
+
+      ! level to analyze coefficients on
+      l = lstart-1
+
+      ! mask variable in 'unk'
+      if (l.eq.(wvlt_maxLvl-1)) then
+        ivar = MSKA_VAR
+      elseif (l.eq.(wvlt_maxLvl-2)) then
+        ivar = MSKB_VAR
+      endif
+
+      ! loop through JAXIS with fixed i and determine lstart
+      do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+        if (solnPtr(ivar,i,j,1).gt.0.e0) then
+          flag2 = .false.
+          exit
+        endif
+      enddo
+
+      ! check flags
+      if (flag2) then
+
+        ! decrement lstart
+        lstart = lstart - 1
+
+      else
+
+        ! in this case, significant mask value found, set flag1 to true so the
+        ! loop stops
+        flag1 = .true.
+
+      endif
+
+    enddo
+
+    ! set value of lstart
+    hydroSweepLvl(i,JAXIS,1,blockID) = lstart
+
+  enddo
+
+  ! loop through JAXIS to get IAXIS values
+  do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+
+    ! starting level is native grid level by default
+    lstart = wvlt_maxLvl
+
+    ! determine which multiresolution level is active
+    flag1 = .false.
+    flag2 = .true.
+    do while((.not.flag1).and.(lstart.ne.1))
+
+      ! set mask level
+      l = lstart - 1
+
+      ! mask variable in 'unk'
+      if (l.eq.(wvlt_maxLvl-1)) then
+        ivar = MSKA_VAR
+      elseif (l.eq.(wvlt_maxLvl-2)) then
+        ivar = MSKB_VAR
+      endif
+
+      ! loop through IAXIS with fixed j
+      do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+        if (solnPtr(ivar,i,j,1).gt.0.e0) then
+          flag2 = .false.
+          exit
+        endif
+      enddo
+
+      ! check flags
+      if (flag2) then
+
+        ! decrement lstart
+        lstart = lstart - 1
+
+      else
+
+        ! in this case, significant mask value found, set flag1 to true so the
+        ! loop stops
+        flag1 = .true.
+
+      endif
+
+    enddo
+
+    ! set value of lstart
+    hydroSweepLvl(j,IAXIS,1,blockID) = lstart
+
+  enddo
+
+#endif
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(blockID,solnPtr)
+
+end subroutine wvlt_buildHydroMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildMask.F90	2021-02-19 13:15:16.131361160 -0500
@@ -0,0 +1,255 @@
+!!****if* source/flashUtilities/wvlt_buildMask
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_buildMask(numCells, numLvls, blockID, detailCoeffs)
+  
+  use tree, ONLY : lrefine
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt, &
+                          wvlt_threshold, parentCellIndices1, &
+                          parentCellIndices2, parentCellIndices3, &
+                          blkLimits, solnPtr, wvlt_useRelative, &
+                          wvlt_threshFactor, wvlt_printDiagnostic
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: numCells, numLvls, blockID
+#if NDIM == 1
+  real, dimension(numCells, 1, 1, numLvls), intent(inout) :: detailCoeffs
+#elif NDIM == 2
+  real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+#endif
+
+  ! local 
+  integer :: l, i, j, k, var, ivar
+  integer :: ii, jj, kk, lvl, ip, jp, kp
+  real :: tol, dereftol, interptol
+  real :: mskval
+  integer, dimension(iCellsInt(wvlt_maxLvl)) :: parentCellIndices
+#if NDIM == 1
+  logical, dimension(numCells, 1, 1, numLvls) :: mask
+  logical, dimension(numCells, 1, 1, numLvls) :: maskdrf
+  logical, dimension(numCells, 1, 1, numLvls) :: maskinterp
+#elif NDIM == 2
+  logical, dimension(numCells, numCells, 1, numLvls) :: mask
+  logical, dimension(numCells, numCells, 1, numLvls) :: maskdrf
+  logical, dimension(numCells, numCells, 1, numLvls) :: maskinterp
+#endif
+
+  ! initialize data
+  mask = .false.
+  maskdrf = .false.
+  maskinterp = .false.
+
+  ! get current level of block
+  lvl = lrefine(blockID)
+
+  ! compute tolerance
+  tol = wvlt_threshold(lvl)
+
+  ! loop through levels
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! derefinement tolerance + interptol
+    dereftol = tol
+    interptol = tol * wvlt_threshFactor
+
+    ! loop through interior cells
+#if NDIM == 1
+    do i = 1, iCellsInt(l)
+ 
+      ! refinement mask
+      if (l.eq.(wvlt_maxLvl-1)) then
+        if ((detailCoeffs(2*i-1,1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,1,1,l+1).ge.tol)) then
+
+          ! set mask to true in this location
+          mask(i,1,1,l) = .true.
+
+        endif
+      endif
+
+      ! derefinement mask
+      if (l.eq.(wvlt_maxLvl-2)) then
+        if ((detailCoeffs(2*i-1,1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,1,1,l+1).ge.dereftol)) then
+
+          ! set mask to true in this location
+          maskdrf(i,1,1,l) = .true.
+
+        endif
+      endif
+
+      ! interpolation mask
+      if ((detailCoeffs(2*i-1,1,1,l+1).ge.interptol) &
+          .or.(detailCoeffs(2*i,1,1,l+1).ge.interptol)) then
+
+        ! set mask to true in this location
+        maskinterp(i,1,1,l) = .true.
+
+      endif
+
+    enddo
+
+    ! compute tolerance update
+    tol = 0.5e0 * tol
+
+#elif NDIM == 2
+    do j = 1, jCellsInt(l)
+      do i = 1, iCellsInt(l)
+ 
+        ! if detail coefficient is significant put its neighbors in mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.tol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.tol)) then
+
+          ! set mask to true in this location
+          mask(i,j,1,l) = .true.
+
+        endif
+
+        ! if detail coefficient is significant put its neighbors in mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.dereftol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.dereftol)) then
+
+          ! set mask to true in this location
+          maskdrf(i,j,1,l) = .true.
+
+        endif
+
+        ! interpolation mask
+        if ((detailCoeffs(2*i-1,2*j-1,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i-1,2*j,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i,2*j-1,1,l+1).ge.interptol) &
+            .or.(detailCoeffs(2*i,2*j,1,l+1).ge.interptol)) then
+
+          ! set mask to true in this location
+          maskinterp(i,j,1,l) = .true.
+
+        endif
+
+      enddo
+    enddo
+
+    ! compute tolerance update
+    !tol = 0.25e0 * tol
+    tol = 0.5e0 * tol
+
+#endif
+
+  enddo
+
+  !------- refinement / derefinement mask -------!
+
+  ! store the mask in 'unk'
+  do l = wvlt_maxLvl-1, 1, -1
+
+!!!#if NDIM == 1
+!!!    mskval = 1.e0
+!!!#elif NDIM == 2
+!!!    mskval = real(lvl)
+!!!#endif
+    mskval = real(lvl)
+
+    ! get mask variable in unk
+    if (l.eq.(wvlt_maxLvl-1)) then
+      var = MSK1_VAR
+      ivar = MSKA_VAR
+      parentCellIndices = parentCellIndices1
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      var = MSK2_VAR
+      ivar = MSKB_VAR
+      parentCellIndices = parentCellIndices2
+    endif
+
+    ! nullify solutiondata
+    solnPtr(var,:,:,:) = 0.0e0
+    solnPtr(ivar,:,:,:) = 0.0e0
+
+    ! loop through interior cells, check refinement mask
+    if (l.eq.(wvlt_maxLvl-1)) then
+      do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+        kp = parentCellIndices(max(k-4,1))
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          jp = parentCellIndices(max(j-4,1))
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            ip = parentCellIndices(i-4)
+
+            ! set solnData's mask
+            if (mask(ip,jp,kp,l)) &
+              solnPtr(var,i,j,k) = mskval
+
+          enddo
+        enddo
+      enddo
+    endif
+
+    ! check derefinement mask
+    if (l.eq.(wvlt_maxLvl-2)) then
+      do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+        kp = parentCellIndices(max(k-4,1))
+        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+          jp = parentCellIndices(max(j-4,1))
+          do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+            ip = parentCellIndices(i-4)
+
+            ! derefinement trick
+            if (maskdrf(ip,jp,kp,l)) &
+              solnPtr(MSK2_VAR,i,j,k) = mskval
+
+          enddo
+        enddo
+      enddo
+    endif
+
+    ! check interpolation mask
+    do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+      kp = parentCellIndices(max(k-4,1))
+      do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+        jp = parentCellIndices(max(j-4,1))
+        do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+          ip = parentCellIndices(i-4)
+
+          ! set solnData's mask
+          if (maskinterp(ip,jp,kp,l)) &
+            solnPtr(ivar,i,j,k) = mskval
+
+        enddo
+      enddo
+    enddo
+
+    ! store detail coefficients in mask
+    if (wvlt_printDiagnostic) then
+      if (l.eq.(wvlt_maxLvl-1)) then
+        do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
+          do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+            do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+              solnPtr(WVLT_VAR,i,j,k) = detailCoeffs(i-4,max(j-4,1),max(k-4,1),l+1)
+            enddo
+          enddo
+        enddo
+      endif
+    endif
+
+  enddo
+
+end subroutine wvlt_buildMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90 source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_buildSourceMask.F90	2021-02-12 11:50:14.905250517 -0500
@@ -0,0 +1,125 @@
+!!****if* source/flashUtilities/wvlt_buildSourceMask
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_buildSourceMask(numCells, numLvls, solnPtr, activeCell, interpCell)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, kCellsInt
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+#if NDIM == 1
+  logical, dimension(numCells,1,1,numLvls), intent(inout) :: activeCell
+  logical, dimension(numCells,1,1,numLvls), intent(inout) :: interpCell
+#endif
+#if NDIM == 2
+  logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: activeCell
+  logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: interpCell
+#endif
+  real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+
+  ! local
+  integer :: l, i, j, var, dl
+
+  ! clear data
+  interpCell = .false.
+  activeCell = .false.
+ 
+  do l = 1, wvlt_maxLvl-1
+
+    ! level difference
+    dl = wvlt_maxLvl - l
+
+    ! get mask variable in unk
+    if (dl.eq.1) then
+      var = MSKA_VAR
+    elseif (dl.eq.2) then
+      var = MSKB_VAR
+    endif
+
+#if NDIM == 1
+
+    do i = 1, iCellsInt(l)
+
+      ! check if cell is in mask
+      if (solnPtr(var,i*2**dl+4,1,1).gt.0.0) then
+
+        ! set this cell to false
+        activeCell(i,1,1,l) = .false.
+
+        ! set its children to true
+        activeCell(2*i-1,1,1,l+1) = .true.
+        activeCell(2*i,1,1,l+1) = .true.
+
+      else
+
+        ! check if this cell is to be interpolated, else burn it
+        if (.not.interpCell(i,1,1,l)) &
+          activeCell(i,1,1,l) = .true.
+
+        ! set children to be interpolated
+        interpCell(2*i-1,1,1,l+1) = .true.
+        interpCell(2*i,1,1,l+1) = .true.
+
+      endif
+
+    enddo
+
+#endif
+
+#if NDIM == 2
+
+    ! loop through cells at current level
+    do j = 1, jCellsInt(l)
+      do i = 1, iCellsInt(l)
+
+        ! check if cell is in mask
+        if ((solnPtr(var,i*2**dl+4,j*2**dl+4,1).gt.0.0)) then
+
+          ! set this cell to false
+          activeCell(i,j,1,l) = .false.
+
+          ! set its children to true
+          activeCell(2*i-1,2*j-1,1,l+1) = .true.
+          activeCell(2*i-1,2*j,1,l+1) = .true.
+          activeCell(2*i,2*j-1,1,l+1) = .true.
+          activeCell(2*i,2*j,1,l+1) = .true.
+
+        else
+
+          ! check if this cell is to be interpolated, else burn it
+          if (.not.interpCell(i,j,1,l)) &
+            activeCell(i,j,1,l) = .true.
+
+          ! set children to be interpolated
+          interpCell(2*i-1,2*j-1,1,l+1) = .true.
+          interpCell(2*i-1,2*j,1,l+1) = .true.
+          interpCell(2*i,2*j-1,1,l+1) = .true.
+          interpCell(2*i,2*j,1,l+1) = .true.
+
+        endif
+
+      enddo
+    enddo
+
+#endif
+
+  enddo
+
+end subroutine wvlt_buildSourceMask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_data.F90 source/Grid/GridSolvers/Multiresolution/wvlt_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_data.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_data.F90	2021-02-19 12:00:07.301084199 -0500
@@ -0,0 +1,71 @@
+!!****if* source/flashUtilities/Wavelet/wvlt_data.F90
+!!
+!! NAME
+!!  wvlt_data
+!!
+!! SYNOPSIS
+!!
+!!  Stores all data used by wavelet subroutines. Contains functions for mapping
+!!  indices, getting buffer regions, and computing interpolations.
+!!
+!! VARIABLE DESCRIPTIONS
+!!
+!!  mask - is defined per block; defines which cells in the dyadic grid
+!!         hierarchy may be interpolated
+!!***
+
+module wvlt_data
+
+  use tree
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  integer,  save                    :: wvlt_numRefineVars, wvlt_maxLvl
+  integer,  save                    :: totCells, totIntCells, numInterp, wvlt_bufferSize
+  integer,  save, allocatable       :: numCells(:), iCellsInt(:), jCellsInt(:), &
+                                       kCellsInt(:), mrRefineMaskVars(:), &
+                                       intCells(:), iCellsTot(:), jCellsTot(:), &
+                                       kCellsTot(:)
+  real, save :: wvlt_threshFactor
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, save, allocatable :: wvlt_threshold(:)
+  real, save, allocatable :: detailCoeffs(:), cellData(:), &
+                              cellDataInterior(:,:), detailCoeffs1D(:)
+  real, save, pointer :: solnPtr(:,:,:,:) 
+  logical, save :: wvlt_interpHydro = .false.
+  logical, save :: wvlt_interpBurn = .false.
+  logical, save :: wvlt_interpEos = .false.
+  logical, save :: wvlt_useSolverAdaptivity = .false.
+  logical, save :: wvlt_useRelative = .false.
+  !???logical, save :: printVals = .false.
+  logical, save :: wvlt_printDiagnostic = .false.
+  logical, save, allocatable :: fluxMask(:,:)
+  integer, save, allocatable :: numIntrfcActv(:), numFluxActv(:)
+  integer, save, allocatable :: intrfcKey(:,:), fluxKey(:,:)
+  integer, save, allocatable :: hydroSweepLvl(:,:,:,:)
+
+  integer, save, allocatable :: parentCellIndices1(:)
+  integer, save, allocatable :: parentCellIndices2(:)
+  integer, save, allocatable :: parentCellIndices3(:)
+
+  contains
+
+    function lmap( l, i ) result(x)
+
+      implicit none
+
+      integer, intent(in)   :: l, i
+      integer               :: dl, x
+
+      ! compute difference between levels
+      dl = wvlt_maxLvl - l
+
+      ! map any interface index on level l to the max level, wvlt_maxLvl
+      x = (2.0**dl)*(i-1) + 1
+      
+    end function lmap 
+
+end module wvlt_data
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decomp1D.F90	2021-02-12 11:50:14.905250517 -0500
@@ -0,0 +1,60 @@
+!!****if* source/flashUtilities/wvlt_decomp1D
+!!
+!! NAME
+!!
+!! SYNOPSIS
+!!
+!!      This routine performs a one-dimensional transform on the given data,
+!!      producing detail coefficients. Biased stencils are used near the
+!!      boundaries. The data is temporarily stored in the wavelet module's
+!!      data structure 'cellData' and uses the index mapping 'cmap.' It is
+!!      assumed that the data passed is of the size equal to the fixed length
+!!      of a block (nxb = nyb = nzb), plus ghost cells.
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!!      numCells ~ the number of cells at the finest level
+!!      numLvls ~ the number of wavelet levels to use
+!!      varData ~ the data to perform the transform on
+!!      cellData ~ the hierarchy of data
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_decomp1D(numCells, numLvls, varData, cellData)
+
+  use wvlt_data, ONLY : iCellsTot
+
+  implicit none
+
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells), intent(in) :: varData
+  real, dimension(numCells, 1, 1, numLvls), intent(out) :: cellData
+
+  integer :: l, i, ilo, ihi
+
+  ! max level
+  l = numLvls
+
+  ilo = 1
+  ihi = iCellsTot(l)
+  do i = ilo, ihi
+    cellData(i,1,1,l) = varData(i)
+  enddo
+
+  ! decompose into hierarchy
+  do l = numLvls-1, 1, -1
+
+    ! coarsen cells
+    ilo = 1
+    ihi = iCellsTot(l)
+    do i = ilo, ihi
+      cellData(i,1,1,l) = 0.5e0*(cellData(2*i-1,1,1,l+1) + cellData(2*i,1,1,l+1))
+    enddo
+
+  end do
+
+end subroutine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decomp2D.F90	2021-02-12 11:50:14.904250488 -0500
@@ -0,0 +1,69 @@
+!!****if* source/flashUtilities/wvlt_decomp2D
+!!
+!! NAME
+!!
+!! SYNOPSIS
+!!
+!!      This routine performs a two-dimensional transform on the given data.
+!!      It is assumed that the data passed is of the size equal to the fixed
+!!      length of a block (nxb = nyb = nzb), plus ghost cells.
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!!      numCells ~ the number of cells at the finest level
+!!      numLvls ~ the number of wavelet levels to use
+!!      varData ~ the data to perform the transform on
+!!      cellData ~ the hierarchy of data
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_decomp2D(numCells, numLvls, varData, cellData)
+
+  use wvlt_data, ONLY : iCellsTot, jCellsTot
+
+  implicit none
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells, numCells), intent(in) :: varData
+  real, dimension(numCells, numCells, 1, numLvls), intent(out) :: cellData
+
+  ! local vars
+  integer :: l, i, j, ilo, ihi, jlo, jhi
+
+  ! max level
+  l = numLvls
+
+  ! get data on block's native grid level
+  ilo = 1
+  ihi = iCellsTot(l)
+  do i = ilo, ihi
+    jlo = 1
+    jhi = jCellsTot(l)
+    do j = jlo, jhi
+      cellData(i,j,1,l) = varData(i,j)
+    enddo
+  enddo
+
+  ! decompose into hierarchy
+  do l = numLvls-1, 1, -1
+
+    ! coarsen cells
+    ilo = 1
+    ihi = iCellsTot(l)
+    do i = ilo, ihi
+      jlo = 1
+      jhi = jCellsTot(l)
+      do j = jlo, jhi
+        cellData(i,j,1,l) = 0.25e0*(cellData(2*i-1,2*j-1,1,l+1) + cellData(2*i-1,2*j,1,l+1) &
+                              + cellData(2*i,2*j-1,1,l+1) + cellData(2*i,2*j,1,l+1))
+      enddo
+    enddo
+
+  end do
+
+end subroutine
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90 source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_decompInterior.F90	2021-02-19 09:43:47.221952794 -0500
@@ -0,0 +1,98 @@
+!!****if* source/flashUtilities/wvlt_decomp1D
+!!
+!! NAME
+!!
+!! SYNOPSIS
+!!
+!!      This routine performs a decomposition on the block interior. This type
+!!      of routine is useful for calculating source terms adaptively, since only the
+!!      block interior need be considered. The data is stored in the array
+!!      'cellData', which is a rank 4 array.  This routine does not make
+!!      use of memory-optimized data structure and instead uses direct indices to
+!!      achieve speed.
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!!      numCells ~ the number of cells at the finest level
+!!      numLvls ~ the number of wavelet levels to use
+!!      var ~ the variable index in 'unk'
+!!      cellData ~ the interior cell data, a rank 4 array
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_decompInterior(numCells, numLvls, var, solnPtr, cellData)
+  
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt, jCellsInt, blkLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: numCells, numLvls, var
+  real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+  real :: diff, sm
+#if NDIM == 1
+  real, dimension(numCells,1,1,numLvls), intent(inout) :: cellData
+#endif
+#if NDIM == 2
+  real, dimension(numCells,numCells,1,numLvls), intent(inout) :: cellData
+#endif
+
+  ! local data
+  integer :: l, i, j, ilo, ihi, jlo, jhi
+
+  ! initialize data
+  cellData = 0.0
+
+  ! copy first level into new hierarchy data structure 
+  ilo = 1
+  ihi = iCellsInt(wvlt_maxLvl)
+  jlo = 1
+  jhi = jCellsInt(wvlt_maxLvl)
+  do i = ilo, ihi
+    do j = jlo, jhi
+      cellData(i,j,1,wvlt_maxLvl) = solnPtr(var, &
+                                                  blkLimits(LOW,IAXIS)+i-1, &
+                                                  blkLimits(LOW,JAXIS)+j-1, &
+                                                  blkLimits(LOW,KAXIS))
+    enddo
+  enddo
+
+  ! decompose into hierarchy
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! coarsen cells
+#if NDIM == 1
+    ilo = 1
+    ihi = iCellsInt(l)
+    do i = ilo, ihi
+      cellData(i,1,1,l) = 0.5e0*(cellData(2*i,1,1,l+1) + cellData(2*i-1,1,1,l+1))
+    enddo
+#endif
+
+#if NDIM == 2
+    ! coarsen cells in 2D
+    ilo = 1
+    ihi = iCellsInt(l)
+    jlo = 1
+    jhi = jCellsInt(l)
+    do i = ilo, ihi
+      do j = jlo, jhi
+        cellData(i,j,1,l) = (cellData(2*i-1,2*j-1,1,l+1) &
+                                              + cellData(2*i-1,2*j,1,l+1) &
+                                              + cellData(2*i,2*j-1,1,l+1) &
+                                              + cellData(2*i,2*j,1,l+1)) / 4.0e0
+      enddo
+    enddo
+#endif
+
+  enddo
+
+end subroutine wvlt_decompInterior
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90 source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_encodeBlock.F90	2021-02-19 13:11:47.398239411 -0500
@@ -0,0 +1,78 @@
+!!****if* source/flashUtilities/wavelet/wvlt_encodeBlock
+!!
+!! NAME
+!!  wvlt_encodeBlock
+!!
+!! SYNOPSIS
+!!  
+!!  DESCRIPTION
+!!  
+!!    The forward wavelet transform (FWT) is performed on the desired variables.
+!!    This version uses average-interpolating wavelets of third order or fifth
+!!    order.
+!!
+!!  ARGUMENTS 
+!!
+!!    localBlkID - local block ID
+!!
+!!  NOTES
+!!  
+!!***
+
+subroutine wvlt_encodeBlock(localBlkID)
+
+  use wvlt_data, ONLY : wvlt_maxLvl, wvlt_numRefineVars, mrRefineMaskVars, &
+                          iCellsTot, jCellsTot, kCellsTot, &
+                          blkLimits, blkLimitsGC, solnPtr
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, &
+                             Grid_getBlkIndexLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  integer, intent(in) :: localBlkID
+  integer :: var, nx, ny, nz
+  real, allocatable, dimension(:,:,:,:) :: details
+
+  ! number of cells on fine grid
+  nx = iCellsTot(wvlt_maxLvl)
+  ny = jCellsTot(wvlt_maxLvl)
+  nz = kCellsTot(wvlt_maxLvl)
+
+  ! allocate arrays
+  allocate(details(nx,ny,nz,wvlt_maxLvl))
+
+  ! initialize values
+  details = 0.0e0
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(localBlkID,solnPtr)
+
+  ! get block dimensions
+  call Grid_getBlkIndexLimits(localBlkID,blkLimits,blkLimitsGC)
+
+  ! loop through variables that refinement is based on
+  do var = 1, wvlt_numRefineVars
+
+    ! compute detail coefficients
+#if NDIM == 1
+    call wvlt_transform1D(nx, wvlt_maxLvl, solnPtr(mrRefineMaskVars(var),:,1,1), details)
+#elif NDIM == 2
+    call wvlt_transform2D(nx, wvlt_maxLvl, solnPtr(mrRefineMaskVars(var),:,:,1), details)
+#endif
+
+  enddo
+
+  ! once detail coefficients computed, add to mask
+  call wvlt_buildMask(nx, wvlt_maxLvl, localBlkID, details)
+
+  ! deallocate arrays
+  deallocate(details)
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(localBlkID,solnPtr)
+
+end subroutine wvlt_encodeBlock
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90 source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_encodeMesh.F90	2021-02-19 13:39:01.114643655 -0500
@@ -0,0 +1,127 @@
+!!****h* source/Grid/GridSolvers/Multiresolution/wavelet/wvlt_encodeMesh
+!!
+!! NAME
+!!  wvlt_encodeMesh
+!!
+!! SYNOPSIS
+!!  
+!!  DESCRIPTION
+!!  
+!!    The multiresolution encoding procedure is performed on the entire mesh
+!!    structure.
+!!
+!!  ARGUMENTS 
+!!
+!!  NOTES
+!!  
+!!***
+
+subroutine wvlt_encodeMesh()
+
+  !use paramesh_dimensions
+  use tree
+  use Grid_interface, ONLY : Grid_fillGuardCells
+  use wvlt_data, ONLY : wvlt_numRefineVars, wvlt_maxLvl, &
+                         wvlt_interpHydro, wvlt_bufferSize, &
+                         wvlt_useSolverAdaptivity
+  use wvlt_interface, ONLY : wvlt_encodeBlock, wvlt_expandBuffer, wvlt_buildHydroMask
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! local vars
+  character(len=1024) :: filename
+  logical :: exist
+  logical :: test, expandBuffer
+  integer :: nstep
+  integer :: lb, l, i, j, k, p, bs
+  integer :: ilo, ihi, jlo, jhi, a, b, c
+  logical, dimension(NUNK_VARS) :: gcMask = .false.
+  integer, dimension(2,MDIM), save :: blkLimits, blkLimitsGC
+  real, pointer :: solnData(:,:,:,:) 
+
+  ! check if refinement variables are present
+  if ( wvlt_numRefineVars > 0 ) then
+
+    !------- ensure correct guardcell information -------!
+
+    ! MR interpolation requires correct guardcell data
+    call Grid_fillGuardCells(CENTER, ALLDIR, doEos=.false.)
+
+    !------- compute detail coefficients and initialize mask on all blocks -------!
+
+    ! loop through local blocks
+    do lb = 1, lnblocks
+
+      ! only consider leaf blocks
+      if (nodetype(lb).eq.LEAF) then
+
+        ! perform wavelet transform
+        call wvlt_encodeBlock(lb)
+
+      endif
+
+    enddo
+
+    !------- create MR mask buffer region -------!
+
+    ! set gcMask
+    gcMask(MSK1_VAR) = .true.
+    gcMask(MSK2_VAR) = .true.
+    if (wvlt_useSolverAdaptivity) then
+      gcMask(MSKA_VAR) = .true.
+      gcMask(MSKB_VAR) = .true.
+    endif
+
+    ! loop through buffer layers (advect mask one cell in every direction)
+    do p = 1, wvlt_bufferSize
+
+      ! block loop
+      do lb = 1, lnblocks
+
+        ! only analyze leaf blocks
+        if (nodetype(lb).eq.LEAF) then
+
+          ! propogate the guardcell mask information for amr mask
+          call wvlt_expandBuffer(lb, AMR)
+
+          ! propogate the guardcell mask information for interp mask
+          if (wvlt_useSolverAdaptivity) &
+            call wvlt_expandBuffer(lb, SA)
+
+        endif
+
+      enddo
+
+      ! transfer mask information
+      call Grid_fillGuardCells(CENTER, ALLDIR, doEos=.false., maskSize=NUNK_VARS, &
+                                mask=gcMask, makeMaskConsistent=.false.)
+
+    enddo
+
+    !------- for simplified split hydro mask option -------#
+
+    ! loop through local blocks
+    if (wvlt_interpHydro) then
+
+      ! loop through all blocks
+      do lb = 1, lnblocks
+
+        ! only analyze leaf blocks
+        if (nodetype(lb).eq.LEAF) then
+
+          ! for hydro module
+          call wvlt_buildHydroMask(lb)
+
+        endif
+
+      enddo
+
+    endif
+
+  endif
+
+end subroutine wvlt_encodeMesh
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90 source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_expandBuffer.F90	2021-02-19 13:27:15.065187539 -0500
@@ -0,0 +1,462 @@
+!!****if* source/flashUtilities/wvlt_expandBuffer
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_expandBuffer(blockID, optmode)
+  
+  use wvlt_data
+  use tree, ONLY : lrefine
+  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_releaseBlkPtr, &
+                             Grid_getBlkIndexLimits
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! arguments
+  integer, intent(in) :: blockID
+  integer, intent(in), optional :: optmode
+
+  ! local scalars
+  integer :: lvl, mode
+  integer :: l, i, j, k, var
+  integer :: ii, jj, bs, ip, jp
+  integer :: MVAR1, MVAR2
+  integer :: status = 0
+
+  ! local arrays
+  integer, dimension(iCellsInt(wvlt_maxLvl)) :: parentCellIndices
+  integer, dimension(2,MDIM) :: bufferRange
+  logical, dimension(iCellsTot(wvlt_maxLvl), jCellsTot(wvlt_maxLvl)) :: tmpmask
+
+  ! check mode, make AMR the default mode
+  if (present(optmode)) then
+    mode = optmode
+  else
+    mode = AMR
+  endif
+
+  ! determine which mask to use
+  if (mode.eq.AMR) then
+    MVAR1 = MSK1_VAR
+    MVAR2 = MSK2_VAR
+  elseif (mode.eq.SA) then
+    MVAR1 = MSKA_VAR
+    MVAR2 = MSKB_VAR
+  else
+    print *, "Incorrect mode supplied in 'wvlt_expandBuffer.' Should be 'AMR' or 'SA.'"
+    call exit(status)
+  endif
+
+  ! get a pointer to solution data 
+  call Grid_getBlkPtr(blockID, solnPtr)
+
+  ! get block dimensions
+  call Grid_getBlkIndexLimits(blockID, blkLimits, blkLimitsGC)
+
+  ! get current level of block
+  lvl = lrefine(blockID)
+
+  ! loop through levels
+  do l = wvlt_maxLvl-1, 1, -1
+
+    ! initialize arrays
+    tmpmask = .false.
+
+    ! get mask variable in unk
+    if (l.eq.(wvlt_maxLvl-1)) then
+      var = MVAR1
+      parentCellIndices = parentCellIndices1
+    elseif (l.eq.(wvlt_maxLvl-2)) then
+      var = MVAR2
+      parentCellIndices = parentCellIndices2
+    endif
+
+    ! size of a cell in the mask
+    !bs = 2**(wvlt_maxLvl-l)
+    bs = 1
+
+#if NDIM == 1
+
+    !------- expand interior -------!
+
+    do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+      ! check for mask information and propagate
+      if (solnPtr(var,i,1,1).gt.0.0e0) then
+
+        ! buffer range (move one mask value per call)
+        bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+        bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+        ! create buffer
+        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+          !solnPtr(var,ii,1,1) = real(lvl)
+          tmpmask(ii,1) = .true.
+        enddo
+
+      endif
+
+    enddo
+
+    !------- extend guardcell regions --------!
+
+    ! if left neighbor is at the same level
+    if (solnPtr(var,blkLimitsGC(LOW,IAXIS),1,1).eq.real(lvl)) then
+
+      ! lower block end expansion
+      do i = blkLimits(LOW,IAXIS)-1, blkLimitsGC(LOW,IAXIS), -1
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = i
+          bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+          ! extend the buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    ! left neighbor is at higher level
+    elseif (solnPtr(var,blkLimitsGC(LOW,IAXIS),1,1).eq.(real(lvl+1))) then
+
+      ! lower block end expansion
+      do i = blkLimits(LOW,IAXIS)-1, blkLimitsGC(LOW,IAXIS)+2, -1
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = i
+          bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+
+          ! create buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    endif
+
+    ! if right neighbor is at the same level
+    if (solnPtr(var,blkLimitsGC(HIGH,IAXIS),1,1).eq.real(lvl)) then
+
+      ! lower block end expansion
+      do i = blkLimits(HIGH,IAXIS)+1, blkLimitsGC(HIGH,IAXIS)
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = i
+
+          ! extend the buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    ! left neighbor is at higher level
+    elseif (solnPtr(var,blkLimitsGC(HIGH,IAXIS),1,1).eq.(real(lvl+1))) then
+
+      ! lower block end expansion
+      do i = blkLimits(HIGH,IAXIS)+1, blkLimitsGC(HIGH,IAXIS)-2
+
+        ! check for mask information
+        if (solnPtr(var,i,1,1).gt.0.e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = i
+
+          ! create buffer
+          do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+            !solnPtr(var,ii,1,1) = 1.e0
+            tmpmask(ii,1) = .true.
+          enddo
+
+        endif
+
+      enddo
+
+    endif
+
+    ! transfer 'tmpmask' to 'unk'
+    do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+      if (tmpmask(i,1)) then
+        solnPtr(var,i,1,1) = real(lvl)
+      else
+        solnPtr(var,i,1,1) = 0.e0
+      endif
+    enddo
+
+#elif NDIM == 2
+
+    !------- expand whole block' mask region -------!
+
+    do j = blkLimitsGC(LOW,JAXIS), blkLimitsGC(HIGH,JAXIS)
+      do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+        ! check for mask information and propagate
+        if (solnPtr(var,i,j,1).gt.0.0e0) then
+
+          ! buffer range (move one mask value per call)
+          bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+          bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+          bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+          bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+          ! create buffer
+          do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+            do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+              tmpmask(ii,jj) = .true.
+            enddo
+          enddo
+
+        endif
+
+      enddo
+    enddo
+
+
+    ! old/alternate logic is based on the neighboring block's relative
+    ! refinement level
+
+    !!!!------- expand interior -------!
+
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).gt.0.0e0) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimits(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimits(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimits(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimits(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!!------- extend guardcell regions --------!
+
+    !!!! check the lower block edge for mask
+    !!!do j = blkLimitsGC(LOW,JAXIS), blkLimits(LOW,JAXIS)
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the left block edge for mask
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimits(LOW,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the right block edge for mask
+    !!!do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
+    !!!  do i = blkLimitsGC(HIGH,IAXIS), blkLimits(HIGH,IAXIS), -1
+
+    !!!    ! check for mask information and propagate
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    !!!! check the upper block edge for mask
+    !!!do j = blkLimitsGC(HIGH,JAXIS), blkLimits(HIGH,JAXIS), -1
+    !!!  do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+
+    !!!    ! check for mask information and propagate
+    !!!    !!print *, "var, i, j, solnPtr(var,i,j,1)", var, i, j, solnPtr(var,i,j,1)
+    !!!    !!print *, "real(lvl)", real(lvl)
+    !!!    if (solnPtr(var,i,j,1).eq.real(lvl)) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    elseif (solnPtr(var,i,j,1).eq.(real(lvl+1))) then
+
+    !!!      ! buffer range (move one mask value per call)
+    !!!      bufferRange(LOW,IAXIS) = max(blkLimitsGC(LOW,IAXIS),i-bs)
+    !!!      bufferRange(HIGH,IAXIS) = min(blkLimitsGC(HIGH,IAXIS),i+bs)
+    !!!      bufferRange(LOW,JAXIS) = max(blkLimitsGC(LOW,JAXIS),j-bs)
+    !!!      bufferRange(HIGH,JAXIS) = min(blkLimitsGC(HIGH,JAXIS),j+bs)
+
+    !!!      ! create buffer
+    !!!      do jj = bufferRange(LOW,JAXIS), bufferRange(HIGH,JAXIS)
+    !!!        do ii = bufferRange(LOW,IAXIS), bufferRange(HIGH,IAXIS)
+    !!!          tmpmask(ii,jj) = .true.
+    !!!        enddo
+    !!!      enddo
+
+    !!!    endif
+
+    !!!  enddo
+    !!!enddo
+
+    ! transfer 'tmpmask' to 'unk'
+    do j = blkLimitsGC(LOW,JAXIS), blkLimitsGC(HIGH,JAXIS)
+      do i = blkLimitsGC(LOW,IAXIS), blkLimitsGC(HIGH,IAXIS)
+        if (tmpmask(i,j)) then
+          solnPtr(var,i,j,1) = real(lvl)
+        else
+          solnPtr(var,i,j,1) = 0.e0
+        endif
+      enddo
+    enddo
+
+#endif
+
+  enddo
+
+  ! clear pointer
+  call Grid_releaseBlkPtr(blockID,solnPtr)
+
+end subroutine wvlt_expandBuffer
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90 source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_finalize.F90	2021-02-12 11:50:14.905250517 -0500
@@ -0,0 +1,55 @@
+!!****if* source/flashUtilities/Wavelet/wvlt_finalize
+!!
+!! NAME
+!!
+!!  wvlt_finalize
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_finalize() 
+  
+  ! declare modules used
+  use wvlt_data
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
+                                          RuntimeParameters_getReal
+  use Driver_interface, ONLY : Driver_abortFlash
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  !------- deallocate memory -------!
+
+  deallocate(intCells)
+  deallocate(numCells)
+  deallocate(iCellsInt)
+  deallocate(jCellsInt)
+  deallocate(kCellsInt)
+  deallocate(iCellsTot)
+  deallocate(jCellsTot)
+  deallocate(kCellsTot)
+  deallocate(mrRefineMaskVars)
+  deallocate(wvlt_threshold)
+
+  deallocate(intrfcKey)
+  deallocate(fluxKey)
+  deallocate(fluxMask)
+  deallocate(numIntrfcActv)
+  deallocate(numFluxActv)
+
+  deallocate(parentCellIndices1)
+  deallocate(parentCellIndices2)
+  deallocate(parentCellIndices3)
+
+  deallocate(hydroSweepLvl)
+
+end subroutine wvlt_finalize
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_init.F90 source/Grid/GridSolvers/Multiresolution/wvlt_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_init.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_init.F90	2021-02-19 09:31:04.559925892 -0500
@@ -0,0 +1,325 @@
+!!****if* source/flashUtilities/Wavelet/wvlt_init
+!!
+!! NAME
+!!
+!!  wvlt_init
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!   This function is called in Driver/DriverMain/Driver_initFlash. A
+!!   counterpart file called wvlt_finalize() is called in Driver_finalizeFlash.
+!!   The number of ghost cells (nlayers) is currently assumed to be 4.
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_init() 
+
+  ! declare modules used
+  use wvlt_data 
+  use tree,             ONLY : lrefine, lrefine_min, lrefine_max
+  use Driver_interface, ONLY : Driver_abortFlash
+  use Grid_data,        ONLY : gr_meshMe, gr_domainBC, gr_numWvltRefineVars
+  use wvlt_data,        ONLY : mrRefineMaskVars, wvlt_numRefineVars
+
+  use Grid_interface,              ONLY : Grid_getLocalNumBlks, Grid_getBlkIndexLimits, &
+                                          Grid_getBlkPtr,       Grid_releaseBlkPtr
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
+                                          RuntimeParameters_getReal, &
+                                          RuntimeParameters_getLog
+  use Simulation_interface,        ONLY : Simulation_mapStrToInt, Simulation_getVarnameType
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+#include "Flash_mpi.h"
+
+  integer :: l, i, j, k, refVar, numflx, numintrfc
+  integer :: ip, jp
+  integer :: lstart, itot
+  real :: threshold
+  logical, allocatable :: tmpmask(:)
+  character(len=MAX_STRING_LENGTH),save :: refVarName, refVarString, paramString
+
+  !--------------------------------------------------------------------------------
+
+  ! refinement variable basename
+  refVarName='wvlt_refine_var_'
+
+  ! allocate space for mrRefineVars
+  allocate(mrRefineMaskVars(6))
+
+  gr_numWvltRefineVars = 0
+
+  ! loop through possible refinement choices
+  do i = 1, 6
+
+    ! concatenate string
+    call concatStringWithInt(refVarName,i,refVarString)
+    call RuntimeParameters_get(refVarString, paramString)
+
+    ! if string is not 'none'
+    if(paramString /= "none") then
+
+      ! find the identifying integer
+      call Simulation_mapStrToInt(paramString, refVar, MAPBLOCK_UNK)
+      
+      ! if integer is valid
+      if (refVar > 0) then
+
+        ! add to total
+         gr_numWvltRefineVars = gr_numWvltRefineVars + 1
+
+        ! set mrrefinevar
+        mrRefineMaskVars(i) = refVar
+
+      else
+
+        ! set mrrefinevar
+        mrRefineMaskVars(i) = 0
+
+      endif
+
+    endif
+
+  enddo
+
+  ! number of multiresolution indicator variables
+  wvlt_numRefineVars = gr_numWvltRefineVars
+
+  ! read in multiresolution parameters
+  call RuntimeParameters_getReal("wvlt_thresh", threshold)
+  call RuntimeParameters_getLog("wvlt_userelative", wvlt_useRelative)
+  call RuntimeParameters_get("wvlt_nbuffer", wvlt_bufferSize)
+  call RuntimeParameters_get("wvlt_maxlvl", wvlt_maxLvl)
+  call RuntimeParameters_get("wvlt_diagnostic", wvlt_printDiagnostic)
+  call RuntimeParameters_getReal("wvlt_threshfactor", wvlt_threshFactor)
+  call RuntimeParameters_getLog("wvlt_interphydro", wvlt_interpHydro)
+  call RuntimeParameters_getLog("wvlt_interpeos", wvlt_interpEos)
+  call RuntimeParameters_getLog("wvlt_interpburn", wvlt_interpBurn)
+
+  ! determine if solver-adaptivity is to be used
+  if (wvlt_interpHydro .or. wvlt_interpEos .or. wvlt_interpBurn) &
+    wvlt_useSolverAdaptivity = .true.
+
+  !------- wavelet threshold -------!
+
+  ! allocate memory for each level
+  allocate(wvlt_threshold(lrefine_max))
+
+  ! compute threshold on each level
+  wvlt_threshold(lrefine_max) = threshold
+  do l = lrefine_max-1, 1, -1
+#if NDIM == 1
+    wvlt_threshold(l) = 0.5e0 * wvlt_threshold(l+1)
+#endif
+#if NDIM == 2
+    !wvlt_threshold(l) = 0.25e0 * wvlt_threshold(l+1)
+    wvlt_threshold(l) = 0.5e0 * wvlt_threshold(l+1)
+#endif
+  enddo
+
+  !------- variable-independent block information -------!
+
+  ! allocate memory for block information (independent of vars)
+  allocate(intCells(wvlt_maxLvl))
+  allocate(numCells(wvlt_maxLvl))
+  allocate(iCellsInt(wvlt_maxLvl))
+  allocate(jCellsInt(wvlt_maxLvl))
+  allocate(kCellsInt(wvlt_maxLvl))
+  allocate(iCellsTot(wvlt_maxLvl))
+  allocate(jCellsTot(wvlt_maxLvl))
+  allocate(kCellsTot(wvlt_maxLvl))
+
+  ! get any block's index limits
+  call Grid_getBlkIndexLimits(1,blkLimits,blkLimitsGC)
+
+  ! compute number of cells on interior of block in each direction
+  iCellsInt(wvlt_maxLvl) = blkLimits(HIGH,IAXIS) - blkLimits(LOW,IAXIS) + 1
+  jCellsInt(wvlt_maxLvl) = blkLimits(HIGH,JAXIS) - blkLimits(LOW,JAXIS) + 1
+  kCellsInt(wvlt_maxLvl) = blkLimits(HIGH,KAXIS) - blkLimits(LOW,KAXIS) + 1
+
+  ! compute number of cells total
+  iCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,IAXIS) - blkLimitsGC(LOW,IAXIS) + 1
+  jCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,JAXIS) - blkLimitsGC(LOW,JAXIS) + 1
+  kCellsTot(wvlt_maxLvl) = blkLimitsGC(HIGH,KAXIS) - blkLimitsGC(LOW,KAXIS) + 1
+
+  ! count the number of cells at every level of refinement (division by 2 each level)
+  do l = wvlt_maxLvl, 1, -1
+    iCellsInt(l) = ceiling( Real(iCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    jCellsInt(l) = ceiling( Real(jCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    kCellsInt(l) = ceiling( Real(kCellsInt(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    iCellsTot(l) = ceiling( Real(iCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    jCellsTot(l) = ceiling( Real(jCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    kCellsTot(l) = ceiling( Real(kCellsTot(wvlt_maxLvl)) / Real(2**(wvlt_maxLvl-l)) )
+    intCells(l) = iCellsInt(l) * jCellsInt(l) * kCellsInt(l)
+    numCells(l) = iCellsTot(l) * jCellsTot(l) * kCellsTot(l)
+  enddo
+
+  ! determine the total number of cells needed for coefficient storage
+  totIntCells = 0
+  totCells = 0
+  do l = 1, wvlt_maxLvl
+    totIntCells = totIntCells + intCells(l)
+    totCells = totCells + numCells(l)
+  enddo
+
+  !------- parent cell indices -------!
+
+  allocate(parentCellIndices1(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = (i + mod(i,2)) / 2
+    parentCellIndices1(i) = ip
+  enddo
+  allocate(parentCellIndices2(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = i
+    do l = wvlt_maxLvl, wvlt_maxLvl-1, -1
+      ip = (ip + mod(ip,2)) / 2
+    enddo
+    parentCellIndices2(i) = ip
+  enddo
+  allocate(parentCellIndices3(iCellsInt(wvlt_maxLvl)))
+  do i = 1, iCellsInt(wvlt_maxLvl)
+    ip = i
+    do l = wvlt_maxLvl, wvlt_maxLvl-2, -1
+      ip = (ip + mod(ip,2)) / 2
+    enddo
+    parentCellIndices3(i) = ip
+  enddo
+
+  !------- pre-computation of hydro flux masks -------!
+
+  ! stores what MR level the hydro sweep takes place on *** this assumes perfectly square/cube blocks
+#if NDIM == 1
+  allocate(hydroSweepLvl(1,1,1,MAXBLOCKS))
+#endif
+
+#if NDIM == 2
+  allocate(hydroSweepLvl(iCellsTot(wvlt_maxLvl),2,1,MAXBLOCKS))
+#endif
+
+!#if NDIM == 3
+!allocate(hydroSweepLvl(iCellsInt(wvlt_maxLvl),iCellsInt(wvlt_maxLvl),3,MAXBLOCKS,3))
+!#endif
+
+  ! allocate arrays that stores number of active interfaces and fluxes
+  allocate(numIntrfcActv(wvlt_maxLvl))
+  allocate(numFluxActv(wvlt_maxLvl))
+
+  ! temporary masks
+  allocate(tmpmask(iCellsTot(wvlt_maxLvl)))
+
+  ! allocate memory for arrays with fixed mappings
+  allocate(intrfcKey(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+  allocate(fluxKey(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+  allocate(fluxMask(iCellsTot(wvlt_maxLvl),wvlt_maxLvl))
+
+  ! initialize mask
+  fluxMask = .false.
+
+  ! loop through hierarchy
+  do lstart = wvlt_maxLvl, 1, -1
+
+    ! initialize temporary masks
+    tmpmask = .false.
+
+    ! counters
+    numflx = 0
+    numintrfc = 0
+
+    ! loop through base grid
+    do i = 1, iCellsInt(1)+1
+
+      ! compute total index on fine grid
+      itot = lmap(1,i) + 4
+
+      ! put in the mask
+      fluxMask(itot,lstart) = .true.
+
+      ! increment counter
+      numflx = numflx + 1
+
+    enddo
+
+    ! loop through hierarchy again
+    do l = 1, lstart-1
+
+      ! loop through cells at current level
+      do i = 1, iCellsInt(l)
+
+      ! compute total index on fine grid
+      itot = lmap(l+1,2*i) + 4
+
+      ! put in the mask
+      fluxMask(itot,lstart) = .true.
+
+      numflx = numflx + 1
+
+      enddo
+
+    enddo
+
+    ! direct flux interfaces now known, now form supporting interface mask
+    do i = 2, iCellsTot(wvlt_maxLvl)-1
+
+      ! check if fluxMask is active
+      if (fluxMask(i,lstart)) then
+
+      ! need interfaces to left and right to be active as well
+      tmpmask(i-1:i+1) = .true.
+
+      endif
+
+    enddo
+
+    ! now count up the number of supporting interfaces active
+    numintrfc = count(tmpmask)
+
+    ! fill in these arrays with index mappings
+    j = 1
+    k = 1
+    do i = 1, iCellsTot(wvlt_maxLvl)
+
+      ! check tmpmask active 
+      if (tmpmask(i)) then
+
+        ! set interface key value
+        intrfcKey(j,lstart) = i
+
+        if (fluxMask(i,lstart)) then
+
+          ! set flux key value
+          fluxKey(k,lstart) = j
+
+          ! increment
+          k = k + 1
+
+        endif
+
+        ! increment counter
+        j = j + 1
+
+      endif
+
+    enddo
+
+    ! set number of interfaces and fluxes
+    numIntrfcActv(lstart) = numintrfc
+    numFluxActv(lstart) = numflx
+
+  enddo
+
+  ! cleanup temporary memory
+  deallocate(tmpmask)
+
+  if ( gr_meshMe==MASTER_PE ) &
+    write(*,'(a)') '[wvlt_init] Multiresolution initialized.'
+
+end subroutine wvlt_init
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90 source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_interface.F90	2021-02-12 23:36:44.554809393 -0500
@@ -0,0 +1,101 @@
+!!****h* source/flashUtilities/wavelet/wvlt_interface
+!!
+!!***
+module wvlt_interface
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+#include "Eos.h"
+
+  interface
+    subroutine wvlt_init() 
+      implicit none
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_finalize()
+      implicit none
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_encodeBlock(lb)
+      implicit none
+      integer, intent(in) :: lb
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildMask(localBlkID)
+      implicit none
+      integer, intent(in) :: localBlkID
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildHydroMask(blockID)
+      implicit none
+      integer, intent(in) :: blockID 
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_buildSourceMask(numCells, numLvls, solnPtr, activeCell, interpCell)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+#if NDIM == 1
+      logical, dimension(numCells,1,1,numLvls), intent(inout) :: activeCell
+      logical, dimension(numCells,1,1,numLvls), intent(inout) :: interpCell
+#endif
+#if NDIM == 2
+      logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: activeCell
+      logical, dimension(numCells,numCells,1,numLvls), intent(inout) :: interpCell
+#endif
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_expandBuffer(localBlkID, optmode)
+      implicit none
+      integer, intent(in) :: localBlkID
+      integer, intent(in), optional :: optmode
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_transform1D(numCells, numLvls, varData, detailCoeffs)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, dimension(numCells), intent(in) :: varData
+      real, dimension(numCells, numLvls), intent(out) :: detailCoeffs
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_transform2D(numCells, numLvls, varData, detailCoeffs)
+      implicit none
+      integer, intent(in) :: numCells, numLvls
+      real, dimension(numCells, numCells), intent(in) :: varData
+      real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+    end subroutine
+  end interface
+
+  interface
+    subroutine wvlt_decompInterior(numCells, numLvls, var, solnPtr, cellData)
+      implicit none
+      integer, intent(in) :: numCells, numLvls, var
+      real, pointer, intent(in) :: solnPtr(:,:,:,:) 
+#if NDIM == 1
+      real, dimension(numCells,1,1,numLvls), intent(inout) :: cellData
+#endif
+#if NDIM == 2
+      real, dimension(numCells,numCells,1,numLvls), intent(inout) :: cellData
+#endif
+    end subroutine
+  end interface
+
+end module wvlt_interface
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_transform1D.F90	2021-02-12 12:25:23.248217796 -0500
@@ -0,0 +1,101 @@
+!!****if* source/flashUtilities/wvlt_transform1D
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!      Performs a one-dimensional wavelet transform on the supplied data. The
+!!      output is a rank 4 array containing the hierarchy of detail
+!!      coefficients.
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_transform1D(numCells, numLvls, varData, detailCoeffs)
+  
+  use wvlt_data, ONLY : iCellsInt, iCellsTot, wvlt_useRelative
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells), intent(in) :: varData
+  real, dimension(numCells, 1, 1, numLvls), intent(inout) :: detailCoeffs
+
+  ! local
+  integer :: l, i, ilo, ihi, ngx, ii
+  real :: uapprox
+  real, dimension(numCells, 1, 1, numLvls) :: cellData
+
+  !------- perform transform on 1D strip of data -------!
+
+  ! call 1D decomposition
+  call wvlt_decomp1D(numCells, numLvls, varData, cellData)
+
+  ! traverse two levels of hierarchy
+  do l = numLvls-1, numLvls-2, -1
+
+    ! number of ghost cells
+    ngx = (iCellsTot(l) - iCellsInt(l)) / 2
+
+    ! loop through interior cells
+    ilo = 1
+    ihi = iCellsInt(l)
+
+    ! check if using relative detail coeff measure
+    if (wvlt_useRelative) then
+
+      do i = ilo, ihi
+
+        ! total block index
+        ii = i + ngx
+
+        ! compute approximate data on fine scale
+        uapprox = cellData(ii,1,1,l) + 0.125e0 * &
+                    (cellData(ii+1,1,1,l) - cellData(ii-1,1,1,l))
+
+        ! compute detail coefficient for right child
+        detailCoeffs(2*i,1,1,l+1) = max(detailCoeffs(2*i,1,1,l+1), &
+                                        abs((cellData(2*ii,1,1,l+1) - uapprox) &
+                                        / max(abs(cellData(2*ii,1,1,l+1)),1.e0)))
+
+        ! compute left child
+        detailCoeffs(2*i-1,1,1,l+1) = detailCoeffs(2*i,1,1,l+1)
+
+      enddo
+
+    else
+
+      do i = ilo, ihi
+
+        ! total block index
+        ii = i + ngx
+
+        ! compute approximate data on fine scale
+        uapprox = cellData(ii,1,1,l) + 0.125e0 * &
+                    (cellData(ii+1,1,1,l) - cellData(ii-1,1,1,l))
+
+        ! compute detail coefficient for right child
+        detailCoeffs(2*i,1,1,l+1) = max(detailCoeffs(2*i,1,1,l+1), &
+                                        abs(cellData(2*ii,1,1,l+1) - uapprox))
+
+        ! compute left child
+        detailCoeffs(2*i-1,1,1,l+1) = detailCoeffs(2*i,1,1,l+1)
+
+      enddo
+
+    endif
+
+  enddo
+
+end subroutine wvlt_transform1D
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90 source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90
--- ../../../archive/FLASH4.6.2-hamr/source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/Grid/GridSolvers/Multiresolution/wvlt_transform2D.F90	2021-02-12 11:50:14.906250547 -0500
@@ -0,0 +1,135 @@
+!!****if* source/flashUtilities/wvlt_transform2D
+!!
+!! NAME
+!!
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!      Performs a two-dimensional wavelet transform on the supplied data. The
+!!      output is a rank 4 array containing the hierarchy of detail
+!!      coefficients.
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine wvlt_transform2D(numCells, numLvls, varData, detailCoeffs)
+  
+  use wvlt_data, ONLY : iCellsInt, jCellsInt, &
+                          iCellsTot, jCellsTot, &
+                          wvlt_useRelative
+
+  implicit none
+
+#include "Flash_mpi.h"
+#include "Flash.h"
+#include "constants.h"  
+
+  ! args
+  integer, intent(in) :: numCells, numLvls
+  real, dimension(numCells, numCells), intent(in) :: varData
+  real, dimension(numCells, numCells, 1, numLvls), intent(inout) :: detailCoeffs
+
+  ! local
+  integer :: l, i, j, itot, jtot, ngx, ngy
+  real :: u0, Qx, Qy, Qxy
+  real, dimension(numCells, numCells, 1, numLvls) :: cellData
+ 
+  !------- perform transform on 2D strip of data -------!
+
+  ! call 2D decomposition
+  call wvlt_decomp2D(numCells, numLvls, varData, cellData)
+
+  ! traverse hierarchy
+  do l = numLvls-1, numLvls-2, -1
+
+    ! compute number of ghost cells at current level
+    ngx = (iCellsTot(l) - iCellsInt(l)) / 2
+    ngy = (jCellsTot(l) - jCellsInt(l)) / 2
+
+    ! loop through interior cells
+    do i = 1, iCellsInt(l)
+
+      ! convert interior index to total index
+      itot = ngx + i
+
+      ! loop through interior j-axis cells
+      do j = 1, jCellsInt(l)
+
+        ! convert interior index to total index
+        jtot = ngy + j
+
+        ! centered value
+        u0 = cellData(itot,jtot,1,l)
+
+        ! compute the terms 'Qx', 'Qy', and 'Qxy' - bihari1997
+        Qx = (-0.125e0) * (cellData(itot+1,jtot,1,l) - cellData(itot-1,jtot,1,l))
+        Qy = (-0.125e0) * (cellData(itot,jtot+1,1,l) - cellData(itot,jtot-1,1,l))
+        Qxy = 0.015625e0 * (cellData(itot+1,jtot+1,1,l) - cellData(itot+1,jtot-1,1,l) &
+                - cellData(itot-1,jtot+1,1,l) + cellData(itot-1,jtot-1,1,l))
+
+        if (wvlt_useRelative) then
+
+          ! compute d^{l+1}_{2i-1,2j-1} (quadrant 3)
+          detailCoeffs(2*i-1,2*j-1,1,l+1) = max(abs((cellData(2*itot-1,2*jtot-1,1,l+1) &
+                                              - (u0 + Qx + Qy + Qxy)) &
+                                              / max(abs(cellData(2*itot-1,2*jtot-1,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i-1,2*j-1,1,l+1))
+
+          ! compute d^{l+1}_{2i,2j-1} (quadrant 4)
+          detailCoeffs(2*i,2*j-1,1,l+1) = max(abs((cellData(2*itot,2*jtot-1,1,l+1) &
+                                              - (u0 - Qx + Qy - Qxy)) &
+                                              / max(abs(cellData(2*itot,2*jtot-1,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i,2*j-1,1,l+1))
+
+
+          ! compute d^{l+1}_{2i-1,2j} (quadrant 2)
+          detailCoeffs(2*i-1,2*j,1,l+1) = max(abs((cellData(2*itot-1,2*jtot,1,l+1) &
+                                              - (u0 + Qx - Qy - Qxy)) &
+                                              / max(abs(cellData(2*itot-1,2*jtot,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i-1,2*j,1,l+1))
+
+
+          ! compute d^{l+1}_{2i,2j} (quadrant 1)
+          detailCoeffs(2*i,2*j,1,l+1) = max(abs((cellData(2*itot,2*jtot,1,l+1) &
+                                              - (u0 - Qx - Qy + Qxy)) &
+                                              / max(abs(cellData(2*itot,2*jtot,1,l+1)),1.e0)), &
+                                              detailCoeffs(2*i,2*j,1,l+1))
+
+        else
+
+          ! compute d^{l+1}_{2i-1,2j-1} 
+          detailCoeffs(2*i-1,2*j-1,1,l+1) = max(abs(cellData(2*itot-1,2*jtot-1,1,l+1) &
+                                              - (u0 + Qx + Qy + Qxy)), &
+                                              detailCoeffs(2*i-1,2*j-1,1,l+1))
+ 
+          ! compute d^{l+1}_{2i,2j-1} 
+          detailCoeffs(2*i,2*j-1,1,l+1) = max(abs(cellData(2*itot,2*jtot-1,1,l+1) &
+                                              - (u0 - Qx + Qy - Qxy)), &
+                                              detailCoeffs(2*i,2*j-1,1,l+1))
+
+
+          ! compute d^{l+1}_{2i-1,2j} 
+          detailCoeffs(2*i-1,2*j,1,l+1) = max(abs(cellData(2*itot-1,2*jtot,1,l+1) &
+                                              - (u0 + Qx - Qy - Qxy)), &
+                                              detailCoeffs(2*i-1,2*j,1,l+1))
+
+
+          ! compute d^{l+1}_{2i,2j} 
+          detailCoeffs(2*i,2*j,1,l+1) = max(abs(cellData(2*itot,2*jtot,1,l+1) &
+                                              - (u0 - Qx - Qy + Qxy)), &
+                                              detailCoeffs(2*i,2*j,1,l+1))
+
+        endif
+
+      enddo
+
+    enddo
+
+  enddo
+
+end subroutine wvlt_transform2D
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/Config source/physics/Hydro/HydroMain/split/PPM/Config
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/Config	2021-02-22 23:57:26.563113166 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/Config	2021-02-14 17:05:20.165818682 -0500
@@ -105,15 +105,25 @@
 PARAMETER omg2                REAL    10.     # PPM dissipation parameter omega2
 PARAMETER igodu               INTEGER 0       # Use Godunov method
 PARAMETER iplm                INTEGER 0       # Use linear profiles 
+PARAMETER interp_6thOrder     	 INTEGER 0       # Use 6th order approximation to interpolate at interface if not 0
+PARAMETER interp_6thC         	 REAL    1.25e0  # Monotonization zone-to-zone jump weighting
+PARAMETER detect_djump        	 REAL    1.e-2   # Density jump detection threshold for steepener
+PARAMETER gridIsUniform          BOOLEAN TRUE    # required for the 6th order method to work
 PARAMETER vgrid               REAL    0.      # Scale factor for grid velocity
 PARAMETER nriem               INTEGER 10      # No. of iterations in Riemann solver
 PARAMETER rieman_tol          REAL    1.0e-5  # Converge factor for Riemann solver
+PARAMETER rieman_tol_abort    	 REAL    1.e-1   # Converge factor for Riemann solver
 PARAMETER cvisc               REAL    0.1     # Artificial viscosity constant
 PARAMETER dp_sh               REAL    0.33    # pressure jump for 1-D shock detection
 PARAMETER ppm_modifystates    BOOLEAN FALSE   # modify states due to gravity?
 PARAMETER leveque             BOOLEAN FALSE   # do LeVeque's method?
 PARAMETER hybrid_riemann      BOOLEAN FALSE   # use HLLE in shocks to remove odd-even decoupling
 PARAMETER charLimiting        BOOLEAN TRUE    # use characteristic variables for slope limiting
+PARAMETER ppmRiemannSolver       STRING "exact"  # exact, AUSMP, AUSMPUP
+PARAMETER ppmRiemannSolverHybrid STRING "HLLE"   # HLLE, AUSMP, AUSMPUP
+PARAMETER forceApproxRiemann     BOOLEAN FALSE   # Force use of the HLLE solver for all flux calculations.
+PARAMETER use_flattening         BOOLEAN TRUE    # toggle profile flattening
+PARAMETER enr_flattening         BOOLEAN FALSE   # consider total energy when flattening
 
 D ppmEnerFluxConstructionMeth selects a method for constructing energy
 D & fluxes, for total (internal+kinetic) energy,
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90	2021-02-22 23:57:38.574465084 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/avisco.F90	2021-02-14 15:24:26.399762300 -0500
@@ -413,7 +413,7 @@
            dxtb  = 3.0 / ( 2.0 * (xtop**3 - xbot**3) )
            dzrl  = 0.5 / ( xzn(j) * (zrgt - zlft) ) 
            do i = nzni, nznf
-              sinth   = max(sin( xl(i) ),1e-6)
+              sinth   = sin( xl(i) )
               avis(i) = (sin(x(i)) * u(i) - sin(x(i-1)) * u(i-1)) /        &
                    (xzn(j) * sinth * (x(i) - x(i-1)) ) +                   &
                    (xtop**2 * (uttp(i) + uttp(i-1)) -                      &
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90	2021-02-22 23:57:38.574465084 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/cma_flatten.F90	2021-02-14 15:24:26.405762475 -0500
@@ -42,7 +42,7 @@
 
 
 subroutine cma_flatten(numIntCells, numCells,guard, xn, xnl, xnr, dxn, xn6)
-  use Hydro_data, ONLY : hy_numXn
+  use Hydro_data, ONLY : hy_numXn, hy_smallx
   implicit none
 
 #include "Flash.h"
@@ -51,9 +51,9 @@
   real, intent(IN),    DIMENSION(numCells, hy_numXn) :: xn
   real, intent(INOUT), DIMENSION(numCells, hy_numXn) :: xnl, xnr, dxn, xn6
 
-  integer :: i, n
-
-  real :: tmp, w_ln, w_rn
+  integer         :: i, n
+  real, parameter :: xjflat = 0.25e0
+  real            :: tmp, w_ln, w_rn
 
   real, DIMENSION(numCells) :: extrema, flatten
   real, DIMENSION(numCells) :: s_L_plus, s_L_minus, s_R_plus, s_R_minus
@@ -68,9 +68,9 @@
 
      do i = guard-1, guard+numIntCells+2
         if ( (xn(i+1,n) - xn(i,n))*(xn(i,n) - xn(i-1,n)) < 0.e0) then
-           extrema(i) = 1.0
+           extrema(i) = 1.e0
         else
-           extrema(i) = 0.0
+           extrema(i) = 0.e0
         endif
      enddo
 
@@ -79,8 +79,8 @@
 ! is an extrema in one of its neighbors and NOT in zone i too.
 
      do i = guard, guard+numIntCells+1
-        flatten(i) = 0.5*max(extrema(i-1), 2.0*extrema(i), extrema(i+1))
-        flatten(i) = min(1.0, flatten(i))
+        flatten(i) = 0.5e0*max(extrema(i-1), 2.e0*extrema(i), extrema(i+1))
+        flatten(i) = min(1.e0, flatten(i))
      enddo
 
 ! Now flatten(i) is > 0 if we are to apply flattening in zone i.  It is
@@ -91,14 +91,14 @@
 ! Apply Eq. 14
 
      do i = guard, guard+numIntCells+1
-        if (flatten(i) > 0.0) then
-           tmp = 1.0 - flatten(i)
+        if (flatten(i) > 0.e0) then
+           tmp = 1.e0 - flatten(i)
            
            xnl(i,n) = flatten(i)*xn(i,n) + tmp*xnl(i,n)
            xnr(i,n) = flatten(i)*xn(i,n) + tmp*xnr(i,n)
            
            dxn(i,n) = xnr(i,n) - xnl(i,n)
-           xn6(i,n) = 6.0*xn(i,n) - 3.0*(xnl(i,n) + xnr(i,n))
+           xn6(i,n) = 6.e0*xn(i,n) - 3.e0*(xnl(i,n) + xnr(i,n))
         endif
      enddo
 
@@ -111,28 +111,28 @@
 
 ! Start by computing two sums, at each interface, Eq. 15.
   do i = guard, guard+numIntCells+1
-     s_L_plus(i) = 0.0
-     s_L_minus(i) = 0.0
+     s_L_plus(i)  = 0.e0
+     s_L_minus(i) = 0.e0
 
-     s_R_plus(i) = 0.0
-     s_R_minus(i) = 0.0
+     s_R_plus(i)  = 0.e0
+     s_R_minus(i) = 0.e0
   enddo
 
   do n = 1, NSPECIES
      do i = guard, guard+numIntCells+1
-        s_L_plus(i)  = s_L_plus(i)  + max(0.0, xnl(i,n) - xn(i,n))
-        s_L_minus(i) = s_L_minus(i) + max(0.0, xn(i,n) - xnl(i,n))
+        s_L_plus(i)  = s_L_plus(i)  + max(0.e0, xnl(i,n) - xn (i,n))
+        s_L_minus(i) = s_L_minus(i) + max(0.e0, xn (i,n) - xnl(i,n))
         
-        s_R_plus(i)  = s_R_plus(i)  + max(0.0, xnr(i,n) - xn(i,n))
-        s_R_minus(i) = s_R_minus(i) + max(0.0, xn(i,n) - xnr(i,n))
+        s_R_plus(i)  = s_R_plus(i)  + max(0.e0, xnr(i,n) - xn (i,n))
+        s_R_minus(i) = s_R_minus(i) + max(0.e0, xn (i,n) - xnr(i,n))
      enddo
   enddo
 
   do i = guard, guard+numIntCells+1
-     delta_L_min(i) = min(s_L_plus(i), s_L_minus(i))
+     delta_L_min(i) = min(s_L_plus(i), s_L_minus(i)) + hy_smallx
      delta_L_max(i) = max(s_L_plus(i), s_L_minus(i))
   
-     delta_R_min(i) = min(s_R_plus(i), s_R_minus(i))
+     delta_R_min(i) = min(s_R_plus(i), s_R_minus(i)) + hy_smallx
      delta_R_max(i) = max(s_R_plus(i), s_R_minus(i))
   enddo
 
@@ -140,21 +140,34 @@
 ! for each abundance
   do n = 1, NSPECIES
      do i = guard, guard+numIntCells+1
-        sgn_L(i,n) = 0.5*abs(sign(1.0, xnr(i,n) - xnl(i,n)) - &
-                             sign(1.0,s_L_plus(i) - s_L_minus(i)))
+        sgn_L(i,n) = 0.5e0*abs( sign(1.e0, xnr(i,n)    - xnl(i,n)    ) &
+                               -sign(1.e0, s_L_plus(i) - s_L_minus(i)))
 
-        sgn_R(i,n) = 0.5*abs(sign(1.0, xnr(i,n) - xnl(i,n)) + &
-                             sign(1.0,s_R_plus(i) - s_R_minus(i)))
+        sgn_R(i,n) = 0.5e0*abs(sign(1.e0, xnr(i,n) - xnl(i,n)) + &
+                               sign(1.e0,s_R_plus(i) - s_R_minus(i)))
 
      enddo
   enddo
 
 ! now, fix up the interface values
   do i = guard, guard+numIntCells+1
-     w_L(i) = max(0.0, min(1.0, 0.25*(delta_L_max(i) - delta_L_min(i))/ &
-                                      delta_L_min(i)))
-     w_R(i) = max(0.0, min(1.0, 0.25*(delta_R_max(i) - delta_R_min(i))/ &
-                                      delta_R_min(i)))
+
+     if ( delta_L_min(i) < 1.e2*tiny(1.e0) ) then
+        write(*,*) ' delta_L_min ',i,delta_L_min(i)
+        write(*,'(a,10es10.2)') 'xnl ',(xnl(i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xn  ',(xn (i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xnr ',(xnr(i,n),n=1,NSPECIES)
+     end if
+     w_L(i) = max(0.e0, min(1.e0, xjflat*(delta_L_max(i) - delta_L_min(i)) &
+                                        /delta_L_min(i)))
+     if ( delta_R_min(i) < 1.e2*tiny(1.e0) ) then
+        write(*,*) ' delta_R_min ',i,delta_R_min(i)
+        write(*,'(a,10es10.2)') 'xnl ',(xnl(i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xn  ',(xn (i,n),n=1,NSPECIES)
+        write(*,'(a,10es10.2)') 'xnr ',(xnr(i,n),n=1,NSPECIES)
+     end if
+     w_R(i) = max(0.e0, min(1.e0, xjflat*(delta_R_max(i) - delta_R_min(i)) &
+                                        /delta_R_min(i)))
   enddo
 
   do n = 1, NSPECIES
@@ -162,11 +175,11 @@
         w_Ln = sgn_L(i,n)*w_L(i)
         w_Rn = sgn_R(i,n)*w_R(i)
 
-        xnl(i,n) = w_Ln*xn(i,n) + (1.0 - w_Ln)*xnl(i,n)
-        xnr(i,n) = w_Rn*xn(i,n) + (1.0 - w_Rn)*xnr(i,n)
+        xnl(i,n) = w_Ln*xn(i,n) + (1.e0 - w_Ln)*xnl(i,n)
+        xnr(i,n) = w_Rn*xn(i,n) + (1.e0 - w_Rn)*xnr(i,n)
         
         dxn(i,n) = xnr(i,n) - xnl(i,n)
-        xn6(i,n) = 6.0*xn(i,n) - 3.0*(xnl(i,n) + xnr(i,n))
+        xn6(i,n) = 6.e0*xn(i,n) - 3.e0*(xnl(i,n) + xnr(i,n))
      enddo
   enddo
 
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Config	2021-02-15 15:55:06.874067566 -0500
@@ -0,0 +1,73 @@
+D hy_renormalizeSpecies            species renormalization
+PARAMETER hy_renormalizeSpecies     BOOLEAN  true
+
+D hy_limitSpecies                  species limiting
+PARAMETER hy_limitSpecies     BOOLEAN  true
+
+D hy_speciesSumTolerance           warning threshold for species normalization error
+PARAMETER hy_speciesSumTolerance    REAL     1.e-8    [0 to ]
+
+D hy_speciesSumToleranceAbort      abort threshold for species normalization error
+PARAMETER hy_speciesSumToleranceAbort           REAL     1.e-4    [0 to ]
+
+D hy_renormalizeMassScalars        mass scalars renormalization
+PARAMETER hy_renormalizeMassScalars   BOOLEAN  false
+
+D hy_limitMassScalars              mass scalars limiting
+PARAMETER hy_limitMassScalars       BOOLEAN  false
+
+D hy_massScalarsSumTolerance       warning threshold for mass scalars normalization error
+PARAMETER hy_massScalarsSumTolerance      REAL    HUGE(1.e0)
+
+D hy_massScalarsSumToleranceAbort  abort threshold for mass scalars normalization error
+PARAMETER hy_massScalarsSumToleranceAbort REAL    HUGE(1.e0)
+
+D cfl            Courant factor
+PARAMETER cfl           REAL    0.8e0   # Courant factor
+
+D cfl_init      initial Courant factor: if non-zero the initial timestep will set to cfl_init Courant factor
+PARAMETER cfl_init     REAL     -1.e0
+
+D cfl_crit      highest allowed Courant factor before automatic timestep reduction kicks in
+PARAMETER cfl_crit     REAL     0.9e0
+
+D cfl_factor_min the smallest allowed cfl in the process of automatic timestep reduction
+PARAMETER cfl_factor_min REAL 0.
+
+D cfl_dynamical  use measured effective Courant factor to additionally limit timestep
+PARAMETER cfl_dynamical BOOLEAN FALSE
+
+D UnitSystem  System of Units
+PARAMETER UnitSystem  STRING   "none"      # System of Units
+
+D use_cma_flattening use the flattening procedure for the abundances as  
+D &                  described in the CMA paper
+
+PARAMETER use_steepening      BOOLEAN TRUE    # toggle the contact steepening
+PARAMETER use_cma_flattening  BOOLEAN FALSE   # use the CMA flattening procedure
+PARAMETER use_cma_steepening  BOOLEAN FALSE   # use the CMA steepening procedure
+PARAMETER use_cma_advection   BOOLEAN FALSE   # use the CMA advection with partial masses being primary variables
+
+PARAMETER xl_boundary_noflow  BOOLEAN FALSE   # noflow conditions (force advection velocities to zero)
+PARAMETER xr_boundary_noflow  BOOLEAN FALSE
+PARAMETER yl_boundary_noflow  BOOLEAN FALSE
+PARAMETER yr_boundary_noflow  BOOLEAN FALSE
+PARAMETER zl_boundary_noflow  BOOLEAN FALSE
+PARAMETER zr_boundary_noflow  BOOLEAN FALSE
+
+USESETUPVARS threadBlockList, threadWithinBlock
+IF threadBlockList
+   PARAMETER threadHydroBlockList BOOLEAN TRUE
+ELSE
+   PARAMETER threadHydroBlockList BOOLEAN FALSE
+ENDIF
+
+IF threadWithinBlock
+   PARAMETER threadHydroWithinBlock BOOLEAN TRUE
+ELSE
+   PARAMETER threadHydroWithinBlock BOOLEAN FALSE
+ENDIF
+
+# multiresolution solver-adaptive parameters
+PARAMETER mrppm_iord INTEGER 3 [1 to 3]
+PARAMETER mrppm_simplemask BOOLEAN TRUE
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/detect.F90	2021-02-14 15:24:26.400762329 -0500
@@ -42,9 +42,9 @@
 !!
 !!***
 
-subroutine detect(numIntCells, numCells, al,a,ar,smalla,rho,p,game,dx,x)
+subroutine detect( numIntCells, numCells, al, a, ar, smalla, rho, p, game, dx, x )
 
-  use Hydro_data, ONLY: hy_small, hy_dela
+  use Hydro_data, ONLY: hy_small, hy_dela, hy_detect_djump
 
   implicit none
 
@@ -54,24 +54,22 @@
   real, dimension(numCells) ::  scrch1, scrch2, scrch3
   real, intent(IN) :: smalla
   integer :: i,numIntCells5,numIntCells6,numIntCells7,numIntCells8
-  
-
 
-    ! the following parameters are set as in Colella and
-    ! Woodward (JCP, 54 (1984), 174), Eqs. 1.17 and 3.2
+  ! the following parameters are set as in Colella and
+  ! Woodward (JCP, 54 (1984), 174), Eqs. 1.17 and 3.2
 
   real, PARAMETER :: eta1 = 20.e0, eta2 = 0.05e0, epsln = 0.01e0, ak0 = 0.1e0
 
   real :: tmp1, tmp2, tmp3
 
-    !------------------------------------------------------------------------------
+  !------------------------------------------------------------------------------
 
   numIntCells5 = numIntCells + 5
   numIntCells6 = numIntCells + 6
   numIntCells7 = numIntCells + 7
   numIntCells8 = numIntCells + 8
 
-! compute some common factors      
+  ! compute some common factors      
 
   do  i = 2, numIntCells7
      scrch1(i) = dx(i) + dx(i-1)
@@ -87,8 +85,8 @@
      scrch1(i) = scrch1(i) * scrch1(i) * scrch1(i)
   end do
 
-! compute {\tilde \eta (i)} as given in the expression at the top of page 181
-! in Colella & Woodward
+  ! compute {\tilde \eta (i)} as given in the expression at the top of page 181
+  ! in Colella & Woodward
   
   do i = 3, numIntCells5
      scrch3(i) = (scrch2(i-1) - scrch2(i+1)) * (scrch1(i) + scrch1(i+1))
@@ -101,29 +99,29 @@
      
      scrch3(i) = scrch3(i) / ((x(i+1) - x(i-1)) * tmp3)
 
-! scrch2 and scrch3 now contain finite difference approximations
-! to the second and third derivativess of a.
+     ! scrch2 and scrch3 now contain finite difference approximations
+     ! to the second and third derivativess of a.
 
-! apply the first constaint on {\tidle \eta (i) as given in Eq. 1.17
+     ! apply the first constaint on {\tidle \eta (i) as given in Eq. 1.17
 
      if (scrch2(i-1)*scrch2(i+1) >= 0.e0) scrch3(i) = 0.e0
 
-! apply the second constraint
+     ! apply the second constraint
 
-     tmp3 = epsln * min(a(i+1),a(i-1)) - abs(a(i+1) - a(i-1))
+     tmp3 = hy_detect_djump * min(a(i+1),a(i-1)) - abs(a(i+1) - a(i-1))
      
      if (tmp3 >= 0.e0) scrch3(i) = 0.e0
      
      scrch3(i) = max(0.e0, min(1.e0, eta1 * (scrch3(i) - eta2) ))
      
-! add an addition constraint (Eq. 3.2) to detect contact discontinuities
+     ! add an addition constraint (Eq. 3.2) to detect contact discontinuities
 
      tmp1 = abs (p(i+1)   - p(i-1)  ) / min (p(i+1),   p(i-1)  )
      tmp2 = abs (rho(i+1) - rho(i-1)) / min (rho(i+1), rho(i-1))
      
      if (game(i)*ak0*tmp2-tmp1 < 0.e0) scrch3(i) = 0.e0
 
-!  scrch3 now contains the contact steepening coefficient
+     !  scrch3 now contains the contact steepening coefficient
 
      tmp1 = a(i-1) + 0.5e0 * hy_dela(i-1)
      tmp2 = a(i+1) - 0.5e0 * hy_dela(i+1)
@@ -131,7 +129,6 @@
      al(i) = al(i) + (tmp1 - al(i)) * scrch3(i)
      ar(i) = ar(i) + (tmp2 - ar(i)) * scrch3(i)
   end do
-  
-  return
+
 end subroutine detect
   
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/flaten.F90	2021-02-14 15:24:26.404762445 -0500
@@ -1,93 +1,90 @@
 !!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/flaten
 !!
 !! NAME
-!! 
+!!
 !!  flaten
 !!
 !! SYNOPSIS
 !!
-!! 
+!!
 !!  call flaten(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells, 
-!!              real(IN)    :: u(numCells), 
-!!              real(IN)    :: p(numCells),  
-!!              real(OUT)   :: flatn(numCells), 
-!!              real(OUT)   :: flatn1(numCells))
+!!              integer(IN) :: numCells,
+!!              real(IN)    :: u(numCells),
+!!              real(IN)    :: p(numCells),
+!!              real(OUT)   :: flatn(numCells),
+!!
 !!
-!! 
 !! DESCRIPTION
-!!  
+!!
 !!  Flaten zone structure in regions where shocks are too thin.
-!!  This version of subroutine FLATEN only uses the simplest form 
-!!  of dissipation as described in the appendix of Colella and Woodward 
-!!  (JCP, 54 (1984), 174). Therefore the only constants required are 
+!!  This version of subroutine FLATEN only uses the simplest form
+!!  of dissipation as described in the appendix of Colella and Woodward
+!!  (JCP, 54 (1984), 174). Therefore the only constants required are
 !!  omg1, omg2 and epsiln, which are read in.
 !!
-!!  The "standard" values of the constants are:                  
-!!                                                                     
-!!          epsiln = 0.33                                             
-!!                                                                     
-!!          omg1   = 0.75                                             
-!!          omg2   = 10.0                                             
-!!          sig1   = 0.50                                             
-!!          sig2   = 1.00                                             
-!!          ak1    = 2.00                                             
-!!          ak2    = 0.01                                             
-!!                                                                     
-!!          wig1   = 2.00                                             
-!!          wig2   = 0.00           for 1-d                           
-!!                   0.10           for 2-d                           
-!!          wig3   = 0.3333 - wig2                                    
-!!                                                                     
+!!  The "standard" values of the constants are:
+!!
+!!          epsiln = 0.33
+!!
+!!          omg1   = 0.75
+!!          omg2   = 10.0
+!!          sig1   = 0.50
+!!          sig2   = 1.00
+!!          ak1    = 2.00
+!!          ak2    = 0.01
+!!
+!!          wig1   = 2.00
+!!          wig2   = 0.00           for 1-d
+!!                   0.10           for 2-d
+!!          wig3   = 0.3333 - wig2
+!!
 !!
 !!
 !!
 !! ARGUMENTS
 !!
 !! numIntCells :
-!! numCells : 
+!! numCells :
 !! u :
 !! p :
 !! flatn :
-!! flatn1 :
 !!
-!! 
+!! NOTES
+!!
+!!  Modified March 16, 2016 by TAH: Added the contribution from the total energy steepness to
+!!    the omega calculation (C&W A.9)
 !!
 !!***
 
-subroutine flaten(numIntCells,numCells, &
-                  u, p,  flatn, flatn1)
+subroutine flaten( numIntCells, numCells, u, p, e, flatn )
 
-  use Hydro_data, ONLY: hy_epsiln, hy_omg1, hy_omg2,&
-                        hy_igodu,hy_dp,hy_du,hy_smallu
-                        
-  
-  implicit none
+  use Hydro_data, ONLY: hy_burnShocks, hy_epsiln, hy_omg1, hy_omg2, &
+                        hy_dp, hy_du, hy_smallu, &
+                        hy_enrFlattening
 
-  integer, INTENT(IN):: numIntCells, numCells
-  real,  INTENT(IN), DIMENSION(numCells) :: u, p
-  real,  INTENT(OUT), DIMENSION(numCells) :: flatn, flatn1
+  implicit none
 
+  integer, INTENT(IN)                       :: numIntCells, numCells
+  real,    INTENT(IN),  DIMENSION(numCells) :: u, p, e
+  real,    INTENT(OUT), DIMENSION(numCells) :: flatn
 
-  real,dimension(numCells) :: scrch1,scrch2,scrch3, scrch4
+  real, dimension(numCells) :: scrch1,scrch2,scrch3
   integer :: i, numIntCells5, numIntCells6, numIntCells7, numIntCells8
   real ::  utest, dutest, dp2, dptest, ptest, dpp, ftilde_up
-  
+  real ::  de1, de2, dee
+
+  !----------------------------------------
+
   numIntCells5 = numIntCells + 5
   numIntCells6 = numIntCells + 6
   numIntCells7 = numIntCells + 7
   numIntCells8 = numIntCells + 8
-  
-  do i = 1, numIntCells8
-     flatn (i) = 0.e0
-     flatn1(i) = 1.e0
-  end do
 
   do i = 2, numIntCells7
 
-! compute the w_j parameter in Eq. A.1 in Colella & Woodward.  w_j is equal to
-! 1 if the jth zone is inside a pressure and velocity jump in the sweep direction,
-! in a manner consistent with a shock; storage for this in hy_shockd removed - KW
+     ! compute the w_j parameter in Eq. A.1 in Colella & Woodward.  w_j is equal to
+     ! 1 if the jth zone is inside a pressure and velocity jump in the sweep direction,
+     ! in a manner consistent with a shock
 
      hy_dp(i)      = p(i+1) - p(i-1)
      hy_du(i)      = u(i+1) - u(i-1)
@@ -99,60 +96,76 @@
      else
         dutest = 0.e0
      endif
-     
-     if (scrch1(i) .LT. 0.e0) then 
+
+     if (scrch1(i) .LT. 0.e0) then
         scrch1(i) = 1.e0
      else
         scrch1(i) = 0.e0
      endif
-     
+
      if (hy_du(i) .GE. 0.e0) scrch1(i) = 0.e0
-     
+
      if (dutest .EQ. 0.e0) scrch1(i) = 0.e0
-     
   end do
-  
-  do i = 3, numIntCells6
-
-       ! hy_shockd removed from here, use Hydro_detectShock instead - KW
 
+  !----------------
+  ! shock detection
 
-       ! compute ftilde, using Eq. A.2 in Colella & Woodward
+  if ( hy_enrFlattening ) then
 
-     dp2 = p(i+2) - p(i-2)
-     
-     if ( abs(dp2) .GT. 0.e0 ) then
-        dpp = hy_dp(i) / dp2 - hy_omg1
-     else
+     ! TAH: Original code only considered dpp in the steepness calculation.
+     !      We extend this to include the total energy steepness as well.
+     !      Additionally, we only flatten when the fields are monotonic
+     !      (i.e. not a saw-tooth profile).
+
+     do i = 3, numIntCells6
+        dp2 = p(i+2) - p(i-2)
+        de2 = e(i+2) - e(i-2)
+        de1 = e(i+1) - e(i-1)
         dpp = 0.e0
-     end if
-     
-     scrch3(i) = scrch1(i) * max (0.e0, dpp * hy_omg2)
-  end do
+        dee = 0.e0
+        if(abs(dp2)>TINY(1.e0)) then
+           if( (dp2*hy_dp(i)>0.e0) .and. (abs(hy_dp(i))<abs(dp2)) ) dpp = hy_dp(i)/dp2
+        endif
+        if(abs(de2)>TINY(1.e0)) then
+           if( (de2*de1>0.e0) .and. (abs(de1)<abs(de2)) ) dee = de1/de2
+        endif
+        scrch3(i) = scrch1(i) * max(0.e0, hy_omg2*(max(dpp,dee)-hy_omg1))
+     end do
+
+  else
+
+     do i = 3, numIntCells6
+        ! compute ftilde, using Eq. A.2 in Colella & Woodward
+        dp2 = p(i+2) - p(i-2)
+
+        if ( abs(dp2) .GT. 0.e0 ) then
+           dpp = hy_dp(i) / dp2 - hy_omg1
+        else
+           dpp = 0.e0
+        end if
+        scrch3(i) = scrch1(i) * max (0.e0, dpp * hy_omg2)
+     end do
+
+  end if
 
-! select upstream value
+  ! select upstream value
 
   do i = 4, numIntCells5
-     if ( hy_dp(i) .LT. 0.e0 ) then
+     if ( hy_dp(i) < 0.e0 ) then
         ftilde_up = scrch3(i+1)
-     else if ( hy_dp(i) .EQ. 0.e0 ) then
+     else if ( hy_dp(i) == 0.e0 ) then
         ftilde_up = scrch3(i)
      else
         ftilde_up = scrch3(i-1)
      endif
 
-! select the maximum flattening
-
+     ! select the maximum flattening
      flatn(i) = max (scrch3(i), ftilde_up)
+  end do
+
+  do i = 4, numIntCells5
      flatn(i) = max (0.e0, min (1.e0, flatn(i)))
-     
-     ! select Godunov method, if desired
-     
-     flatn (i) = flatn(i) * (1.e0 - hy_igodu) + hy_igodu
-     
-     flatn1(i) = 1.e0 - flatn(i)
   end do
-  
-  return
-end subroutine flaten
 
+end subroutine flaten
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_data.F90	2021-02-14 18:59:36.169459564 -0500
@@ -0,0 +1,223 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_data
+!!
+!! NAME
+!!
+!!  Hydro_data
+!!
+!!
+!! SYNOPSIS
+!!
+!!  use Hydro_data
+!!
+!!
+!! DESCRIPTION
+!!
+!!***
+
+
+module Hydro_data
+
+#include "Flash.h"
+#include "constants.h"
+
+  !!*****Runtime parameters*****
+  logical, save :: hy_fluxCorrect,       &
+                   hy_hybridRiemann,     &
+                   hy_useGravity,        &
+                   hy_burnShocks,        &
+                   hy_charLimiting,      &
+                   hy_forceApproxRiemann
+
+  logical ,save :: hy_renormalizeSpecies,      hy_limitSpecies,               &
+                   hy_renormalizeMassScalars,  hy_limitMassScalars
+  real, save    :: hy_speciesSumTolerance,     hy_speciesSumToleranceAbort,   &
+                   hy_massScalarsSumTolerance, hy_massScalarsSumToleranceAbort
+
+  integer, save :: hy_geometry, &
+                   hy_irenorm, &
+                   hy_eosMode,  &
+                   hy_eosModeAfter, &
+                   hy_meshMe, hy_meshNumProcs
+
+  integer, save :: hy_ppmEintFluxConstructionMeth = 0
+  integer, save :: hy_ppmEnerFluxConstructionMeth = 0
+  integer, save :: hy_ppmEintCFluxConstructionMeth = 0
+  integer, save :: hy_ppmEnerCFluxConstructionMeth = 0
+
+  integer, save, dimension(MDIM) :: hy_dirGeom
+
+  real, save :: hy_cfl, hy_cflInit, &
+                hy_cfl_crit,        &
+                hy_cfl_factor_min,  &
+                hy_dp_sh_md,        &
+                hy_cvisc,           &
+                hy_epsiln,          &
+                hy_eintSwitch,      &
+                hy_omg1,            &
+                hy_omg2,            &
+                hy_vgrid
+
+  logical,save :: hy_useHydro, hy_updateHydroFluxes, &
+                  hy_useDiffuse
+
+
+  !--- TAH: Added runtime selection of Riemann solvers (April 6, 2016)
+  integer, save :: hy_RiemannSolver, hy_RiemannSolverHybrid
+  character(len=MAX_STRING_LENGTH), save :: hy_RiemannSolver_str, hy_RiemannSolverHybrid_str
+
+  !!*****End Runtime parameters*****
+
+
+  !!*****Directly Derived from Runtime parameters*****
+  integer, save :: hy_transverseStencilWidth
+
+  !!*****End Directly Derived from Runtime parameters*****
+
+  ! Maybe should become a runtime parameter.
+  logical, parameter :: hy_alwaysCallDetectShock = .FALSE. !.TRUE.
+
+  logical, save :: hy_movingGrid
+
+  !!AJG CFL violation diagnostics
+  integer, parameter :: CW_STATES=1, CW_DIV=CW_STATES+1, CW_FLX=CW_DIV+1
+  logical, save :: hy_cfl_warning(CW_FLX)
+  real, save :: hy_cfl_max(CW_FLX)
+  logical, save :: hy_cfl_dynamical
+  real, save :: hy_cfl_factor
+
+  !!*****Constants database
+  real,    save :: hy_pi
+
+
+  integer, parameter :: hy_numXN     = NSPECIES+NMASS_SCALARS
+  integer, parameter :: hy_numMS     = NMASS_SCALARS
+  !!******** PPM KERNEL DATA STRUCTURES SCALARS************
+
+  !! - in PPMData
+  integer, save :: hy_igodu, hy_nriem, hy_iplm, hy_interp_6thOrder
+  real, save    :: hy_small, hy_smallu, hy_smallp, &
+                   hy_smlrho, hy_smallx, hy_dp_sh, &
+                   hy_riemanTol, hy_riemanTolAbort, &
+                   hy_interp_6thC, hy_detect_djump
+  logical, save :: hy_ppmModifyStates, hy_leveque,  &
+                   hy_useFlattening,            &
+                   hy_enrFlattening,            &
+                   hy_useSteepening,            &
+                   hy_useCmaAdvection,          &
+                   hy_useCmaFlattening,         &
+                   hy_useCmaSteepening,         &
+                   hy_gridIsUniform,            &
+                   hy_useCellAreasForFluxes
+
+  logical, save :: hy_rieman_printDiag = .false.
+
+  logical, save :: hy_xl_boundary_noflow, hy_xr_boundary_noflow, &
+                   hy_yl_boundary_noflow, hy_yr_boundary_noflow, &
+                   hy_zl_boundary_noflow, hy_zr_boundary_noflow
+
+  integer,parameter :: lowerFace=1,upperFace=2
+  integer, dimension(2,MDIM*2) :: neigh
+  !!******** PPM KERNEL DATA STRUCTURES ************
+
+  ! interpolation constants
+  real, save :: hy_cl1 = 0.3125e0
+  real, save :: hy_cl2 = 0.9375e0
+  real, save :: hy_cl3 = -0.3125e0
+  real, save :: hy_cl4 = 0.0625e0
+
+  real, save :: hy_cr1 = 0.0625e0
+  real, save :: hy_cr2 = -0.3125e0
+  real, save :: hy_cr3 = 0.9375e0
+  real, save :: hy_cr4 = 0.3125e0
+
+  real, save :: hy_cc1 = -0.0625e0
+  real, save :: hy_cc2 = 0.5625e0
+  real, save :: hy_cc3 = 0.5625e0
+  real, save :: hy_cc4 = -0.0625e0
+
+  ! multiresolution parameters
+  logical , save :: hy_simpleMask
+  integer, save :: hy_lstart, hy_iord
+  real, save :: hy_numAdaptiveFlux = 0
+  real, save :: hy_numTotFlux = 0
+
+  !!******** PPM KERNEL DATA STRUCTURES ************
+
+#ifdef FIXEDBLOCKSIZE
+  logical, save, dimension(MAXCELLS) :: hy_fluxmask
+  real,save, DIMENSION(MAXCELLS) :: hy_dela  , &
+                                    hy_dp    , hy_du    , hy_dut   , hy_dutt  , &
+                                    hy_drho  , hy_dgame , hy_dgamc , hy_dgrav , &
+                                    hy_p6    , hy_u6    , hy_ut6   , hy_utt6  , &
+                                    hy_rho6  , hy_game6 , hy_gamc6 , hy_grav6 , &
+                                    hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic,&
+                                    hy_gravl , hy_gravr,                     &
+                                    hy_clft  , hy_plft  , hy_uttlft,         &
+                                    hy_ulft  , hy_vlft  , hy_utlft ,         &
+                                    hy_crght , hy_prght , hy_vrght ,         &
+                                    hy_urght , hy_utrght, hy_uttrgt,         &
+                                    hy_gmelft, hy_gmergt,                    &
+                                    hy_gmclft, hy_gmcrgt,                    &
+                                    hy_deint,  hy_eint6,                     &
+                                    hy_eLft,   hy_eRght,                     &
+                                    hy_eiLft,  hy_eiRght,                    &
+                                    hy_flatn,  hy_cds
+
+  real, save, DIMENSION(MAXCELLS,hy_numXN) :: hy_dxn, hy_xn6 ,hy_xnlft, hy_xnrght
+  real,save, dimension(2,NYB,NZB,MAXBLOCKS) :: hy_xarea,hy_xdtdx,&
+       hy_xgrav,hy_xngrav,hy_xfict
+  real,save, dimension(NXB,2,NZB,MAXBLOCKS) :: hy_yarea,hy_ydtdy,&
+       hy_ygrav,hy_yngrav,hy_yfict
+  real,save, dimension(NXB,NYB,2,MAXBLOCKS) :: hy_zarea,hy_zdtdz,&
+       hy_zgrav,hy_zngrav,hy_zfict
+  real,save, dimension(2,2,NYB,NZB,MAXBLOCKS) :: hy_xareaAtFaces
+  real,save, dimension(2,NXB,2,NZB,MAXBLOCKS) :: hy_yareaAtFaces
+  real,save, dimension(2,NXB,NYB,2,MAXBLOCKS) :: hy_zareaAtFaces
+
+#else
+  integer, save :: numCells, iguard, jguard, kguard
+  real,save,allocatable,dimension(:) :: hy_dela, &
+                           hy_dp , hy_du , hy_dut, hy_dutt, &
+                           hy_drho, hy_dgame, hy_dgamc, hy_dgrav, &
+                           hy_p6, hy_u6 , hy_ut6 , hy_utt6 , &
+                           hy_rho6 , hy_game6 , hy_gamc6 , hy_grav6 , &
+                           hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic,&
+                           hy_gravl, hy_gravr,   &
+                           hy_clft  , hy_plft  , hy_uttlft,   &
+                           hy_ulft  , hy_vlft  , hy_utlft , &
+                           hy_crght , hy_prght , hy_vrght ,         &
+                           hy_urght , hy_utrght, hy_uttrgt, &
+                           hy_gmelft, hy_gmergt, &
+                           hy_gmclft, hy_gmcrgt, &
+                           hy_deint, hy_eint6,   &
+                           hy_eLft,   hy_eRght,  &
+                           hy_eiLft,  hy_eiRght
+
+  real, save, allocatable,dimension(:,:) :: hy_dxn,hy_xn6,hy_xnlft, hy_xnrght
+  real,save, allocatable, dimension(:,:,:,:) :: hy_xarea,hy_xdtdx,&
+       hy_xgrav,hy_xngrav,hy_xfict
+  real,save, allocatable, dimension(:,:,:,:) :: hy_yarea,hy_ydtdy,&
+       hy_ygrav,hy_yngrav,hy_yfict
+  real,save, allocatable, dimension(:,:,:,:) :: hy_zarea,hy_zdtdz,&
+       hy_zgrav,hy_zngrav,hy_zfict
+  real,save, allocatable, dimension(:,:,:,:,:) :: hy_xareaAtFaces, &
+                                                  hy_yareaAtFaces, &
+                                                  hy_zareaAtFaces
+
+#endif
+
+  real,save,allocatable,dimension(:) :: hy_ptrial, hy_perror, hy_wlft, hy_wrght
+
+!! Generated for gravity diagnostic output
+  real, save, dimension(MDIM) :: hy_gravMass, hy_gravMassXYZ, hy_gravMassZYX,&
+                                 hy_gravMassXZY, hy_gravMassYZX,&
+                                 hy_gravMassYXZ, hy_gravMassZXY
+  logical,save,dimension(NUNK_VARS) :: hy_gcMask
+  integer,save :: hy_gcMaskSize=NUNK_VARS
+
+  character(len=6),save :: hy_FluxRepresentation
+  integer, parameter :: hy_numPresFluxes = 1
+  integer, save, target, dimension(hy_numPresFluxes) :: hy_specialFluxVars
+  data hy_specialFluxVars  / 0 /
+
+end module Hydro_data
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_finalize.F90	2021-02-14 15:24:26.404762445 -0500
@@ -0,0 +1,55 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_finalize
+!!
+!! NAME
+!!
+!!  Hydro_finalize
+!!
+!! SYNOPSIS
+!!
+!!  Hydro_finalize()
+!!
+!! DESCRIPTION
+!!
+!!  Deallocates any memory that has been allocated in the Hydro Unit
+!!  and prepares the unit for shutdown
+!!
+!!
+!!***
+
+
+subroutine Hydro_finalize()
+
+  use Hydro_data, ONLY : hy_xarea,hy_xdtdx, hy_xgrav,hy_xngrav,hy_xfict
+  use Hydro_data, ONLY : hy_yarea,hy_ydtdy, hy_ygrav,hy_yngrav,hy_yfict
+  use Hydro_data, ONLY : hy_zarea,hy_zdtdz, hy_zgrav,hy_zngrav,hy_zfict
+  use Hydro_data, ONLY : hy_fluxCorrect
+  use Hydro_data, ONLY : hy_numAdaptiveFlux, hy_numTotFlux
+
+  implicit none
+
+#include "Flash.h"
+
+  print *, "Flux evals: ", hy_numAdaptiveFlux, " of ", hy_numTotFlux
+
+#ifndef FIXEDBLOCKSIZE
+
+
+  if(hy_fluxCorrect) then
+!!     deallocate(hy_xarea)
+!!     deallocate(hy_xngrav)
+!!    deallocate(hy_xgrav)
+!!     deallocate(hy_xdtdx)
+!!     deallocate(hy_xfict)
+!!     deallocate(hy_yarea)
+!!     deallocate(hy_yngrav)
+!!     deallocate(hy_ygrav)
+!!     deallocate(hy_ydtdy)
+!!     deallocate(hy_yfict)
+!!     deallocate(hy_zarea)
+!!     deallocate(hy_zngrav)
+!!     deallocate(hy_zgrav)
+!!     deallocate(hy_zdtdz)
+!!     deallocate(hy_zfict)
+  end if
+#endif
+end subroutine Hydro_finalize
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Hydro_init.F90	2021-02-15 18:17:43.350071336 -0500
@@ -0,0 +1,447 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/Hydro_init
+!!
+!! NAME
+!!
+!!  Hydro_init
+!!
+!!
+!! SYNOPSIS
+!!
+!!  Hydro_init()
+!!
+!!
+!! DESCRIPTION
+!!
+!!  Initialize unit scope variables which are typically the runtime parameters.
+!!  This must be called once by Driver_initFlash.F90 first. Calling multiple
+!!  times will not cause any harm but is unnecessary.
+!!
+!! ARGUMENTS
+!!
+!!
+!!
+!! PARAMETERS
+!!
+!!   These are the runtime parameters used in the split PPM Hydro
+!!   implementation.
+!!
+!!   To see the default parameter values and all the runtime parameters
+!!   specific to your simulation check the "setup_params" file in your
+!!   object directory.
+!!   You might have overwritten these values with the flash.par values
+!!   for your specific run.
+!!
+!!    useHydro [BOOLEAN]
+!!        Should any Hydro calculations be performed?
+!!    updateHydroFluxes [BOOLEAN]
+!!        whether fluxes computed by Hydro should be used to update the solution
+!!    cfl [REAL]
+!!    geometry [STRING]
+!!        Grid geometry
+!!    eosMode [STRING]
+!!        the default Eos mode, usually MODE_DENS_EI,
+!!        where density and energy are provided to
+!!        calculate pressure and temperature
+!!    flux_correct [BOOLEAN]
+!!    hybrid_riemann [BOOLEAN]
+!!    smlrho [REAL]
+!!        Cutoff value for density
+!!    smallp [REAL]
+!!        Cutoff value for pressure
+!!    eintSwitch [REAL]  Defined in Eos Unit
+!!    cvisc [REAL]
+!!        Artificial viscosity constant
+!!    dp_sh_md
+!!    epsiln [REAL]
+!!    burnShocks [BOOLEAN]
+!!    nriem [INTEGER]
+!!    omg1
+!!        PPM dissipation parameter omega1
+!!    omg2
+!!        PPM dissipation parameter omega2
+!!    rieman_tol [REAL]
+!!    small [REAL]
+!!       Generic small value that can be used as floor where needed
+!!    smallu [REAL]
+!!       Cutoff value for velocity
+!!    smallx [REAL]
+!!       Cutoff value for abundances
+!!    vgrid
+!!    ppm_modifystates
+!!    leveque
+!!    igodu [INTEGER]
+!!       Enable Guodunov method instead of PPM if set to 1
+!!    iplm [INTEGER]
+!!       Enable piecewise linear method instead of PPM if set to 1
+!!    use_flattening [BOOLEAN]
+!!    use_steepening [BOOLEAN]
+!!    use_cma_flattening [BOOLEAN]
+!!    use_cma_steepening [BOOLEAN]
+!!    use_cma_advection [BOOLEAN]
+!!    ppmEnerFluxConstructionMeth [INTEGER]
+!!    ppmEintFluxConstructionMeth [INTEGER]
+!!    ppmEnerCompFluxConstructionMeth [INTEGER]
+!!    ppmEnerCompFluxConstructionMeth [INTEGER]
+!!***
+
+subroutine Hydro_init()
+
+  !!These are all the runtime parameters.  First the logicals, then the
+  !! integers, then the reals
+
+  use Hydro_data
+  use Driver_interface, ONLY : Driver_abortFlash
+  use Driver_interface, ONLY : Driver_getMype, Driver_getNumProcs
+  use Logfile_interface, ONLY : Logfile_stampMessage, &
+    Logfile_stampVarMask
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get, &
+    RuntimeParameters_mapStrToInt
+  use Grid_interface, ONLY:  Grid_setFluxHandling
+
+  implicit none
+
+  logical :: useSpecialFluxVar
+  integer :: istat
+
+#include "constants.h"
+#include "Flash.h"
+#include "PPM.h"
+
+  character(len=MAX_STRING_LENGTH) :: str_geometry,eosModeString
+
+  ! Everybody should know these
+  call Driver_getMype(MESH_COMM,hy_meshMe)
+  call Driver_getNumProcs(MESH_COMM,hy_meshNumProcs)
+
+
+  call RuntimeParameters_get("useHydro", hy_useHydro)
+  if (hy_meshMe == MASTER_PE) then
+     if ( hy_useHydro ) then
+        write(*,'(a)') "[Hydro_init] Hydro enabled."
+     else
+        write(*,'(a)') "[Hydro_init] Hydro disabled."
+     end if
+  end if
+  !!hydro_timestep
+  call RuntimeParameters_get ("cfl", hy_cfl)
+  call RuntimeParameters_get ("cfl_init", hy_cflInit)
+  call RuntimeParameters_get ("cfl_crit", hy_cfl_crit)
+  call RuntimeParameters_get ("cfl_dynamical", hy_cfl_dynamical)
+
+  if (hy_cfl_crit<hy_cfl) hy_cfl_crit=hy_cfl*1.01 ! give some margin
+  hy_cfl_factor = 1.e0
+
+  call RuntimeParameters_get ("cfl_factor_min", hy_cfl_factor_min)
+
+  !!**Hydro_sweep RuntimeParameters
+
+  call RuntimeParameters_get ("geometry", str_geometry)
+  call RuntimeParameters_mapStrToInt(str_geometry, hy_geometry)
+
+  call RuntimeParameters_get ("eosMode", eosModeString)
+  call RuntimeParameters_mapStrToInt(eosModeString, hy_eosMode)
+  if(hy_eosMode/=MODE_DENS_EI)&
+       call Driver_abortFlash("Hydro : Wrong Eos mode for PPM")
+
+  call RuntimeParameters_get ("hy_eosModeAfter", eosModeString)
+  call RuntimeParameters_mapStrToInt(eosModeString, hy_eosModeAfter)
+  if(hy_eosModeAfter/=MODE_DENS_EI .AND. &
+       hy_eosModeAfter/=hy_eosMode)&
+       call Driver_abortFlash("Hydro : Wrong Eos mode for After PPM Sweep")
+
+  hy_useGravity = .false.
+#ifdef GRAVITY
+  call RuntimeParameters_get("useGravity", hy_useGravity)
+#endif
+  call RuntimeParameters_get("useDiffuse", hy_useDiffuse)
+
+  !-------------------------
+  ! species error thresholds
+
+  call RuntimeParameters_get("hy_renormalizeSpecies",       hy_renormalizeSpecies )
+  call RuntimeParameters_get("hy_limitSpecies",             hy_limitSpecies )
+  call RuntimeParameters_get("hy_speciesSumTolerance",      hy_speciesSumTolerance )
+  call RuntimeParameters_get("hy_speciesSumToleranceAbort", hy_speciesSumToleranceAbort )
+
+  if ( NSPECIES == 0 ) then
+     if ( hy_limitSpecies .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No species found - disable limiting.'
+     hy_limitSpecies = .false.
+     if ( hy_renormalizeSpecies .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No species found - disable renormalization.'
+     hy_renormalizeSpecies = .false.
+  end if
+
+  !------------------------------
+  ! mass scalars error thresholds
+
+  call RuntimeParameters_get("hy_renormalizeMassScalars",       hy_renormalizeMassScalars )
+  call RuntimeParameters_get("hy_limitMassScalars",             hy_limitMassScalars )
+  call RuntimeParameters_get("hy_massScalarsSumTolerance",      hy_massScalarsSumTolerance )
+  call RuntimeParameters_get("hy_massScalarsSumToleranceAbort", hy_massScalarsSumToleranceAbort )
+
+  if ( NMASS_SCALARS == 0 ) then
+     if ( hy_limitMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars found - disable limiting.'
+     hy_limitMassScalars = .false.
+     if ( hy_renormalizeMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars groups found - disable renormalization.'
+     hy_renormalizeMassScalars = .false.
+  end if
+
+  if ( NMASS_SCALAR_GROUPS == 0 ) then
+     if ( hy_renormalizeMassScalars .and. (hy_meshMe == MASTER_PE) ) write(*,'(a)') '[Hydro_init] Warning: No mass scalars groups found - disable renormalization.'
+     hy_renormalizeMassScalars = .false.
+  end if
+
+  call RuntimeParameters_get("flux_correct",              hy_fluxCorrect)
+  call RuntimeParameters_get("hybrid_riemann",            hy_hybridRiemann)
+  call RuntimeParameters_get("forceApproxRiemann",	  hy_forceApproxRiemann)
+
+  !!**Hydro_updateSolution
+  call RuntimeParameters_get("updateHydroFluxes", hy_updateHydroFluxes)
+  call RuntimeParameters_get("smlrho",            hy_smlrho)
+  call RuntimeParameters_get("smallp",            hy_smallp)
+  call RuntimeParameters_get("eintSwitch",        hy_eintSwitch)
+
+  !!**Hydro_1d needs
+  call RuntimeParameters_get("cvisc",    hy_cvisc)
+  call RuntimeParameters_get("dp_sh_md", hy_dp_sh_md )
+  call RuntimeParameters_get("epsiln",   hy_epsiln)
+
+! Define this ifdef variable in your unit's Config file with PPDEFINE
+#ifdef FLASH_SOURCEBURN
+  call RuntimeParameters_get("burnShocks", hy_burnShocks)
+#else
+  hy_burnShocks = .false.
+#endif
+  call RuntimeParameters_get("nriem",            hy_nriem)
+  call RuntimeParameters_get("omg1",             hy_omg1)
+  call RuntimeParameters_get("omg2",             hy_omg2)
+  call RuntimeParameters_get("rieman_tol",       hy_riemanTol)
+  call RuntimeParameters_get("rieman_tol_abort", hy_riemanTolAbort)
+  call RuntimeParameters_get("small",            hy_small)
+  call RuntimeParameters_get("smallu",           hy_smallu)
+  call RuntimeParameters_get("smallx",           hy_smallx)
+  call RuntimeParameters_get("vgrid",            hy_vgrid)
+
+  !!**PPM inputs
+  call RuntimeParameters_get("ppm_modifystates", hy_ppmModifystates)
+  call RuntimeParameters_get("leveque",          hy_leveque)
+  call RuntimeParameters_get("igodu",            hy_igodu)
+  call RuntimeParameters_get("iplm",             hy_iplm)
+  call RuntimeParameters_get("gridIsUniform",    hy_gridIsUniform)
+  call RuntimeParameters_get("interp_6thOrder",  hy_interp_6thOrder)
+  call RuntimeParameters_get("interp_6thC",      hy_interp_6thC)
+  call RuntimeParameters_get("detect_djump",     hy_detect_djump)
+
+  call RuntimeParameters_get("xl_boundary_noflow", hy_xl_boundary_noflow)
+  call RuntimeParameters_get("xr_boundary_noflow", hy_xr_boundary_noflow)
+  call RuntimeParameters_get("yl_boundary_noflow", hy_yl_boundary_noflow)
+  call RuntimeParameters_get("yr_boundary_noflow", hy_yr_boundary_noflow)
+  call RuntimeParameters_get("zl_boundary_noflow", hy_zl_boundary_noflow)
+  call RuntimeParameters_get("zr_boundary_noflow", hy_zr_boundary_noflow)
+
+
+  call RuntimeParameters_get("ppmEnerFluxConstructionMeth", hy_ppmEnerFluxConstructionMeth)
+  call RuntimeParameters_get("ppmEintFluxConstructionMeth", hy_ppmEintFluxConstructionMeth)
+  if (hy_ppmEintFluxConstructionMeth==-1) hy_ppmEintFluxConstructionMeth = hy_ppmEnerFluxConstructionMeth
+
+  call RuntimeParameters_get("ppmEnerCompFluxConstructionMeth", hy_ppmEnerCFluxConstructionMeth)
+  call RuntimeParameters_get("ppmEintCompFluxConstructionMeth", hy_ppmEintCFluxConstructionMeth)
+  if (hy_ppmEintCFluxConstructionMeth==-1) hy_ppmEintCFluxConstructionMeth = hy_ppmEnerCFluxConstructionMeth
+
+  call RuntimeParameters_get("use_flattening",     hy_useFlattening)
+  call RuntimeParameters_get("enr_flattening",     hy_enrFlattening)
+  call RuntimeParameters_get("use_steepening",     hy_useSteepening)
+  call RuntimeParameters_get("use_cma_flattening", hy_useCmaFlattening)
+  call RuntimeParameters_get("use_cma_steepening", hy_useCmaSteepening)
+  call RuntimeParameters_get("use_cma_advection",  hy_useCmaAdvection)
+  call RuntimeParameters_get("charLimiting",       hy_charLimiting) ! new characteristic limiting - DL
+  call RuntimeParameters_get("mrppm_iord", hy_iord)
+  call RuntimeParameters_get("mrppm_simplemask", hy_simpleMask)
+
+  call RuntimeParameters_get("hy_fluxRepresentation", hy_fluxRepresentation)
+  if (trim(hy_fluxRepresentation) == "auto") then
+#ifdef FLASH_GRID_PARAMESH2
+     hy_fluxRepresentation = "hybrid" !Paramesh2 always assumes this - KW
+#else
+     if (hy_geometry == CARTESIAN) then
+        hy_fluxRepresentation = "hybrid"
+     else
+        hy_fluxRepresentation = "fluxes"
+     end if
+#endif
+  end if
+
+
+  ! Riemann solver selection for both normal operation and hybridization around shocks (TAH: April 6, 2016)
+  ! Flags are defined in PPM.h
+  call RuntimeParameters_get("ppmRiemannSolver",       hy_RiemannSolver_str)
+  call RuntimeParameters_get("ppmRiemannSolverHybrid", hy_RiemannSolverHybrid_str)
+  if((trim(hy_RiemannSolver_str) == "Exact") .or. &
+     (trim(hy_RiemannSolver_str) == "exact") .or. &
+     (trim(hy_RiemannSolver_str) == "EXACT") ) then
+     hy_RiemannSolver = EXACTRS
+  elseif( (trim(hy_RiemannSolver_str) == "ausmp") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMP") ) then
+     hy_RiemannSolver = AUSMP
+  elseif( (trim(hy_RiemannSolver_str) == "ausmpup") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMPUP") ) then
+     hy_RiemannSolver = AUSMPUP
+  elseif( (trim(hy_RiemannSolver_str) == "ausmpupit") .or. &
+          (trim(hy_RiemannSolver_str) == "AUSMPUPIT") ) then
+     hy_RiemannSolver = AUSMPUPIT
+  elseif( (trim(hy_RiemannSolver_str) == "ROEP") .or. &
+          (trim(hy_RiemannSolver_str) == "roep") ) then
+     hy_RiemannSolver = ROEP
+  
+
+  else
+     call Driver_abortFlash&
+          ("[Hydro_init]: The Riemann Solver is of unknown type: " // &
+           "Options are exact, AUSMP, AUSMPUP,AUSMPUPIT, or ROEP")
+  endif
+
+  if((trim(hy_RiemannSolverHybrid_str) == "hlle") .or. &
+     (trim(hy_RiemannSolverHybrid_str) == "HLLE") ) then
+     hy_RiemannSolverHybrid = HLLE
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmp") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMP") ) then
+     hy_RiemannSolverHybrid = AUSMP
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmpup") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMPUP") ) then
+     hy_RiemannSolverHybrid = AUSMPUP
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ausmpupit") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "AUSMPUPIT") ) then
+     hy_RiemannSolverHybrid = AUSMPUPIT
+  elseif( (trim(hy_RiemannSolverHybrid_str) == "ROEP") .or. &
+          (trim(hy_RiemannSolverHybrid_str) == "roep") ) then
+     hy_RiemannSolverHybrid = ROEP
+  else
+     call Driver_abortFlash&
+          ("[Hydro_init]: The Hybridization Riemann Solver is of unknown type: " // &
+           "Options are HLLE, AUSMP, or AUSMPUP.")
+  endif
+
+  if (.NOT. hy_useHydro) return ! If Hydto is turned off; return here before anything serious gets done.
+
+  if (hy_fluxRepresentation == "hybrid") then
+     hy_useCellAreasForFluxes = .FALSE.
+     call Grid_setFluxHandling('consv_flux_densities',status=istat)
+  else if (hy_fluxRepresentation == "fluxes") then
+     hy_useCellAreasForFluxes = .TRUE.
+     call Grid_setFluxHandling('consv_fluxes',status=istat)
+  else
+     call Driver_abortFlash('Hydro_init: Runtime Parameter hy_fluxRepresentation must be either '//&
+          '"hybrid" or "fluxes".')
+  end if
+#if NDIM > 1
+  if (istat .NE. 0) then
+     if (hy_fluxCorrect) then
+        if (hy_meshMe .EQ. MASTER_PE) print*,'WARNING from Hydro_init: hy_fluxRepresentation '//&
+             'was requested as "',hy_fluxRepresentation,'",',' but the Grid unit does not support this,'//&
+             ' using the handling supported by Grid.'
+        call Logfile_stampMessage('WARNING from Hydro_init: hy_fluxRepresentation '//&
+             'was requested as "'//hy_fluxRepresentation//'", but the Grid unit does not support this,'//&
+             ' using the handling supported by Grid.')
+        hy_useCellAreasForFluxes = .NOT. hy_useCellAreasForFluxes
+     end if
+  end if
+#endif
+
+  useSpecialFluxVar = hy_useCellAreasForFluxes
+
+  if (useSpecialFluxVar) then
+     hy_specialFluxVars(1) = P_FLUX
+  end if
+  if (hy_meshMe .EQ. MASTER_PE) then
+     print*,'Info: Hydro_init has set hy_specialFluxVars to ',hy_specialFluxVars
+  end if
+
+
+!! Determine some unit-wide variables that are directly derived from
+!! Runtime parameters
+  if (hy_cvisc == 0.0) then
+     hy_transverseStencilWidth = 0
+  else
+     hy_transverseStencilWidth = 1
+  end if
+
+!! Determine the geometries of the individual dimensions
+
+  if (hy_geometry == CARTESIAN)then
+     hy_dirGeom(IAXIS) = XYZ
+     hy_dirGeom(JAXIS) = XYZ
+     hy_dirGeom(KAXIS) = XYZ
+  elseif(hy_geometry == POLAR)then
+     hy_dirGeom(IAXIS) = RAD_CYL
+     hy_dirGeom(JAXIS) = PHI_CYL
+     hy_dirGeom(KAXIS) = XYZ
+  elseif(hy_geometry == CYLINDRICAL) then
+     hy_dirGeom(IAXIS) = RAD_CYL
+     hy_dirGeom(JAXIS) = XYZ
+     hy_dirGeom(KAXIS) = PHI_CYL
+  elseif(hy_geometry == SPHERICAL) then
+     hy_dirGeom(IAXIS) = RAD_SPH
+     hy_dirGeom(JAXIS) = THETA
+     hy_dirGeom(KAXIS) = PHI_SPH
+  else
+     call Driver_abortFlash("unsupported geometry ")
+  end if
+
+  if (hy_vgrid /= 0.e0) then
+     hy_movingGrid = .true.
+  else
+     hy_movingGrid = .false.
+  endif
+
+!! Ensure that hy_hybridRiemann is false if we're in 1D.
+!! Added by Tim in r6222, but not sure why. Commented out as helps with the entropy noise in ySNR models. (tp/201901xx)
+!!  if (hy_hybridRiemann .and. (NDIM==1)) call Driver_abortFlash('[Hydro_init] ERROR: Cannot have hybrid Riemann in 1D')
+
+!! Now initialize the GC Mask
+
+  hy_gcMask = .FALSE.
+
+#ifdef FL_NON_PERMANENT_GUARDCELLS
+  hy_gcMask(PRES_VAR) = .TRUE.
+#else
+  if (hy_hybridRiemann .AND. (hy_cvisc .ne. 0.0)) hy_gcMask(PRES_VAR) = .TRUE.
+#endif
+
+  hy_gcMask(DENS_VAR) = .TRUE.
+  hy_gcMask(ENER_VAR) = .TRUE.
+#ifdef EINT_VAR
+  hy_gcMask(EINT_VAR) = .TRUE.
+#endif
+  hy_gcMask(TEMP_VAR) = .TRUE.     !for now - only used fo initial guess by Helmholtz Eos - KW
+
+#ifdef GPOT_VAR
+  hy_gcMask(GPOT_VAR) = .TRUE.
+#endif
+#ifdef GPOL_VAR
+  hy_gcMask(GPOL_VAR) = .TRUE.
+#endif
+
+  hy_gcMask(VELX_VAR) = .TRUE.
+#if NDIM >= 2
+#ifdef VELY_VAR
+  hy_gcMask(VELY_VAR) = .TRUE.
+#endif
+#endif
+#if NDIM == 3
+#ifdef VELZ_VAR
+  hy_gcMask(VELZ_VAR) = .TRUE.
+#endif
+#endif
+#if SPECIES_BEGIN <= UNK_VARS_END
+  hy_gcMask(SPECIES_BEGIN:UNK_VARS_END) = .TRUE.
+#endif
+
+  hy_gcMaskSize=NUNK_VARS
+
+  call Logfile_stampVarMask(hy_gcMask, .FALSE., '[Hydro_init]', 'gcNeed')
+
+  !!AJG CFL violation diagnostics
+  hy_cfl_warning(:) = .false.
+  hy_cfl_max(:)     = -1.e0
+
+
+end subroutine Hydro_init
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/hy_ppm_block.F90	2021-02-18 10:06:46.332557655 -0500
@@ -0,0 +1,977 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/hy_ppm_block
+!!
+!! NAME
+!!
+!!  hy_ppm_block
+!!
+!! SYNOPSIS
+!!
+!!  call hy_ppm_block(integer(IN):: hy_meshMe,
+!!                integer(IN):: sweepDir, 
+!!                integer(IN):: blockID,
+!!                real(IN)   :: dt, 
+!!                real(IN)   :: dtOld, 
+!!                integer(IN):: blkLimits(HIGH,MDIM),
+!!                integer(IN):: blkLimitsGC(HIGH,MDIM),
+!!                integer(IN):: bcs(2,MDIM),
+!!                integer(IN):: numCells, 
+!!                integer(IN):: numguard,
+!!                real(IN)   :: primaryCoord(numCells),
+!!                real(IN)   :: primaryLeftCoord(numCells),
+!!                real(IN)   :: primaryRightCoord(numCells),
+!!                real(IN)   :: primaryDx(numCells),
+!!                real(IN)   :: secondCoord(numCells),
+!!                real(IN)   :: thirdCoord(numCells),
+!!                real(IN)   :: radialCoord(numCells),
+!!                real(IN)   :: ugrid(numCells),
+!!                real(OUT)  :: tempArea (blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempGrav1d_o(blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempGrav1d  (blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempDtDx    (blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempFict    (blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempAreaLeft(blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(OUT)  :: tempFlx(NFLUXES, blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real(IN)   :: shock       (blkLimitsGC(1,1):blkLimitsGC(2,1), blkLimitsGC(1,2):blkLimitsGC(2,2), blkLimitsGC(1,3):blkLimitsGC(2,3)),
+!!                real, pointer :: solnData(:,:,:,:)
+!!
+!! DESCRIPTION
+!!
+!!  This routine takes a pointer to a block of grid data, picks out 1d
+!!  slices, and applies the ppm algorithm, 1 row at a time, calculating
+!!  fluxes.  The fluxes are stored and returned in the tempFlx/y/z
+!!  arrays.  Other quantities used in the update step are calculated, as
+!!  well, such as the geometry factors.
+!!
+!! ARGUMENTS
+!!
+!!   hy_meshMe -- my Processor Number
+!!
+!!   blockID -- My block number
+!!
+!!   sweepDir --  direction in which to do 1d hydro sweeps
+!!
+!!   dt --         timestep to advance through
+!!
+!!   dtOld --     previous timestep
+!!
+!!   blkLimits --  array holding upper and lower index limits of interior block cells (no GC)
+!!
+!!   blkLimitsGC --  array holding the upper and lower index limits of an entire block (including GC)
+!!
+!!   bcs --  boundary conditions for domain boundaries as obtained from Grid_getBlkBC
+!!
+!!   numCells --  tells this routine how long each 1d slice will be
+!!
+!!   numguard --  tells this routine how many guardcells surround the interior
+!!
+!!   primaryCoord --  positions of cell centers of the 1d slice
+!!
+!!   primaryLeftCoord --  positions of left interfaces
+!!
+!!   primaryRightCoord --  positions of right interfaces
+!!
+!!   primaryDx --  width of cells in the sweep direction
+!!
+!!   secondCoord --  for an x sweep: y coordinates; for a y sweep: x coord; for a z sweep: xcoord
+!!
+!!   thirdCoord --   for an x sweep: z coordinates; for a y sweep: z coord; for a z sweep: ycoord
+!!
+!!   radialCoord --  
+!!
+!!   ugrid --  this is for moving grid velocities
+!!
+!!   tempArea --  in case we're in non-cartesian geometry, compute cell face areas; used in the update step
+!!
+!!   tempGrav1d_o --  gravitational acceleration from the previous step, at cell edges
+!!
+!!   tempGrav1d --  gravitational acceleration from the current step 
+!!
+!!   tempDtDx --  dt/dx factor for updating quantities from fluxes
+!!
+!!   tempFict --  represents geometry related forces, e.g., centrifugal; used to update velocities 
+!!
+!!   tempFlx --   fluxes for all flux variables and all cells of the block; are used to update the solution, and
+!!               given to Grid package for flux correction routines.
+!!   tempAreaLeft --  cell face areas to the left
+!!
+!!
+!!   shock --  0 if there is no shock or 1 if there is a shock for each cell; calculated by Hydro_detectShock 
+!!
+!!   solnData --  a pointer to the cell-centered data for the whole block
+!!
+!!***
+
+
+! solnData depends on the ordering on unk
+!!REORDER(4): solnData, tempFlx
+
+
+#ifdef DEBUG_ALL
+#define DEBUG_HYDRO
+#endif
+
+
+subroutine hy_ppm_block( hy_meshMe,blockID,sweepDir, dt, dtOld, &
+                         blkLimits,blkLimitsGC,bcs,  &
+                         numCells,numguard, &
+                         primaryCoord ,     &
+                         primaryLeftCoord , &
+                         primaryRghtCoord , &
+                         primaryDx        , &
+                         secondCoord      , &
+                         thirdCoord       , &
+                         radialCoord      , &
+                         ugrid            , &
+                         tempArea, tempGrav1d_o, tempGrav1d, &
+                         tempDtDx, tempFict, tempAreaLeft,   &
+                         tempFlx,                            & 
+                         shock, solnData)
+
+
+  use Hydro_data, ONLY : hy_useGravity, hy_geometry, hy_dirGeom,&
+                         hy_dela, &
+                         hy_dp , hy_du , hy_dut, hy_dutt, &
+                         hy_drho, hy_dgame, hy_dgamc, hy_dgrav, &
+                         hy_p6, hy_u6 , hy_ut6 , hy_utt6 , &
+                         hy_rho6 , hy_game6 , hy_gamc6 , hy_grav6 , &
+                         hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic,&
+                         hy_gravl, hy_gravr,   &
+                         hy_clft  , hy_plft  , hy_uttlft,   &
+                         hy_ulft  , hy_vlft  , hy_utlft , &
+                         hy_crght , hy_prght , hy_vrght ,         &
+                         hy_urght , hy_utrght, hy_uttrgt, &
+                         hy_gmelft, hy_gmergt, &
+                         hy_gmclft, hy_gmcrgt, &
+                         hy_ptrial, hy_perror, &
+                         hy_wlft, hy_wrght, &
+                         hy_nriem, &
+                         hy_deint,hy_eint6,hy_eiLft, hy_eiRght,     &
+                         hy_dxn,hy_xn6,hy_xnlft, hy_xnrght,     &
+                         hy_updateHydroFluxes, &
+                         hy_useCellAreasForFluxes, &
+                         hy_gravMass, &
+                         hy_flatn, hy_cds
+
+  use Grid_interface, ONLY : Grid_getSingleCellVol, Grid_getBlkData
+  use Driver_interface, ONLY : Driver_abortFlash
+  use Timers_interface, ONLY : Timers_start, Timers_stop
+
+  !! LOCAL - effective SCRATCH space
+  !! shock and shock_multid are for shock detecting
+  !! u -> utrt and omgz are for PPM.
+  !! These are slices that we pass to PPM.  Optimized for vector
+  !! machines years ago, PPM needs these slices in a very specific
+  !! way.  This is costly.  
+
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "PPM.h"
+
+  !! ------------
+  !! ---- ARGUMENTS
+  integer, intent(IN) :: hy_meshMe, blockID
+  integer, intent(IN) :: sweepDir
+  real,    intent(IN) :: dt, dtOld
+  integer, intent(IN) :: numCells,numguard
+  integer, intent(IN),dimension(2,MDIM) :: blkLimitsGC,blkLimits,bcs
+
+  real,    pointer :: solnData(:,:,:,:) 
+  !real, intent(INOUT), optional, dimension(numCells) :: vhalf
+
+  !! ------------
+
+  integer :: i1, i2, j1, j2, k1, k2
+  integer :: i, j, k, ii,ilo,ihi,jlo,jhi,klo,khi
+  integer :: iloGc,ihiGc,jloGc,jhiGc,kloGc,khiGc
+  real    :: xbot, xtop, ybot, ytop, ylft, yrgt, zlft, zrgt
+  integer :: numIntCells
+  integer,parameter :: numXn=NSPECIES+NMASS_SCALARS
+  integer :: sp,istat
+  integer,dimension(MDIM) :: size,startingPos
+  ! for gravity accumulation, implemented by LBR 12/19/2006
+  integer, DIMENSION(MDIM) :: point
+  real               :: cellVolume
+  real, allocatable :: faceAreas(:,:,:), cellVolumes(:,:,:)
+
+  ! multiresolution
+  integer :: numflx, numintrfc
+  integer, allocatable :: fluxKey(:), intrfcKey(:)
+
+  interface
+    subroutine ppm_mask(lb, numCells, primDim, secCell, terCell, &
+                          numintrfc, numflx, mask, intrfcmask, flxmask)
+      implicit none
+      integer, intent(in) :: lb, numCells, primDim, secCell, terCell
+      integer, intent(inout) :: numflx, numintrfc
+      real, dimension(numCells, 2), intent(in) :: mask
+      integer, allocatable, intent(inout) :: intrfcmask(:), flxmask(:)
+    end subroutine
+  end interface
+
+#ifdef FIXEDBLOCKSIZE
+  real, intent(OUT), DIMENSION(GRID_ILO_GC:GRID_IHI_GC,       &
+                               GRID_JLO_GC:GRID_JHI_GC,          &
+                               GRID_KLO_GC:GRID_KHI_GC) ::       &
+                               tempArea,       &
+                               tempGrav1d_o,   &
+                               tempGrav1d,     &
+                               tempDtDx,       &
+                               tempFict,       &
+                               tempAreaLeft
+
+  real, intent(IN), DIMENSION(GRID_ILO_GC:GRID_IHI_GC,       &
+                              GRID_JLO_GC:GRID_JHI_GC,          &
+                              GRID_KLO_GC:GRID_KHI_GC) :: &
+                              shock
+
+  real, intent(OUT), DIMENSION(NFLUXES,                   &
+                               GRID_ILO_GC:GRID_IHI_GC,     &
+                               GRID_JLO_GC:GRID_JHI_GC,     &
+                               GRID_KLO_GC:GRID_KHI_GC) ::  &
+                               tempFlx
+
+  real,intent(IN), DIMENSION(MAXCELLS) :: primaryCoord ,  &
+                                          primaryLeftCoord , &
+                                          primaryRghtCoord , &
+                                          primaryDx        , &
+                                          secondCoord      , &
+                                          thirdCoord       , &
+                                          radialCoord     , &
+                                          ugrid
+
+  real, DIMENSION(MAXCELLS) :: dtdx, areaLeft, area, cvol, grav, ngrav, fict, shock_multid
+  real, DIMENSION(MAXCELLS) :: rhoflx, uflx, pav, &
+                               utflx, uttflx, eflx, eintflx,&
+                               u, ut, utt, rho, p, e,  &
+                               tmp, gamc, game,  &
+                               uttp, utbt, utlt, utrt, &
+                               omgz
+  real, DIMENSION(MAXCELLS, NSPECIES+NMASS_SCALARS) :: xn,xnflx
+
+  ! multiresolution copy arrays (hardcoded 2 for number of levels currently)
+  real, dimension(MAXCELLS, 2) :: mrmask
+
+  istat = 0
+
+#else
+  real, intent(OUT), DIMENSION(blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS),       &
+                               blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS),          &
+                               blkLimitsGC(LOW,KAXIS):blkLimitsGC(HIGH,KAXIS)) ::       &
+                               tempArea,       &
+                               tempGrav1d_o,   &
+                               tempGrav1d,     &
+                               tempDtDx,       &
+                               tempFict,       &
+                               tempAreaLeft
+  real, intent(IN), DIMENSION(blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS),&
+                              blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS),&
+                              blkLimitsGC(LOW,KAXIS):blkLimitsGC(HIGH,KAXIS)) :: shock
+  
+  real, intent(OUT), DIMENSION(NFLUXES,                   &
+                               blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS),     &
+                               blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS),     &
+                               blkLimitsGC(LOW,KAXIS):blkLimitsGC(HIGH,KAXIS)) ::  &
+                               tempFlx  
+  real, intent(IN), DIMENSION(numCells) :: primaryCoord ,  &
+                                           primaryLeftCoord , &
+                                           primaryRghtCoord , &
+                                           primaryDx        , &
+                                           secondCoord      , &
+                                           thirdCoord       , &
+                                           radialCoord     , &
+                                           ugrid
+
+
+
+
+  real, DIMENSION(numCells) :: dtdx, areaLeft, area, cvol, grav, ngrav, fict, shock_multid
+  real, DIMENSION(numCells) :: rhoflx, uflx, pav, &
+                               utflx, uttflx, eflx, eintflx,&
+                               u, ut, utt, rho, p, e,  &
+                               tmp, gamc, game,  &
+                               uttp, utbt, utlt, utrt, &
+                               omgz
+  real, DIMENSION(numCells, NSPECIES+NMASS_SCALARS) :: xn, xnflx
+
+  ! multiresolution copy arrays (hardcoded 2 for number of levels currently)
+  real, dimension(numCells, 2) :: mrmask
+
+  save omgz
+  !======================================================================
+
+  allocate(hy_dela(numCells),stat = istat) 
+  if (istat==0)allocate(hy_dp(numCells),stat = istat) 
+  if (istat==0)allocate( hy_du(numCells),stat = istat)  
+  if (istat==0)allocate(hy_dut(numCells),stat = istat) 
+  if (istat==0)allocate( hy_dutt(numCells),stat = istat) 
+  if (istat==0)allocate( hy_drho(numCells),stat = istat) 
+  if (istat==0)allocate( hy_dgame(numCells),stat = istat) 
+  if (istat==0)allocate( hy_dgamc(numCells),stat = istat) 
+  if (istat==0)allocate( hy_dgrav(numCells),stat = istat) 
+  if (istat==0)allocate( hy_p6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_u6(numCells),stat = istat)
+  if (istat==0)allocate( hy_ut6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_utt6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_rho6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_game6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_gamc6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_grav6(numCells),stat = istat) 
+  if (istat==0)allocate( hy_pwl(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_pwr(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_dpw(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_pw6l(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_pw6r(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_pwcubic(numCells),stat = istat) !! valid
+
+  if (istat==0)allocate(hy_deint(numCells), stat = istat)
+  if (istat==0)allocate(hy_eint6(numCells), stat = istat)
+  if (istat==0)allocate(hy_eiLft(numCells),stat = istat) 
+  if (istat==0)allocate( hy_eiRght(numCells),stat = istat) 
+
+  if (istat==0)allocate(hy_dxn(numCells,numXN), stat = istat)
+  if (istat==0)allocate(hy_xn6(numCells,numXN), stat = istat)
+  if (istat==0)allocate(hy_xnlft(numCells,numXn),stat = istat) 
+  if (istat==0)allocate( hy_xnrght(numCells,numXn),stat = istat) 
+
+  if (istat==0)allocate(hy_gravl(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_gravr(numCells),stat = istat) !! valid
+  if (istat==0)allocate(hy_clft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_plft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_uttlft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_ulft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_vlft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_utlft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_crght(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_prght(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_vrght(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_urght(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_utrght(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_uttrgt(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_gmelft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_gmergt(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_gmclft(numCells),stat = istat) !! valid
+  if (istat==0)allocate( hy_gmcrgt(numCells),stat = istat) !! valid
+  
+#endif
+  if (istat==0)allocate( hy_ptrial(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_perror(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_wlft(hy_nriem + 2),stat = istat)
+  if (istat==0)allocate( hy_wrght(hy_nriem + 2),stat = istat)
+
+  if (istat /= 0) then
+     call Driver_abortFlash("[hy_ppm_block] ERROR: Memory allocation error in subroutine hy_block!")
+  end if
+
+
+!    Compute fluxes:  copy fluid data from 3D storage arrays        
+!    into 1D work arrays, then operate on each row in turn.         
+!    Update the solution in the 3D storage arrays, then save        
+!    the computed fluxes for adjustment during the flux             
+!    conservation step.                                             
+
+!!$ IMPORTANT -- MOVE TO DATABASE. THIS IS A TEMPORARY HACK 
+  grav(:) = 0.e0
+          
+  call Timers_start("hy_block")
+! if we are using a hybrid Riemann solvers (i.e. using HLLE inside shocks), 
+! then start by doing a multi-dimensional shock detection -- this is more 
+! accurate than the 1-d one done by the PPM algorithm            
+
+  tempFlx(:,:,:,:) = 0.e0
+
+  select case (sweepDir)
+  case (SWEEP_X)
+     j1 = 1; j2 = 1
+     k1 = 1; k2 = 1
+     !! Loop over the interior to create the 1d slices
+     iloGc = blkLimitsGC(LOW,IAXIS)
+     ihiGc = blkLimitsGC(HIGH,IAXIS)
+     ilo = blkLimits(LOW,IAXIS)
+     ihi = blkLimits(HIGH,IAXIS)
+     if (hy_useCellAreasForFluxes) then
+        allocate(faceAreas(ihi+1, &
+              blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
+              blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)))
+        call Grid_getBlkData(blockID, CELL_FACEAREA, ILO_FACE, EXTERIOR, &
+                             (/1,blkLimits(LOW,JAXIS),blkLimits(LOW,KAXIS)/), &
+                             faceAreas, &
+          (/ihi+1, blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1, &
+                   blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1/) )
+        allocate(cellVolumes(ihi, &
+              blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
+              blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)))
+        call Grid_getBlkData(blockID, CELL_VOLUME, 0, EXTERIOR, &
+                             (/1,blkLimits(LOW,JAXIS),blkLimits(LOW,KAXIS)/), &
+                             cellVolumes, &
+          (/ihi, blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1, &
+                 blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1/) )
+     end if
+     do k = blkLimits(LOW,KAXIS),blkLimits(HIGH,KAXIS)
+        point(KAXIS) = k
+        do j = blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS)
+           point(JAXIS) = j
+           if (hy_useCellAreasForFluxes) then
+              areaLeft(1:ihi+1) = faceAreas(:,j,k)
+              cvol(1:ihi) = cellVolumes(:,j,k)
+           end if
+           shock_multid(iloGc:ihiGc) = shock(iloGc:ihiGc,j,k)
+           u(iloGc:ihiGc)    = solnData( VELX_VAR,iloGc:ihiGc, j, k )
+           ut(iloGc:ihiGc)   = solnData( VELY_VAR, iloGc:ihiGc, j, k )
+           utt(iloGc:ihiGc)  = solnData( VELZ_VAR, iloGc:ihiGc, j, k )
+           rho(iloGc:ihiGc)  = solnData( DENS_VAR, iloGc:ihiGc, j, k )
+           p(iloGc:ihiGc)    = solnData( PRES_VAR, iloGc:ihiGc, j, k )
+           e(iloGc:ihiGc)    = solnData( ENER_VAR, iloGc:ihiGc, j, k )
+           tmp(iloGc:ihiGc)  = solnData( TEMP_VAR, iloGc:ihiGc, j, k )
+           game(iloGc:ihiGc) = solnData( GAME_VAR, iloGc:ihiGc, j, k )
+           gamc(iloGc:ihiGc) = solnData( GAMC_VAR, iloGc:ihiGc, j, k )
+           mrmask(iloGc:ihiGc,2) = solnData( MSKA_VAR, iloGc:ihiGc, j, k )
+           mrmask(iloGc:ihiGc,1) = solnData( MSKB_VAR, iloGc:ihiGc, j, k )
+           !vhalf(iloGc:ihiGc)= solnData( VXIN_VAR, iloGc:ihiGc, j, k )
+
+           if (numXN > 0) then
+#ifdef INDEXREORDER
+              !! Note: solnData is going to be flipped so this is OK even if it does not seem so
+              xn(iloGc:ihiGc,:) = solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1),iloGc:ihiGc,j,k)
+#else
+              xn(iloGc:ihiGc,:) = transpose&
+                (solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1),iloGc:ihiGc,j,k ))
+#endif
+           end if
+           if (NDIM.ge.2) then
+              j1 = j - 1 ; j2 = j + 1
+           end if
+           if (NDIM.eq.3) then
+              k1 = k - 1 ; k2 = k + 1
+           end if
+
+           !!Initialise to zero (because we may not be overwriting the entire array)
+           uttp = 0
+           utbt = 0
+           utrt = 0
+           utlt = 0
+           uttp(iloGc:ihiGc) = solnData(VELY_VAR, iloGc:ihiGc, j2, k)
+           utbt(iloGc:ihiGc) = solnData(VELY_VAR, iloGc:ihiGc, j1, k)
+           utrt(iloGc:ihiGc) = solnData(VELZ_VAR, iloGc:ihiGc, j, k2)
+           utlt(iloGc:ihiGc) = solnData(VELZ_VAR, iloGc:ihiGc, j, k1)
+
+           ! support for rotation (only 2D cylindrical)
+           omgz = 0.e0
+#ifdef SAMZ_MSCALAR
+
+           if ( (hy_geometry == CYLINDRICAL) .and. (hy_dirGeom(IAXIS) == RAD_CYL) ) &
+                omgz(iloGc:ihiGc) = solnData(SAMZ_MSCALAR, iloGc:ihiGc, j, k)/primaryCoord(iloGc:ihiGc)**2
+#endif
+
+           xbot = 0.
+           xtop = 0.           
+           ybot = secondCoord(j1)
+           ytop = secondCoord(j2)
+           ylft = 0.
+           yrgt = 0.
+           zlft = thirdCoord(k1)
+           zrgt = thirdCoord(k2)
+           numIntCells = ihi-ilo+1
+
+           ! get masking information from wavelet module
+           !call Timers_start("ppm_mask")
+           call ppm_mask(blockID, numCells, IAXIS, j, k, numintrfc, numflx, &
+                             mrmask, intrfcKey, fluxKey)
+           !call Timers_stop("ppm_mask")
+
+           ! determine which routine to call
+           call Timers_start("hydro_1d")
+
+           ! call hydro routine to get fluxes
+           call ppm_hydro(blockID,numIntCells,numCells,numintrfc, &
+                         numflx,intrfcKey,fluxKey, &
+                         numguard, bcs, &
+                         sweepDir, hy_meshMe,dt, dtOld, &
+                         j, k,                       &
+                         hy_dirGeom(IAXIS), hy_useGravity,              &
+                         xbot, xtop,                 &
+                         ybot, ytop, ylft, yrgt,     &
+                         zlft, zrgt, ugrid,          &
+                         primaryCoord ,              &
+                         primaryLeftCoord ,          &
+                         primaryRghtCoord ,          &
+                         primaryDx        ,          &
+                         secondCoord      ,          &
+                         thirdCoord       ,          &
+                         radialCoord     ,           &
+                         u, ut, utt, rho, p, e, tmp, game, gamc,   &
+                         xn, utbt, uttp, utlt, utrt,               &
+                         omgz,                                     &
+                         shock_multid,                             &
+                         dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
+                         rhoflx, uflx, pav, utflx, uttflx,         &
+                         eflx, eintflx, xnflx)
+
+           ! deallocate memory from compressed array maps
+           deallocate(intrfcKey)
+           deallocate(fluxKey)
+           call Timers_stop("hydro_1d")
+
+#ifdef FLTX_VAR
+
+           solnData(FLTX_VAR,iloGc:ihiGc,j,k) = hy_flatn(iloGc:ihiGc)
+#endif
+#ifdef CDSX_VAR
+
+           solnData(CDSX_VAR,iloGc:ihiGc,j,k) = hy_cds(iloGc:ihiGc)
+#endif
+
+           tempAreaLeft(ilo:ihi+1,j,k) = areaLeft(ilo:ihi+1)
+           if (hy_updateHydroFluxes) then
+              do i = ilo, ihi
+                 tempDtDx(i,j,k)     = dtdx(i)
+                 tempArea(i,j,k)     = area(i)
+                 tempGrav1d_o(i,j,k) = grav(i)
+                 tempGrav1d(i,j,k)   = ngrav(i)
+                 tempFict(i,j,k)     = fict(i)
+
+                 point(IAXIS) = i
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(IAXIS) = hy_gravMass(IAXIS) + grav(i)*rho(i)*cellVolume
+              enddo
+
+              do i = ilo, ihi+1
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(i)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(i)
+                 tempFlx(P_FLUX,i,j,k)    = pav(i)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(i)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(i)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(i)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(i)
+              enddo
+
+              do sp = 1, numXn
+                 do i = ilo, ihi+1
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(i,sp)
+                 end do
+              enddo
+           else
+              do i = ilo, ihi
+                 tempDtDx(i,j,k)     = dtdx(i)
+                 tempArea(i,j,k)     = area(i)
+                 tempGrav1d_o(i,j,k) = grav(i)
+                 tempGrav1d(i,j,k)   = ngrav(i)
+                 tempFict(i,j,k)     = fict(i)
+              end do
+           end if
+        
+        end do !!j loop
+     end do !!k loop
+
+     size(IAXIS)=blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1
+     size(JAXIS)=blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1
+     size(KAXIS)=blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1
+
+
+#if NDIM >= 2
+
+  case (SWEEP_Y)
+
+     ! although one could assume userForce is sufficiently selective, it seems prudent
+     ! to zero out the specific angular momentum to avoid any possible problems
+     omgz = 0.e0
+
+     k1 = 1; k2 = 1
+     !! Loop over the interior to create the 1d slices
+     jlo = blkLimits(LOW,JAXIS)
+     jhi = blkLimits(HIGH,JAXIS)
+     jloGc = blkLimitsGC(LOW,JAXIS)
+     jhiGc = blkLimitsGC(HIGH,JAXIS)
+     if (hy_useCellAreasForFluxes) then
+        allocate(faceAreas(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
+                           jhi+1, &
+                           blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)))
+        call Grid_getBlkData(blockID, CELL_FACEAREA, JLO_FACE, EXTERIOR, &
+                             (/blkLimits(LOW,IAXIS),1,blkLimits(LOW,KAXIS)/), &
+                             faceAreas, &
+                             (/blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1, &
+                               jhi+1, &
+                               blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1/) )
+        allocate(cellVolumes(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
+                             jhi, &
+                             blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)))
+        call Grid_getBlkData(blockID, CELL_VOLUME, 0, EXTERIOR, &
+                             (/blkLimits(LOW,IAXIS),1,blkLimits(LOW,KAXIS)/), &
+                             cellVolumes, &
+                             (/blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1, &
+                               jhi, &
+                               blkLimits(HIGH,KAXIS)-blkLimits(LOW,KAXIS)+1/) )
+     end if
+     do k = blkLimits(LOW,KAXIS),blkLimits(HIGH,KAXIS)
+        point(KAXIS) = k
+        do i = blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS)
+           point(IAXIS) = i
+           
+           if (hy_useCellAreasForFluxes) then
+              areaLeft(1:jhi+1) = faceAreas(i,:,k)
+              cvol(1:jhi) = cellVolumes(i,:,k)
+           end if
+           shock_multid(jloGc:jhiGc) = shock(i,jloGc:jhiGc,k)
+           u(jloGc:jhiGc)    = solnData( VELY_VAR,i, jloGc:jhiGc, k )
+           ut(jloGc:jhiGc)   = solnData( VELX_VAR,i, jloGc:jhiGc, k )
+           utt(jloGc:jhiGc)  = solnData( VELZ_VAR,i, jloGc:jhiGc, k )
+           rho(jloGc:jhiGc)  = solnData( DENS_VAR,i, jloGc:jhiGc, k )
+           p(jloGc:jhiGc)    = solnData( PRES_VAR,i, jloGc:jhiGc, k )
+           e(jloGc:jhiGc)    = solnData( ENER_VAR,i, jloGc:jhiGc, k )
+           tmp(jloGc:jhiGc)  = solnData( TEMP_VAR,i, jloGc:jhiGc, k )
+           game(jloGc:jhiGc) = solnData( GAME_VAR,i, jloGc:jhiGc, k )
+           gamc(jloGc:jhiGc) = solnData( GAMC_VAR,i, jloGc:jhiGc, k )
+           mrmask(jloGc:jhiGc,2) = solnData( MSKA_VAR, i, jloGc:jhiGc, k )
+           mrmask(jloGc:jhiGc,1) = solnData( MSKB_VAR, i, jloGc:jhiGc, k )
+           !vhalf(jloGc:jhiGc)= solnData( VYIN_VAR,i, jloGc:jhiGc, k )
+
+           if (numXN > 0) then
+#ifdef INDEXREORDER
+              xn(jloGc:jhiGc,:) = solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1),i,jloGc:jhiGc,k)
+#else
+              xn(jloGc:jhiGc,:) = transpose&
+                &(solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1),i,jloGc:jhiGc,k ))
+#endif
+           end if
+           i1 = i - 1 ; i2 = i + 1
+           if (NDIM.eq.3) then
+              k1 = k - 1 ; k2 = k + 1
+           end if
+           
+           !!Initialise to zero (because we may not be overwriting the entire array)
+           uttp = 0
+           utbt = 0
+           utrt = 0
+           utlt = 0
+           uttp(jloGc:jhiGc) = solnData(VELX_VAR, i2, jloGc:jhiGc, k)
+           utbt(jloGc:jhiGc) = solnData(VELX_VAR, i1, jloGc:jhiGc, k)
+           utrt(jloGc:jhiGc) = solnData(VELZ_VAR,i, jloGc:jhiGc, k2)
+           utlt(jloGc:jhiGc) = solnData(VELZ_VAR,i, jloGc:jhiGc, k1)
+
+           xbot = secondCoord(i1)
+           xtop = secondCoord(i2)
+           zlft = thirdCoord(k1)
+           zrgt = thirdCoord(k2)
+           numIntCells = jhi-jlo+1
+
+           ! get masking information from wavelet module
+           !call Timers_start("ppm_mask")
+           call ppm_mask(blockID, numCells, JAXIS, i, k, numintrfc, numflx, &
+                             mrmask, intrfcKey, fluxKey)
+           !call Timers_stop("ppm_mask")
+
+           ! call hydro routine
+           call Timers_start("hydro_1d")
+           call ppm_hydro(blockID,numIntCells,numCells,numintrfc,numflx, &
+                          intrfcKey, fluxKey, numguard, bcs, &
+                          sweepDir, hy_meshMe ,dt,dtOld, &
+                          i, k,                       &
+                          hy_dirGeom(JAXIS), hy_useGravity,                           &
+                          xbot, xtop,                              &
+                          ybot, ytop, ylft, yrgt,                  &
+                          zlft, zrgt, ugrid,                       &
+                          primaryCoord ,     &
+                          primaryLeftCoord , &
+                          primaryRghtCoord , &
+                          primaryDx        , &
+                          secondCoord      , &
+                          thirdCoord       , &
+                          radialCoord      , &
+                          u, ut, utt, rho, p, e, tmp, game, gamc,  &
+                          xn, utbt, uttp, utlt, utrt,              &
+                          omgz,                                    &
+                          shock_multid,                            &
+                          dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
+                          rhoflx, uflx, pav, utflx, uttflx,        &
+                          eflx, eintflx, xnflx)
+
+           ! deallocate memory from compressed array maps
+           deallocate(intrfcKey)
+           deallocate(fluxKey)
+           call Timers_stop("hydro_1d")
+
+#ifdef FLTY_VAR
+
+           solnData(FLTY_VAR,i,jloGc:jhiGc,k) = hy_flatn(jloGc:jhiGc)
+#endif
+#ifdef CDSY_VAR
+
+           solnData(CDSY_VAR,i,jloGc:jhiGc,k) = hy_cds(jloGc:jhiGc)
+#endif
+
+           tempAreaLeft(i,jlo:jhi+1,k) = areaLeft(jlo:jhi+1)
+           if (hy_updateHydroFluxes) then
+              do j = jlo, jhi
+                 tempDtDx(i,j,k)     = dtdx(j)
+                 tempArea(i,j,k)     = area(j)
+                 tempGrav1d_o(i,j,k) = grav(j)   !! Gradient in y direction
+                 tempGrav1d(i,j,k)   = ngrav(j)  !! Gradient in y direction + (dt/dtOld)*(difference in time)
+                 tempFict(i,j,k)     = fict(j)
+
+                 point(JAXIS) = j
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(JAXIS) = hy_gravMass(JAXIS) + grav(j)*rho(j)*cellVolume !  grav(j)*rho(j)*cellVolume 
+
+              enddo
+
+              do j = jlo, jhi+1
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(j)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(j)
+                 tempFlx(P_FLUX,i,j,k)    = pav(j)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(j)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(j)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(j)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(j)
+              enddo
+
+              do sp = 1, numXn
+                 do j = jlo, jhi+1
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(j,sp)
+                 end do
+              enddo
+           else
+              do j = jlo, jhi
+                 tempDtDx(i,j,k)     = dtdx(j)
+                 tempArea(i,j,k)     = area(j)
+                 tempGrav1d_o(i,j,k) = grav(j)
+                 tempGrav1d(i,j,k)   = ngrav(j)
+                 tempFict(i,j,k)     = fict(j)
+              end do
+           end if
+
+        end do !!j loop
+     end do !!k loop
+
+
+
+#endif
+#if NDIM == 3 
+  case (SWEEP_Z) 
+
+     ! although one could assume userForce is sufficiently selective, it seems prudent
+     ! to zero out the specific angular momentum to avoid any possible problems
+     omgz = 0.e0
+
+     !! Loop over the interior to create the 1d slices
+     klo = blkLimits(LOW,KAXIS)
+     khi = blkLimits(HIGH,KAXIS)
+     kloGc = blkLimitsGC(LOW,KAXIS)
+     khiGc = blkLimitsGC(HIGH,KAXIS)
+
+     if (hy_useCellAreasForFluxes) then
+        allocate(faceAreas(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
+                           blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
+                           khi+1))
+        call Grid_getBlkData(blockID, CELL_FACEAREA, KLO_FACE, EXTERIOR, &
+                             (/blkLimits(LOW,IAXIS),blkLimits(LOW,JAXIS),1/), &
+                             faceAreas, &
+                             (/blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1, &
+                               blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1, &
+                               khi+1/) )
+        allocate(cellVolumes(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
+                             blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
+                             khi))
+        call Grid_getBlkData(blockID, CELL_VOLUME, 0, EXTERIOR, &
+                             (/blkLimits(LOW,IAXIS),blkLimits(LOW,JAXIS),1/), &
+                             cellVolumes, &
+                             (/blkLimits(HIGH,IAXIS)-blkLimits(LOW,IAXIS)+1, &
+                               blkLimits(HIGH,JAXIS)-blkLimits(LOW,JAXIS)+1, &
+                               khi/) )
+     end if
+     do j = blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS)
+        point(JAXIS) = j
+        do i = blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS)
+           point(IAXIS) = i
+           
+           if (hy_useCellAreasForFluxes) then
+              areaLeft(1:khi+1) = faceAreas(i,j,:)
+              cvol(1:khi) = cellVolumes(i,j,:)
+           end if
+           shock_multid(kloGc:khiGc) = shock(i,j,kloGc:khiGc)
+           
+           u(kloGc:khiGc)    = solnData( VELZ_VAR, i, j, kloGc:khiGc )
+           ut(kloGc:khiGc)   = solnData( VELX_VAR, i, j, kloGc:khiGc )
+           utt(kloGc:khiGc)  = solnData( VELY_VAR, i, j, kloGc:khiGc )
+           rho(kloGc:khiGc)  = solnData( DENS_VAR, i, j, kloGc:khiGc )
+           p(kloGc:khiGc)    = solnData( PRES_VAR, i, j, kloGc:khiGc )
+           e(kloGc:khiGc)    = solnData( ENER_VAR, i, j, kloGc:khiGc )
+           tmp(kloGc:khiGc)  = solnData( TEMP_VAR, i, j, kloGc:khiGc )
+           game(kloGc:khiGc) = solnData( GAME_VAR, i, j, kloGc:khiGc )
+           gamc(kloGc:khiGc) = solnData( GAMC_VAR, i, j, kloGc:khiGc )
+           !vhalf(kloGc:khiGc)= solnData( VZIN_VAR, i, j, kloGc:khiGc )
+
+           if (numXN > 0) then
+#ifdef INDEXREORDER
+              !! solnData will be flipped so this is OK
+              xn(kloGc:khiGc,:) = solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1), i, j, kloGc:khiGc)
+#else
+              xn(kloGc:khiGc,:) = transpose&
+                &(solnData(SPECIES_BEGIN:(SPECIES_BEGIN+numXN-1), i, j, kloGc:khiGc))
+#endif
+           end if
+
+           i1 = i - 1 ; i2 = i + 1
+           j1 = j - 1 ; j2 = j + 1
+           
+           !!Initialise to zero (because we may not be overwriting the entire array)
+           uttp = 0
+           utbt = 0
+           utrt = 0
+           utlt = 0
+           uttp(kloGc:khiGc) = solnData(VELX_VAR, i2, j, kloGc:khiGc)
+           utbt(kloGc:khiGc) = solnData(VELX_VAR, i1, j, kloGc:khiGc)
+           utrt(kloGc:khiGc) = solnData(VELY_VAR, i, j2, kloGc:khiGc)
+           utlt(kloGc:khiGc) = solnData(VELY_VAR, i, j1, kloGc:khiGc)
+
+           xbot = secondCoord(i1)
+           xtop = secondCoord(i2)
+           ylft = thirdCoord(j1)
+           yrgt = thirdCoord(j2)
+           numIntCells = khi-klo+1
+!        call Timers_start("hydro_1d")
+           call hydro_1d (blockID,numIntCells,numCells,numguard,bcs,     &
+                          sweepDir, hy_meshMe, dt, dtOld,                &
+                          i, j,                                          &
+                          hy_dirGeom(KAXIS), hy_useGravity,              &
+                          xbot, xtop,                                    &
+                          ybot, ytop, ylft, yrgt,                        &
+                          zlft, zrgt, ugrid,                             &
+                          primaryCoord ,                                 &
+                          primaryLeftCoord ,                             &
+                          primaryRghtCoord ,                             &
+                          primaryDx        ,                             &
+                          secondCoord      ,                             &
+                          thirdCoord       ,                             &
+                          radialCoord      ,                             &
+                          u, ut, utt, rho, p, e, tmp, game, gamc,        &
+                          xn, utbt, uttp, utlt, utrt,                    &
+                          omgz,                                          &
+                          shock_multid,                                  &
+                          dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
+                          rhoflx, uflx, pav, utflx, uttflx,              &
+                          eflx, eintflx, xnflx)
+!        call Timers_stop("hydro_1d")
+#ifdef FLTZ_VAR
+
+           solnData(FLTZ_VAR,i,j,kloGc:khiGc) = hy_flatn(kloGc:khiGc)
+#endif
+#ifdef CDSZ_VAR
+
+           solnData(CDSZ_VAR,i,j,kloGc:khiGc) = hy_cds(kloGc:khiGc)
+#endif
+
+           tempAreaLeft(i,j,klo:khi+1) = areaLeft(klo:khi+1)
+           if (hy_updateHydroFluxes) then
+              do k = klo, khi 
+                 tempDtDx(i,j,k)     = dtdx(k)
+                 tempArea(i,j,k)     = area(k)
+                 tempGrav1d_o(i,j,k) = grav(k)
+                 tempGrav1d(i,j,k)   = ngrav(k)
+                 tempFict(i,j,k)     = fict(k)
+
+                 point(KAXIS) = k
+                 call Grid_getSingleCellVol(blockID,EXTERIOR,point,cellVolume)
+                 hy_gravMass(KAXIS) = hy_gravMass(KAXIS) + grav(k)*rho(k)*cellVolume
+
+              enddo
+
+              do k = klo, khi+1 
+                 tempFlx(RHO_FLUX,i,j,k)  = rhoflx(k)
+                 tempFlx(U_FLUX,i,j,k)    = uflx(k)
+                 tempFlx(P_FLUX,i,j,k)    = pav(k)
+                 tempFlx(UT_FLUX,i,j,k)   = utflx(k)
+                 tempFlx(UTT_FLUX,i,j,k)  = uttflx(k)
+                 tempFlx(E_FLUX,i,j,k)    = eflx(k)
+                 tempFlx(EINT_FLUX,i,j,k) = eintflx(k)
+              enddo
+
+              do sp = 1, numXn
+                 do k = klo, khi+1 
+                    tempFlx(SPECIES_FLUX_BEGIN+sp-1,i,j,k) = xnflx(k,sp)
+                 end do
+              enddo
+
+           else
+              do k = klo, khi
+                 tempDtDx(i,j,k)     = dtdx(k)
+                 tempArea(i,j,k)     = area(k)
+                 tempGrav1d_o(i,j,k) = grav(k)
+                 tempGrav1d(i,j,k)   = ngrav(k)
+                 tempFict(i,j,k)     = fict(k)
+              end do
+           end if
+
+        end do
+     end do
+#endif
+     
+  end select
+
+  if (hy_useCellAreasForFluxes) then
+     deallocate(cellVolumes)
+     deallocate(faceAreas)
+  end if
+
+  deallocate( hy_ptrial )
+  deallocate( hy_perror )
+  deallocate( hy_wlft )
+  deallocate( hy_wrght )
+
+#ifndef FIXEDBLOCKSIZE
+  deallocate(hy_dela) 
+  deallocate(hy_dp) 
+  deallocate( hy_du)  
+  deallocate(hy_dut) 
+  deallocate( hy_dutt) 
+  deallocate( hy_drho) 
+  deallocate( hy_dgame) 
+  deallocate( hy_dgamc) 
+  deallocate( hy_dgrav) 
+  deallocate( hy_p6) 
+  deallocate( hy_u6)
+  deallocate( hy_ut6) 
+  deallocate( hy_utt6) 
+  deallocate( hy_rho6) 
+  deallocate( hy_game6) 
+  deallocate( hy_gamc6) 
+  deallocate( hy_grav6) 
+  deallocate( hy_pwl) 
+  deallocate( hy_pwr) 
+  deallocate( hy_dpw) 
+  deallocate( hy_pw6l) 
+  deallocate( hy_pw6r) 
+  deallocate( hy_pwcubic) 
+
+  deallocate(hy_deint)
+  deallocate(hy_eint6)
+  deallocate(hy_eiLft)
+  deallocate( hy_eiRght)
+
+  deallocate(hy_dxn)
+  deallocate(hy_xn6)
+  deallocate(hy_xnlft)
+  deallocate( hy_xnrght)
+
+  deallocate(hy_gravl) 
+  deallocate( hy_gravr) 
+  deallocate(hy_clft) 
+  deallocate( hy_plft) 
+  deallocate( hy_uttlft) 
+  deallocate( hy_ulft) 
+  deallocate( hy_vlft) 
+  deallocate( hy_utlft) 
+  deallocate( hy_crght) 
+  deallocate( hy_prght) 
+  deallocate( hy_vrght) 
+  deallocate( hy_urght) 
+  deallocate( hy_utrght) 
+  deallocate( hy_uttrgt) 
+  deallocate( hy_gmelft) 
+  deallocate( hy_gmergt) 
+  deallocate( hy_gmclft) 
+  deallocate( hy_gmcrgt) 
+  
+#endif
+  call Timers_stop("hy_block")
+end subroutine hy_ppm_block
+
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/Makefile	2021-02-14 19:07:55.635029815 -0500
@@ -1,16 +1,24 @@
 #	Makefile for 1D piecewise-parabolic method (PPM) module
 
-Hydro += hydro_1d.o \
+Hydro += ppm_hydro.o \
          grdvel.o \
+         cma_flatten.o \
          avisco.o \
-         intrfc.o \
-         rieman.o \
          riemann_hlle.o \
-         states.o \
-         coeff.o \
+         riemann_ausmp.o \
+         riemann_ausmpup.o \
+				 riemann_ausmpupit.o \
+				 riemann_roe.o \
          detect.o \
          flaten.o \
-         interp.o hy_interpNoLim.o \
-         cma_flatten.o \
-         monot.o hy_nomonot.o \
-	 interp_char.o
+				 ppm_compress.o \
+				 ppm_intrfc.o \
+				 ppm_coeff.o \
+				 ppm_interp.o \
+				 ppm_profile.o \
+				 ppm_detect.o \
+				 ppm_states.o \
+				 ppm_riemann.o \
+				 ppm_decode.o \
+				 ppm_interp_char.o \
+				 ppm_mask.o
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_coeff.F90	2021-02-14 15:24:26.403762417 -0500
@@ -0,0 +1,60 @@
+subroutine ppm_coeff(numCells, numIntrfcActv, dxvec, &
+                      c1, c2, c3, c4, c5, c6, c7, &
+                      s1, s2, s3, s4, s5, s6, key)
+
+
+  implicit none
+
+  integer, intent(IN) :: numCells, numIntrfcActv
+  real, intent(IN), DIMENSION(numCells) :: dxvec
+  logical, intent(in), dimension(numIntrfcActv) :: key  
+
+  real, intent(inout), dimension(numIntrfcActv) :: c1, c2, c3, c4, c5, c6, c7
+  real, intent(inout), dimension(numIntrfcActv) :: s1, s2, s3, s4, s5, s6
+  !real, dimension(4) :: tmp
+  real, dimension(numIntrfcActv) :: tmp1, tmp2, tmp3, tmp4
+  integer :: i, j
+  real :: dx
+
+  ! help vectorize the code
+  !do i = 1, numIntrfcActv
+  !  j = key(i)
+  !  tmp1(i) = dx(j-2)
+  !  tmp2(i) = dx(j-1)
+  !  tmp3(i) = dx(j)
+  !  tmp4(i) = dx(j+1)
+  !enddo
+
+  ! set dx
+  dx = dxvec(5)
+
+  ! loop over active cells only
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed cell index
+    !i = key(j)
+    !tmp = dx(i-2:i+1)
+
+    ! compute coefficients from eq. 1.6
+    c1(j) = dx / (dx + dx)
+    c2(j) = 1.0 / (dx + dx + dx + dx)
+    c3(j) = 2.0 * dx * c1(j) 
+    c4(j) = (dx+dx) / (2.0*dx+dx)
+    c5(j) = (dx + dx) / (2.0*dx + dx)
+    c6(j) = dx * c4(j)
+    c7(j) = dx * c5(j)
+
+    !  compute average slope coefficients for a_{j}
+    s1(j) = dx / (dx + dx + dx)
+    s2(j) = (2.0*dx + dx) / (dx + dx)
+    s3(j) = (dx + 2.0*dx) / (dx + dx)
+
+    !  compute average slope coefficients for a_{j+1}
+    s4(j) = dx / (dx + dx + dx)
+    s5(j) = (2.0*dx + dx) / (dx + dx)
+    s6(j) = (dx + 2.0*dx) / (dx + dx)
+
+
+  enddo
+
+end subroutine ppm_coeff
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_compress.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_compress.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_compress.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_compress.F90	2021-02-14 15:24:26.403762417 -0500
@@ -0,0 +1,112 @@
+subroutine ppm_compress(numCells, numXn, fluxMask, numFluxActv, numIntrfcActv, &
+                      intrfcKey, fluxKey, rhol, rhor, ul, ur, &
+                      utl, utr, uttl, uttr, pl, pr, eintl, eintr, gravl, &
+                      gravr, pwl, pwr, vl, vr, gamcl, gamcr, gamel, gamer, &
+                      xnl, xnr)
+
+  !-----------------------------------------------------------------------------
+
+  implicit none
+
+  integer, intent(in) :: numCells, numXn
+  integer, intent(out) :: numFluxActv, numIntrfcActv
+  logical, intent(in), dimension(numCells) :: fluxMask
+  logical, dimension(numCells) :: intrfcMask
+  integer, allocatable, intent(inout) :: intrfcKey(:), fluxKey(:)
+  real, allocatable, intent(inout) :: rhol(:), rhor(:), ul(:), ur(:), utl(:), &
+                                      utr(:), uttl(:), uttr(:), pl(:), pr(:), gamcl(:), &
+                                      gamcr(:), gamel(:), gamer(:), eintl(:), eintr(:), &
+                                      vl(:), vr(:), gravl(:), gravr(:), pwl(:), pwr(:)
+  real, allocatable, intent(inout) :: xnl(:,:), xnr(:,:)
+  integer :: i, j, k
+
+  !-----------------------------------------------------------------------------
+
+  ! initialize counters
+  numFluxActv = 0
+  numIntrfcActv = 0
+
+  ! intialize interface mask
+  intrfcMask(:) = .false.
+
+  ! loop over interior interfaces (make sure ghost interfaces not true)
+  do i = 1, numCells
+
+    ! check if fluxMask is active
+    if (fluxMask(i)) then
+
+      ! increment number of active fluxes
+      numFluxActv = numFluxActv + 1
+
+      ! need interfaces to left and right to be active as well
+      intrfcMask(i-1:i+1) = .true.
+
+    endif
+
+  enddo
+
+  ! count active interfaces, create mask
+  !do i = 1, numCells
+  !  if (intrfcMask(i).eqv..true.) numIntrfcActv = numIntrfcActv + 1
+  !enddo
+  numIntrfcActv = count(intrfcMask)
+
+  ! allocate memory for keys
+  allocate(intrfcKey(numIntrfcActv))
+  allocate(fluxKey(numFluxActv))
+
+  ! allocate memory for variables
+  allocate(rhol(numIntrfcActv))
+  allocate(rhor(numIntrfcActv))
+  allocate(ul(numIntrfcActv))
+  allocate(ur(numIntrfcActv))
+  allocate(utl(numIntrfcActv))
+  allocate(utr(numIntrfcActv))
+  allocate(uttl(numIntrfcActv))
+  allocate(uttr(numIntrfcActv))
+  allocate(pl(numIntrfcActv))
+  allocate(pr(numIntrfcActv))
+  allocate(gamcl(numIntrfcActv))
+  allocate(gamcr(numIntrfcActv))
+  allocate(gamel(numIntrfcActv))
+  allocate(gamer(numIntrfcActv))
+  allocate(eintl(numIntrfcActv))
+  allocate(eintr(numIntrfcActv))
+  allocate(gravl(numIntrfcActv))
+  allocate(gravr(numIntrfcActv))
+  allocate(vl(numIntrfcActv))
+  allocate(vr(numIntrfcActv))
+  allocate(pwl(numIntrfcActv))
+  allocate(pwr(numIntrfcActv))
+  allocate(xnl(numIntrfcActv,numXn))
+  allocate(xnr(numIntrfcActv,numXn))
+
+  ! map compressed index space to uncompressed index space
+  j = 1
+  k = 1
+  do i = 1, numCells
+
+    ! check if both masks active
+    if (intrfcMask(i)) then
+
+      ! set interface key value
+      intrfcKey(j) = i
+
+      if (fluxMask(i)) then
+
+        ! set flux key value (access example: ar(fluxKey(k)-1))
+        fluxKey(k) = j
+
+        ! increment
+        k = k + 1
+
+      endif
+
+      ! increment counter
+      j = j + 1
+
+    endif
+
+  enddo
+
+end subroutine ppm_compress
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_decode.F90	2021-02-18 10:23:40.701317937 -0500
@@ -0,0 +1,248 @@
+!!****if* source/flashUtilities/Wavelet/ppm_decode
+!!
+!! NAME
+!!
+!!  ppm_decode
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine ppm_decode(numCells, numintrfc, numflx, hy_numXn, fluxmask, &
+                        rhoflx, uflx, utflx, uttflx, pav, &
+                        eintflx, eflx, xnflx)
+  
+  use Hydro_data, ONLY : hy_cl1, hy_cl2, hy_cl3, hy_cl4, &
+                           hy_cr1, hy_cr2, hy_cr3, hy_cr4, &
+                           hy_cc1, hy_cc2, hy_cc3, hy_cc4, &
+                           hy_lstart, hy_simpleMask, hy_iord
+
+  use wvlt_data, ONLY : wvlt_maxLvl, iCellsInt
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! initialize variables
+  integer, intent(in) :: numCells, hy_numXn
+  integer, intent(in) :: numintrfc, numflx
+  logical, intent(in), dimension(numCells) :: fluxmask
+  real, intent(inout), dimension(numCells) :: rhoflx, uflx, utflx, uttflx, &
+                                                pav, eintflx, eflx
+  real, intent(inout), dimension(numCells,hy_numXn) :: xnflx
+
+  ! local vars
+  integer :: l, n, it, i1, i2, i3, i4, ni, dl
+  integer :: i, j, k
+  real :: c1, c2, c3, c4
+  real :: cl1, cl2, cl3, cl4
+  real :: cc1, cc2, cc3, cc4
+  real :: cr1, cr2, cr3, cr4
+
+
+  if (hy_iord.eq.1) then
+
+    cl1 = 0.5e0; cl2 = 0.5e0; cl3 = 0.e0; cl4 = 0.e0
+    cc1 = 0.e0; cc2 = 0.5e0; cc3 = 0.5e0; cc4 = 0.e0;
+    cr1 = 0.e0; cr2 = 0.e0; cr3 = 0.5e0; cr4 = 0.5e0;
+
+  elseif (hy_iord.eq.3) then
+
+    cl1 = hy_cl1; cl2 = hy_cl2; cl3 = hy_cl3; cl4 = hy_cl4
+    cc1 = hy_cc1; cc2 = hy_cc2; cc3 = hy_cc3; cc4 = hy_cc4
+    cr1 = hy_cr1; cr2 = hy_cr2; cr3 = hy_cr3; cr4 = hy_cr4
+
+  endif
+
+  if (hy_simpleMask) then
+
+    ! loop through levels, start at lstart
+    do l = hy_lstart, wvlt_maxLvl-1
+
+      ! number of cells at this level
+      ni = iCellsInt(l)
+
+      ! current level difference
+      dl = wvlt_maxLvl - l
+
+      ! loop through cells 
+      do i = 1, ni
+
+        ! compute fine-grid index of target interface
+        it = 2**(wvlt_maxLvl-(l+1)) * (2*i-1) + 5
+
+        print *, "l, i, it", l, i, it
+
+        ! coefficients and indices
+        if (i.eq.1) then
+
+          ! compute dependencies
+          i1 = 2**dl * (i-1) + 5
+          i2 = 2**dl * (i) + 5
+          i3 = 2**dl * (i+1) + 5
+          i4 = 2**dl * (i+2) + 5
+
+          ! coefficients
+          c1 = cl1; c2 = cl2; c3 = cl3; c4 = cl4
+          !c3 = 0.e0
+          !c4 = 0.e0
+          !c1 = 0.5e0
+          !c2 = 0.5e0
+
+        elseif (i.eq.ni) then
+
+          ! compute dependencies
+          i1 = 2**dl * (i-3) + 5
+          i2 = 2**dl * (i-2) + 5
+          i3 = 2**dl * (i-1) + 5
+          i4 = 2**dl * (i) + 5
+
+          ! coefficients
+          c1 = cr1; c2 = cr2; c3 = cr3; c4 = cr4
+
+        ! centered scheme
+        else
+
+          ! compute dependencies
+          i1 = 2**dl * (i-2) + 5
+          i2 = 2**dl * (i-1) + 5
+          i3 = 2**dl * (i) + 5
+          i4 = 2**dl * (i+1) + 5
+
+          ! coefficients
+          c1 = cc1; c2 = cc2; c3 = cc3; c4 = cc4
+
+        endif
+
+        ! interpolate fluxes
+        rhoflx(it) = c1*rhoflx(i1) + c2*rhoflx(i2) &
+                     + c3*rhoflx(i3) + c4*rhoflx(i4)
+     
+        uflx(it) = c1*uflx(i1) + c2*uflx(i2) &
+                     + c3*uflx(i3) + c4*uflx(i4)
+
+        utflx(it) = c1*utflx(i1) + c2*utflx(i2) &
+                     + c3*utflx(i3) + c4*utflx(i4)
+
+        uttflx(it) = c1*uttflx(i1) + c2*uttflx(i2) &
+                     + c3*uttflx(i3) + c4*uttflx(i4)
+
+        pav(it) = c1*pav(i1) + c2*pav(i2) &
+                     + c3*pav(i3) + c4*pav(i4)
+
+        eintflx(it) = c1*eintflx(i1) + c2*eintflx(i2) &
+                     + c3*eintflx(i3) + c4*eintflx(i4)
+
+        eflx(it) = c1*eflx(i1) + c2*eflx(i2) &
+                     + c3*eflx(i3) + c4*eflx(i4)
+
+        do n = 1, hy_numXn
+          xnflx(it,n) = c1*xnflx(i1,n) + c2*xnflx(i2,n) &
+                          + c3*xnflx(i3,n) + c4*xnflx(i4,n)
+        enddo
+
+      enddo
+
+    enddo
+
+  else
+
+    ! loop through levels, start at lstart
+    do l = 1, wvlt_maxLvl-1
+
+      ! number of cells at this level
+      ni = iCellsInt(l)
+
+      ! current level difference
+      dl = wvlt_maxLvl - l
+
+      ! loop through cells 
+      do i = 1, ni
+
+        ! compute fine-grid index of target interface
+        it = 2**(wvlt_maxLvl-(l+1)) * (2*i-1) + 5
+
+        if (.not.fluxmask(it)) then
+
+          ! coefficients and indices
+          if (i.eq.1) then
+
+            ! compute dependencies
+            i1 = 2**dl * (i-1) + 5
+            i2 = 2**dl * (i) + 5
+            i3 = 2**dl * (i+1) + 5
+            i4 = 2**dl * (i+2) + 5
+
+            ! coefficients
+            c1 = cl1; c2 = cl2; c3 = cl3; c4 = cl4
+
+          elseif (i.eq.ni) then
+
+            ! compute dependencies
+            i1 = 2**dl * (i-3) + 5
+            i2 = 2**dl * (i-2) + 5
+            i3 = 2**dl * (i-1) + 5
+            i4 = 2**dl * (i) + 5
+
+            ! coefficients
+            c1 = cr1; c2 = cr2; c3 = cr3; c4 = cr4
+
+          ! centered scheme
+          else
+
+            ! compute dependencies
+            i1 = 2**dl * (i-2) + 5
+            i2 = 2**dl * (i-1) + 5
+            i3 = 2**dl * (i) + 5
+            i4 = 2**dl * (i+1) + 5
+
+            ! coefficients
+            c1 = cc1; c2 = cc2; c3 = cc3; c4 = cc4
+
+          endif
+
+          ! interpolate fluxes
+          rhoflx(it) = c1*rhoflx(i1) + c2*rhoflx(i2) &
+                       + c3*rhoflx(i3) + c4*rhoflx(i4)
+       
+          uflx(it) = c1*uflx(i1) + c2*uflx(i2) &
+                       + c3*uflx(i3) + c4*uflx(i4)
+
+          utflx(it) = c1*utflx(i1) + c2*utflx(i2) &
+                       + c3*utflx(i3) + c4*utflx(i4)
+
+          uttflx(it) = c1*uttflx(i1) + c2*uttflx(i2) &
+                       + c3*uttflx(i3) + c4*uttflx(i4)
+
+          pav(it) = c1*pav(i1) + c2*pav(i2) &
+                       + c3*pav(i3) + c4*pav(i4)
+
+          eintflx(it) = c1*eintflx(i1) + c2*eintflx(i2) &
+                       + c3*eintflx(i3) + c4*eintflx(i4)
+
+          eflx(it) = c1*eflx(i1) + c2*eflx(i2) &
+                       + c3*eflx(i3) + c4*eflx(i4)
+
+          do n = 1, hy_numXn
+            xnflx(it,n) = c1*xnflx(i1,n) + c2*xnflx(i2,n) &
+                            + c3*xnflx(i3,n) + c4*xnflx(i4,n)
+          enddo
+
+        endif
+
+      enddo
+
+    enddo
+
+
+
+  endif
+
+end subroutine ppm_decode
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_detect.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_detect.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_detect.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_detect.F90	2021-02-14 15:24:26.405762475 -0500
@@ -0,0 +1,227 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/ppm_detect
+!!
+!! NAME
+!! 
+!!  ppm_detect
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!  
+!!  Search for contact discontinuities in variable "a" and
+!!  steepen the zone structure if needed
+!!
+!! ARGUMENTS
+!!
+!!***
+
+subroutine ppm_detect(numCells, numFluxActv, numIntrfcActv, fluxKey, &
+                    intrfcKey, dx, al, a, ar)
+
+  implicit none
+
+  integer, intent(in) :: numCells, numFluxActv, numIntrfcActv
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  real, intent(in), dimension(numCells) :: a, dx
+  real, intent(inout), dimension(numIntrfcActv) :: al, ar
+  logical, dimension(numCells) :: flag
+  integer :: i, j, jlo, klo, khi
+  real :: del1, del2, etamod, u1, u2, u3, dela, ad
+  real, dimension(5) :: sa, sdx
+  real, dimension(numCells) :: eta
+
+  ! the following parameters are set as in Colella and
+  ! Woodward (JCP, 54 (1984), 174), Eqs. 1.17 and 3.2
+
+  real, PARAMETER :: eta1 = 20.e0, eta2 = 0.05e0, epsln = 0.01e0, ak0 = 0.1e0
+
+  !------------------------------------------------------------------------------
+
+  ! initialize flag to tell if we've already done cell
+  flag(:) = .false.
+
+  ! compute discontinuity detection
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+    jlo = fluxKey(i) - 1
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(jlo)
+    khi = intrfcKey(j)
+
+    ! compute contact disc. indicator (left of interface)
+    if (flag(klo).eqv..false.) then
+
+      ! set flag
+      flag(klo) = .true.
+
+      ! get stencil
+      sa = a((klo-2):(klo+2))
+      sdx = dx((klo-2):(klo+2))
+
+      ! compute delta^2 a term for a_{j-1}
+      del1 = 1.0e0 / (sdx(1) + sdx(2) + sdx(3)) &
+              * ((sa(3)-sa(2))/(sdx(3)+sdx(2)) - (sa(2)-sa(1))/(sdx(2)+sdx(1)))
+
+      ! repeat for a_{j+1}
+      del2 = 1.0e0 / (sdx(3) + sdx(4) + sdx(5)) &
+              * ((sa(5)-sa(4))/(sdx(5)+sdx(4)) - (sa(4)-sa(3))/(sdx(4)+sdx(3)))
+
+      ! check condition
+      if (((-del2*del1).gt.0.0e0).and.((abs(sa(4)-sa(2)) &
+            - epsln*min(abs(sa(4)),abs(sa(2)))).gt.0.0e0)) then
+
+          ! compute eta for current cell
+          eta(klo) = -(del2 - del1) / (sdx(4) - sdx(2)) &
+                      * ((sdx(3) - sdx(2))**3.0e0 + (sdx(4) - sdx(3))**3.0e0) &
+                      / (sa(4) - sa(2))
+
+      else
+
+          ! set zero
+          eta(klo) = 0.0e0
+
+      endif
+
+    endif
+
+    !------- compute contact disc. indicator (right of interface) -------!
+
+    ! set flag
+    flag(khi) = .true.
+
+    ! get stencil
+    sa = a((khi-2):(khi+2))
+    sdx = dx((khi-2):(khi+2))
+
+    ! compute delta^2 a term for a_{j-1}
+    del1 = 1.0e0 / (sdx(1) + sdx(2) + sdx(3)) &
+            * ((sa(3)-sa(2))/(sdx(3)+sdx(2)) - (sa(2)-sa(1))/(sdx(2)+sdx(1)))
+
+    ! repeat for a_{j+1}
+    del2 = 1.0e0 / (sdx(3) + sdx(4) + sdx(5)) &
+            * ((sa(5)-sa(4))/(sdx(5)+sdx(4)) - (sa(4)-sa(3))/(sdx(4)+sdx(3)))
+
+    ! check condition
+    if (((-del2*del1).gt.0.0e0).and.((abs(sa(4)-sa(2)) &
+          - epsln*min(abs(sa(4)),abs(sa(2)))).gt.0.0e0)) then
+
+        ! compute eta for current cell
+        eta(khi) = -(del2 - del1) / (sdx(4) - sdx(2)) &
+                    * ((sdx(3) - sdx(2))**3.0e0 + (sdx(4) - sdx(3))**3.0e0) &
+                    / (sa(4) - sa(2))
+
+    else
+
+        ! set zero
+        eta(khi) = 0.0e0
+
+    endif
+
+  enddo
+
+  !------- modify profiles -------!
+
+  ! clear flag
+  flag(:) = .false.
+
+  ! compute limits from quasi-linear profiles
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+    jlo = fluxKey(i) - 1
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(jlo)
+    khi = intrfcKey(j)
+
+    ! compute new left limit
+    if (flag(klo).eqv..false.) then
+
+      ! set flag
+      flag(klo) = .true.
+
+      ! get stencil
+      sa = a((klo-2):(klo+2))
+      sdx = dx((klo-2):(klo+2))
+
+      ! compute eta from tilde eta (eq 1.16)
+      etamod = max(0.0e0,min(eta1*(eta(klo)-eta2),1.0e0))
+
+      ! check condition for modification of profile of left cell
+      if (etamod.gt.0.0) then
+
+        ! compute differences
+        u1 = sa(5) - sa(4)
+        u2 = sa(4) - sa(3)
+
+        ! compute average slope (eq. 1.7 cw84)
+        dela = sdx(4) / (sdx(3) + sdx(4) + sdx(5)) * ((2.0e0*sdx(3) &
+                + sdx(4)) / (sdx(5) + sdx(4)) * u1 &
+                + (sdx(4) + 2.0e0*sdx(5)) / (sdx(3) + sdx(4)) &
+                * u2)
+
+        ! modify this slope (eq. 1.8 cw84)
+        if (u1*u2.gt.0.0e0) then
+          dela = min(min(abs(dela),2.0e0*abs(u1)),2.0e0*abs(u2)) * sign(1.0,dela)
+        else
+          dela = 0.0e0
+        endif
+
+        ! compute contact disc. limit (eq. 1.14 cw84)
+        ad = sa(4) - 0.5*dela
+
+        ! set limit to left of interface (eq. 1.15 cw84)
+        al(j) = al(j)*(1.0e0 - etamod) + ad*etamod
+
+      endif
+
+    endif
+
+    !------- compute right limit always -------!
+
+    ! set flag
+    flag(khi) = .true.
+
+    ! get stencil
+    sa = a((khi-2):(khi+2))
+    sdx = dx((khi-2):(khi+2))
+
+    ! compute eta from tilde eta (eq 1.16)
+    etamod = max(0.0e0,min(eta1*(eta(khi)-eta2),1.0e0))
+
+    ! check condition for modification of profile of left cell
+    if (etamod.gt.0.0) then
+
+      ! compute differences
+      u1 = sa(3) - sa(2)
+      u2 = sa(2) - sa(1)
+
+      ! compute average slope (eq. 1.7 cw84)
+      dela = sdx(2) / (sdx(1) + sdx(2) + sdx(3)) * ((2.0e0*sdx(1) &
+              + sdx(2)) / (sdx(3) + sdx(2)) * u1 &
+              + (sdx(2) + 2.0e0*sdx(3)) / (sdx(1) + sdx(2)) &
+              * u2)
+
+      ! modify this slope (eq. 1.8 cw84)
+      if (u1*u2.gt.0.0e0) then
+        dela = min(min(abs(dela),2.0e0*abs(u1)),2.0e0*abs(u2)) * sign(1.0,dela)
+      else
+        dela = 0.0e0
+      endif
+
+      ! compute contact disc. limit (eq. 1.14 cw84)
+      ad = sa(2) - 0.5*dela
+
+      ! set limit to right of interface (eq. 1.15 cw84)
+      ar(j) = ar(j)*(1.0e0 - etamod) + ad*etamod
+
+    endif
+
+  enddo
+
+end subroutine ppm_detect
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_flatten.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_flatten.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_flatten.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_flatten.F90	2021-02-14 15:24:26.403762417 -0500
@@ -0,0 +1,274 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/ppm_flatten
+!!
+!! NAME
+!!
+!!  ppm_flatten
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!!  Flaten zone structure in regions where shocks are too thin.
+!!  This version of subroutine FLATEN only uses the simplest form
+!!  of dissipation as described in the appendix of Colella and Woodward
+!!  (JCP, 54 (1984), 174). Therefore the only constants required are
+!!  omg1, omg2 and epsiln, which are read in.
+!!
+!!  The "standard" values of the constants are:
+!!
+!!          epsiln = 0.33
+!!
+!!          omg1   = 0.75
+!!          omg2   = 10.0
+!!          sig1   = 0.50
+!!          sig2   = 1.00
+!!          ak1    = 2.00
+!!          ak2    = 0.01
+!!
+!!          wig1   = 2.00
+!!          wig2   = 0.00           for 1-d
+!!                   0.10           for 2-d
+!!          wig3   = 0.3333 - wig2
+!!
+!!
+!!
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine ppm_flatten(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, u, p, e, flatn, flatn1)
+
+  use Hydro_data, ONLY: hy_useShockBurn, hy_epsiln, hy_omg1, hy_omg2, &
+                        hy_igodu,hy_dp,hy_du,hy_smallu,hy_enrflaten !hy_shockd
+
+
+  implicit none
+
+  ! arguments
+  integer, intent(in) :: numCells, numFluxActv, numIntrfcActv
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  real,  intent(in), dimension(numCells) :: u, p, e
+  real,  intent(out), dimension(numFluxActv) :: flatn, flatn1
+
+  ! local variables
+  integer :: i, j, k, kt
+  real :: scrch1,scrch2,scrch3, scrch4
+  real :: du, dup, de
+  real ::  utest, dutest, dp2, dptest, ptest, dpp, ftilde_up
+  real ::  de1, de2, dee
+
+  ! initialize arrays
+  flatn(:) = 0.e0
+  flatn1(:) = 1.e0
+  !hy_shockd(:) = 0.e0
+
+!  ! loop through all active interfaces
+!  do i = 1, numFluxActv ! 2-numIntCells7
+!
+!    ! fine-grid coefficients
+!    j = fluxKey(i)
+!    k = intrfcKey(j)
+!
+!    ! loop through neighbors
+!    do kt = k-3, k+2
+!
+!      ! compute the w_j parameter in Eq. A.1 in Colella & Woodward.  w_j is equal to
+!      ! 1 if the jth zone is inside a pressure and velocity jump in the sweep direction,
+!      ! in a manner consistent with a shock -- store it in hy_shockd
+!      hy_dp(kt) = p(kt+1) - p(kt-1)
+!      hy_du(kt) = u(kt+1) - u(kt-1)
+!      scrch1(kt) = hy_epsiln * min(p(kt+1), p(kt-1)) - abs(hy_dp(kt))
+!      utest = hy_smallu - abs (hy_du(kt))
+!
+!      if (utest .LT. 0.e0) then
+!         dutest = hy_du(kt)
+!      else
+!         dutest = 0.e0
+!      endif
+!
+!      if (scrch1(kt) .LT. 0.e0) then
+!         scrch1(kt) = 1.e0
+!      else
+!         scrch1(kt) = 0.e0
+!      endif
+!
+!      if (hy_du(kt) .GE. 0.e0) scrch1(kt) = 0.e0
+!
+!      if (dutest .EQ. 0.e0) scrch1(kt) = 0.e0
+!
+!      if (hy_useShockBurn) then
+!        scrch4(kt) = 0.e0
+!      else
+!        scrch4(kt) = scrch1(kt)
+!      endif
+!
+!    enddo ! neighbor loop
+!
+!  enddo
+!
+!  do i = 1, numFluxActv ! 3-numIntCells6
+!
+!    ! fine-grid coefficients
+!    j = fluxKey(i)
+!    k = intrfcKey(j)
+!
+!    ! loop through neighbors
+!    do kt = k-2, k+1
+!
+!      ! shock detection
+!      !hy_shockd(kt) = max (scrch4(kt-1), scrch4(kt), scrch4(kt+1))
+!
+!      if(.not. hy_enrflaten) then
+!      ! compute ftilde, using Eq. A.2 in Colella & Woodward
+!      dp2 = p(kt+2) - p(kt-2)
+!
+!      if ( abs(dp2) .GT. 0.e0 ) then
+!      dpp = hy_dp(kt) / dp2 - hy_omg1
+!      else
+!      dpp = 0.e0
+!      end if
+!      scrch3(kt) = scrch1(kt) * max (0.e0, dpp * hy_omg2)
+!      else
+!      ! TAH: Original code only considered dpp in the steepness calculation.
+!      !      We extend this to include the total energy steepness as well.
+!      !      Additionally, we only flatten when the fields are monotonic
+!      !      (i.e. not a saw-tooth profile).
+!      dp2 = p(kt+2) - p(kt-2)
+!      de2 = e(kt+2) - e(kt-2)
+!      de1 = e(kt+1) - e(kt-1)
+!      dpp = 0.e0
+!      dee = 0.e0
+!      if(abs(dp2)>TINY(1.e0)) then
+!      if( (dp2*hy_dp(kt)>0.e0) .and. (abs(hy_dp(kt))<abs(dp2)) ) dpp = hy_dp(kt)/dp2
+!      endif
+!      if(abs(de2)>TINY(1.e0)) then
+!      if( (de2*de1>0.e0) .and. (abs(de1)<abs(de2)) ) dee = de1/de2
+!      endif
+!      scrch3(kt) = scrch1(kt) * max(0.e0, hy_omg2*(max(dpp,dee)-hy_omg1))
+!      endif
+!
+!    enddo ! neighbor loop
+!
+!  enddo
+!
+!  ! select upstream value
+!  do i = 1, numFluxActv ! 4 - numIntCells5
+!
+!    ! fine-grid coefficients
+!    j = fluxKey(i)
+!    k = intrfcKey(j)
+!
+!    ! loop through neighbors
+!    do kt = k-1, k
+!
+!      if ( hy_dp(kt) .LT. 0.e0 ) then
+!        ftilde_up = scrch3(kt+1)
+!      else if ( hy_dp(kt) .EQ. 0.e0 ) then
+!        ftilde_up = scrch3(kt)
+!      else
+!        ftilde_up = scrch3(kt-1)
+!      endif
+!
+!      ! select the maximum flattening
+!      flatn(kt) = max (scrch3(kt), ftilde_up)
+!      flatn(kt) = max (0.e0, min (1.e0, flatn(kt)))
+!
+!      ! select Godunov method, if desired
+!      flatn(kt) = flatn(kt) * (1.e0 - hy_igodu) + hy_igodu
+!      flatn1(kt) = 1.e0 - flatn(kt)
+!
+!    enddo ! neighbor loop
+!
+!  enddo
+
+  ! set flag
+  flag = 4
+
+  do i = 1, numFluxActv
+
+    !------- left flattening coefficients -------!
+
+    ! fine-grid coefficients
+    j = fluxKey(i)
+    kt = intrfcKey(j) - 1
+
+    if (flag.eq.kt) then
+
+      dp = p(kt+1) - p(kt-1)
+      du = u(kt+1) - u(kt-1)
+
+      scrch1 = hy_epsiln * min (p(i+1), p(i-1)) - abs( hy_dp(i) )
+    utest      = hy_smallu - abs (hy_du(i))
+     
+     if (utest .LT. 0.e0) then
+     dutest = hy_du(i)
+     else
+     dutest = 0.e0
+     endif
+
+     if (scrch1(i) .LT. 0.e0) then
+     scrch1(i) = 1.e0
+     else
+     scrch1(i) = 0.e0
+     endif
+
+     if (hy_du(i) .GE. 0.e0) scrch1(i) = 0.e0
+     if (dutest .EQ. 0.e0) scrch1(i) = 0.e0
+
+      if (.not. hy_enrflaten) then
+
+        ! compute ftilde, using Eq. A.2 in Colella & Woodward
+        dp2 = p(kt+2) - p(kt-2)
+        if (abs(dp2).gt.0.e0) then
+          dpp = dp / dp2 - hy_omg1
+        else
+          dpp = 0.e0
+        end if
+        scrch3 = scrch1 * max (0.e0, dpp * hy_omg2)
+
+      else
+
+        ! TAH: Original code only considered dpp in the steepness calculation.
+        !      We extend this to include the total energy steepness as well.
+        !      Additionally, we only flatten when the fields are monotonic
+        !      (i.e. not a saw-tooth profile).
+        dp2 = p(kt+2) - p(kt-2)
+        de2 = e(kt+2) - e(kt-2)
+        de1 = e(kt+1) - e(kt-1)
+        dpp = 0.e0
+        dee = 0.e0
+        if(abs(dp2)>TINY(1.e0)) then
+          if( (dp2*hy_dp(kt)>0.e0) .and. (abs(hy_dp(kt))<abs(dp2)) ) dpp = hy_dp(kt)/dp2
+        endif
+        if(abs(de2)>TINY(1.e0)) then
+          if( (de2*de1>0.e0) .and. (abs(de1)<abs(de2)) ) dee = de1/de2
+        endif
+        scrch3(kt) = scrch1(kt) * max(0.e0, hy_omg2*(max(dpp,dee)-hy_omg1))
+
+      endif
+
+      if ( hy_dp(kt) .LT. 0.e0 ) then
+        ftilde_up = scrch3(kt+1)
+      else if ( hy_dp(kt) .EQ. 0.e0 ) then
+        ftilde_up = scrch3(kt)
+      else
+        ftilde_up = scrch3(kt-1)
+      endif
+
+      ! select the maximum flattening
+      flatn(kt) = max(scrch3(kt), ftilde_up)
+      flatn(kt) = max(0.e0, min (1.e0, flatn(kt)))
+
+      ! select Godunov method, if desired
+      flatn(kt) = flatn(kt) * (1.e0 - hy_igodu) + hy_igodu
+      flatn1(kt) = 1.e0 - flatn(kt)
+
+    enddo
+
+  enddo
+
+end subroutine ppm_flatten
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/PPM.h	2021-02-14 18:14:49.606934150 -0500
@@ -0,0 +1,20 @@
+!!***h* source/physics/Hydro/explicit/split/PPM/PPM.h
+!!
+!! This is the internal header file for the Hydro unit in 
+!! its PPM incarnation.
+!!***
+
+
+#define UPDATE_INTERIOR 0
+#define UPDATE_BOUND 1
+#define UPDATE_ALL 2
+
+!!-----------------------------!!
+!!    RIEMANN SOLVER FLAGS     !!  
+!!-----------------------------!!
+#define EXACTRS 1
+#define HLLE    2
+#define AUSMP   3
+#define AUSMPUP 4
+#define AUSMPUPIT 5
+#define ROEP 6
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_hydro.F90	2021-02-14 16:13:27.197320602 -0500
@@ -1,156 +1,23 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/hydro_1d
+!!****if* source/flashUtilities/wavelet/ppm_hydro
 !!
 !! NAME
 !!
-!!  hydro_1d
+!!  ppm_hydro
 !!
 !!
 !! SYNOPSIS
-!!  
-!!  call hydro_1d(integer(in) :: blockID,
-!!                integer(in) :: numIntCells,
-!!                integer(in) :: numCells, 
-!!                integer(in) :: guard,
-!!                integer(in) :: bcs,
-!!                integer(in) :: xyzswp, 
-!!                integer(in) :: hy_meshMe, 
-!!                real(in)    :: dt, 
-!!                real(in)    :: dt_old,                 
-!!                integer(in) :: jCell, 
-!!                integer(in) :: kCell,                             
-!!                integer(in) :: igeom, 
-!!                logical(in) :: useGravity,                             
-!!                real(in)    :: xbot, 
-!!                real(in)    :: xtop,                               
-!!                real(in)    :: ybot, 
-!!                real(in)    :: ytop, 
-!!                real(in)    :: ylft, 
-!!                real(in)    :: yrgt,                   
-!!                real(in)    :: zlft, 
-!!                real(in)    :: zrgt, 
-!!                real(in)    :: ugrid(numCells),
-!!                real(in)    :: primaryCoord(numCells),
-!!                real(in)    :: primaryLeftCoord(numCells),
-!!                real(in)    :: primaryRghtCoord(numCells),
-!!                real(in)    :: primaryDx(numCells),
-!!                real(in)    :: secondCoord(numCells),
-!!                real(in)    :: thirdCoord(numCells),
-!!                real(in)    :: radialCoord(numCells),
-!!                real(in)    :: u(numCells), 
-!!                real(in)    :: ut(numCells), 
-!!                real(in)    :: utt(numCells), 
-!!                real(in)    :: rho(numCells), 
-!!                real(in)    :: p(numCells),
-!!                real(in)    :: e(numCells),
-!!                real(in)    :: tmp(numCells), 
-!!                real(inout) :: game(numCells), 
-!!                real(inout) :: gamc(numCells),   
-!!                real(inout) :: xn(numCells, hy_numXn), 
-!!                real(inout) :: utbt(numCells), 
-!!                real(inout) :: uttp(numCells),
-!!                real(inout) :: utlt(numCells),
-!!                real(inout) :: utrt(numCells),               
-!!                real(in)    :: shock_multid(numCells),
-!!                real(out)   :: dtdx(numCells), 
-!!                real(inout) :: areaLeft(numCells),
-!!                real(out)   :: area(numCells), 
-!!                real(in)    :: cvol(numCells), 
-!!                real(inout) :: grav(numCells), 
-!!                real(out)   :: ngrav(numCells), 
-!!                real(out)   :: fict(numCells),            
-!!                real(out)   :: rhoflx(numCells),
-!!                real(out)   :: uflx(numCells), 
-!!                real(out)   :: pav(numCells), 
-!!                real(out)   :: utflx(numCells), 
-!!                real(out)   :: uttflx(numCells),
-!!                real(out)   :: eflx(numCells), 
-!!                real(out)   :: eintflx(numCells), 
-!!                real(out)   :: xnflx(numCells,hy_numXn))
 !!
 !! DESCRIPTION
 !!
 !!  Compute the 1-d directionally split fluxes through the boundary
-!!  of the computational zone using the PPM method.   
+!!  of the computational zone using the PPM method.
 !!
 !! ARGUMENTS
 !!
-!!   blockID - my blockID
-!!   numIntCells -
-!!   numCells - 
-!!   guard -  number of guard cells
-!!   bcs -
-!!   xyzswp - the direction of the sweep
-!!   hy_meshMe - the local processor number. 
-!!   dt -   current delta t
-!!   dt_old - delta t from previous step
-!!   jCell -   index that indicates where we are in terms of the
-!!             first transversal coordinate, i.e., index for secondCoord
-!!   kCell -   index that indicates where we are in terms of the
-!!             second transversal coordinate, i.e., index for thirdCoord
-!!   igeom -
-!!   useGravity - indication if gravitational acceleration should be account for
-!!   xbot - 
-!!   xtop -                               
-!!   ybot - 
-!!   ytop - 
-!!   ylft - 
-!!   yrgt -                   
-!!   zlft - 
-!!   zrgt -  Values of secondary and third coordinates (at center) for the 1d arrays of 
-!!                   cells that are directly neighboring the current 1d array being swept.
-!!                   Only used in avisco.
-!! 
-!!   ugrid - 
-!!   primaryCoord -  positions of cell centers of the 1d slice
-!!
-!!   primaryLeftCoord -  positions of left interfaces
-!!
-!!   primaryRghtCoord -  positions of right interfaces
-!!
-!!   primaryDx -  width of cells in the sweep direction
-!!
-!!   secondCoord -  values of the first transverse coordinate to the sweep direction
-!!                   for an x sweep: y coordinates; for a y sweep: x coord; for a z sweep: xcoord
-!!
-!!   thirdCoord -   the second transverse coordinate to the sweep direction
-!!                   for an x sweep: z coordinates; for a y sweep: z coord; for a z sweep: ycoord
-!!
-!!   radialCoord -  The radial coordinate, no matter whether it's primary, second, or third.
-!!                   Actually, this is currently always the IAXIS coordinate.
-!!   u - 
-!!   ut -
-!!   utt -
-!!   rho -
-!!   p -
-!!   e -
-!!   tmp - 
-!!   game - 
-!!   gamc -  
-!!   xn - 
-!!   utbt - 
-!!   uttp -
-!!   utlt - 
-!!   utrt - 
-!!   shock_multid -
-!!   dtdx - 
-!!   areaLeft -
-!!   area - 
-!!   cvol -
-!!   grav -
-!!   ngrav - 
-!!   fict -
-!!   rhoflx - 
-!!   uflx - 
-!!   pav -
-!!   utflx - 
-!!   uttflx - 
-!!   eflx - 
-!!   eintflx -
-!!   xnflx -
-!!   
 !!***
 
-subroutine hydro_1d (blockID,numIntCells,numCells, guard,bcs,        &
+subroutine ppm_hydro(blockID,numIntCells,numCells, numIntrfcActv, numFluxActv, &
+                     intrfcKey, fluxKey, guard,bcs,        &
                      xyzswp, hy_meshMe, dt, dt_old,                 &
                      jCell, kCell,                             &
                      igeom, useGravity,                             &
@@ -166,28 +33,44 @@
                      radialCoord     , &
                      u, ut, utt, rho, p, e, tmp, game, gamc,   &
                      xn, utbt, uttp, utlt, utrt,               &
+                     omgz,                                     &
                      shock_multid,                             &
                      dtdx, areaLeft, area, cvol, grav, ngrav, fict, &
-                     rhoflx, uflx, pav, utflx, uttflx,         &
+                     rhoflx, uflx, pflx, utflx, uttflx,         &
                      eflx, eintflx, xnflx)
 
 
   use Hydro_data, ONLY : hy_dirGeom, hy_movingGrid, hy_useCellAreasForFluxes, &
-       hy_epsiln, hy_omg1, hy_omg2
+                         hy_epsiln, hy_omg1, hy_omg2, &
+                         hy_cfl_crit, hy_cfl_warning, hy_cfl_max, CW_FLX
   use Hydro_data, ONLY : hy_cvisc, hy_useCmaAdvection, hy_smallx, hy_smallp
   use Hydro_data, ONLY : hy_numXn, hy_hybridRiemann, hy_updateHydroFluxes
   use Hydro_data, ONLY : hy_ppmEnerFluxConstructionMeth
-  use Driver_interface, ONLY : Driver_abortFlash
+  use Hydro_data, ONLY : hy_xl_boundary_noflow, hy_xr_boundary_noflow, &
+                         hy_yl_boundary_noflow, hy_yr_boundary_noflow, &
+                         hy_zl_boundary_noflow, hy_zr_boundary_noflow
+  use Hydro_data, ONLY : hy_forceApproxRiemann, hy_RiemannSolver, hy_RiemannSolverHybrid
+  use Hydro_data, ONLY : hy_fluxmask
+  use wvlt_data, ONLY : wvlt_interpHydro
+
+  use Grid_data,  ONLY : gr_imin, gr_imax, gr_jmin, gr_jmax, gr_kmin, gr_kmax
+
+  use Driver_interface,  ONLY : Driver_abortFlash
   use Gravity_interface, ONLY : Gravity_accelOneRow
-  use hy_ppm_interface, ONLY: hy_ppm_force, hy_ppm_geom, hy_ppm_completeGeomFactors
+  use hy_ppm_interface,  ONLY: hy_ppm_force, hy_ppm_geom, hy_ppm_completeGeomFactors
+  use Timers_interface, ONLY : Timers_start, Timers_stop
+
   implicit none
-  
+
 #include "Flash.h"
 #include "constants.h"
+#include "PPM.h"
 
-!--arguments-------------------------
+
+  ! arguments
   integer, intent(IN) ::  blockID,jCell, kCell, numIntCells,numCells,&
                           xyzswp, hy_meshMe,igeom, guard
+  integer, intent(in) :: numIntrfcActv, numFluxActv
   real, intent(IN) :: dt, dt_old
 
   logical, intent(IN) :: useGravity
@@ -207,48 +90,72 @@
   real, DIMENSION(numCells), intent(OUT)   :: area
   real, DIMENSION(numCells, hy_numXn), intent(OUT) :: xnflx
   real, DIMENSION(numCells), intent(OUT) :: dtdx, ngrav, fict
-  real, DIMENSION(numCells), intent(OUT) :: rhoflx, uflx, pav, &
+  real, DIMENSION(numCells), intent(OUT) :: rhoflx, uflx, pflx, &
                                             utflx, uttflx, eflx, eintflx
 
-  
-
   real, DIMENSION(numCells, hy_numXn), intent(INOUT) :: xn
-  real, intent(IN) :: xbot, xtop, ybot 
+  real, intent(IN) :: xbot, xtop, ybot
   real, intent(IN) :: ytop, ylft, yrgt, zlft, zrgt
   real, intent(IN), DIMENSION(numCells) :: ugrid
   real, intent(INOUT), DIMENSION(numCells) :: game, gamc, utbt, &
-                                              uttp, utlt, utrt
-
-
-!--locals-------------------------
-
-  real, DIMENSION(numCells, hy_numXn) :: xnav, xnl, xnr
+                                              uttp, utlt, utrt! , vhalf
+  real, intent(IN), DIMENSION(numCells)    :: omgz
 
-  real, DIMENSION(numCells)    :: rhoav, uav, utav, uttav, eint, &
-              &                   rhol, rhor, ul, ur, utl, utr, uttl, uttr, &
-              &                   pl, pr, vl, vr, gamcl, gamcr, ce, &
-              &                   urell, ugrdl, gameav, gamel, gamer, &
-              &                   eintl, eintr, eintAv, &
-              &                   v, dvol, &
-              &                   ograv, hgrav
-
-
-  
-  real, DIMENSION(numCells) ::  scrch1, scrchEkin
-  real, DIMENSION(numCells) ::  avis
-  real, DIMENSION(numCells) ::  xzn, yzn, zzn
-  real, DIMENSION(numCells) :: xlold, xrold, dxold, dvold, &
-                               alold, aold, arear
-  
-  integer :: i, n, kk
+  ! locals
+  logical :: xl_noflow, xr_noflow
+  integer :: local_RiemannSolver
   integer :: numIntCells4, numIntCells5, numIntCells8
-  
-  real ::  dtfac, dg
-  real ::  c
-
-!  real :: pres_jump
+  integer :: i, n, j, k
+  real ::  dtfac, dg, dudt
+  real :: scrchEkin, c
+  real :: cfl_max
   integer,dimension(2) :: pos
-  
+  real, dimension(numCells) :: ce, eint, &
+                                v, dvol, ograv, hgrav
+  real, DIMENSION(numCells) :: avis
+  real, DIMENSION(numCells) :: xzn, yzn, zzn
+  real, DIMENSION(numCells) :: xlold, xrold, dxold, dvold, &
+                                alold, aold, arear
+
+  ! compressed arrays
+  integer, dimension(numIntrfcActv) :: intrfcKey
+  integer, dimension(numFluxActv) :: fluxKey
+  real, dimension(numFluxActv) :: scrch1
+  real, dimension(numIntrfcActv) :: rho_left, rho_right, u_left, u_right, ut_left, &
+                                    ut_right, utt_left, utt_right, p_left, p_right, &
+                                    gamc_left, gamc_right, game_left, &
+                                    game_right, eint_left, eint_right, &
+                                    grav_left, grav_right, v_left, v_right, &
+                                    pw_left, pw_right
+  real, dimension(numIntrfcActv,hy_numXn) :: xn_left, xn_right
+
+  real, dimension(numFluxActv) :: drho_left, drho_right, du_left, du_right, &
+                                  dut_left, dut_right, dutt_left, dutt_right, &
+                                  dp_left, dp_right, deint_left, deint_right, &
+                                  dgamc_left, dgamc_right, dgame_left, &
+                                  dgame_right, dgrav_left, dgrav_right, dpw_left, &
+                                  dpw_right
+  real, dimension(numFluxActv,hy_numXn) :: dxn_left, dxn_right
+
+  real, dimension(numFluxActv) :: rho6_left, rho6_right, u6_left, &
+                                    u6_right, ut6_left, ut6_right, utt6_left, &
+                                    utt6_right, p6_left, p6_right, eint6_left, &
+                                    eint6_right, gamc6_left, gamc6_right, &
+                                    game6_left, game6_right, grav6_left, &
+                                    grav6_right, pw6_left, pw6_right
+  real, dimension(numFluxActv,hy_numXn) :: xn6_left, xn6_right
+
+  real, dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                    utrght, uttlft, uttrght, plft, &
+                                    prght, eilft, eirght, gmelft, &
+                                    gmerght, gmclft, gmcrght, &
+                                    vlft, vrght
+  real, dimension(numFluxActv,hy_numXn) :: xnlft, xnrght
+
+  real, dimension(numFluxActv) :: rhoav, uav, utav, uttav, &
+                                    pav, gameav, eintav
+  real, dimension(numFluxActv,hy_numXn) :: xnav
+
 #ifndef RHO_FLUX
   call Driver_abortFlash("[HYDRO_1D] ERROR: rhoflx not defined")
 #endif
@@ -271,221 +178,275 @@
   call Driver_abortFlash("[HYDRO_1D] ERROR: eintflx not defined")
 #endif
 
+    numIntCells4 = numIntCells + 4
+    numIntCells5 = numIntCells + 5
+    numIntCells8 = numIntCells + 8
 
-                        ! initialize grav arrays to zero
-  hgrav(:) = 0.e0       ! need to reconsider whether this
-  ngrav(:) = 0.e0       ! is the best place to do this
-
+    !---------------------------
+    if (.NOT. hy_useCellAreasForFluxes) then
+       call hy_ppm_geom (numIntCells, numCells, jCell, kCell, xyzswp, igeom,  &
+            &     areaLeft, arear, area, primaryDx, dvol, &
+            &     primaryLeftCoord, primaryRghtCoord,  &
+            &     radialCoord, thirdCoord)
+    else
+       call hy_ppm_completeGeomFactors(numIntCells4, numCells, igeom, primaryDx, &
+            radialCoord(jCell), dvol, cvol, &
+            area, areaLeft)
+    end if
 
-  numIntCells4 = numIntCells + 4
-  numIntCells5 = numIntCells + 5
-  numIntCells8 = numIntCells + 8
-
-  !---------------------------
-  if (.NOT. hy_useCellAreasForFluxes) then
-     call hy_ppm_geom (numIntCells, numCells, jCell, kCell, xyzswp, igeom,  &
-          &     areaLeft, arear, area, primaryDx, dvol, &
-          &     primaryLeftCoord, primaryRghtCoord,  &
-          &     radialCoord, thirdCoord)
-  else
-     call hy_ppm_completeGeomFactors(numIntCells4, numCells, igeom, primaryDx, &
-          radialCoord(jCell), dvol, cvol, &
-          area, areaLeft)
-  end if
-
-  !---------------------------
-  if (useGravity) then
-     pos(1)=jCell; pos(2)=kCell
+    !---------------------------
+    if (useGravity) then
+       pos(1)=jCell; pos(2)=kCell
 #ifdef GPOL_VAR
 #ifndef GPOT_VAR
-     call Driver_abortFlash("Shouldn't have gpol defined without gpot")
+       call Driver_abortFlash("Shouldn't have gpol defined without gpot")
 #endif
 #endif
 
 #if defined(GPOT_VAR) && defined(GPOL_VAR) && defined(FLASH_GRAVITY_TIMEDEP)
-     ! Gravity implementation defines FLASH_GRAVITY_TIMEDEP -> time-dependent gravity field,
-     ! interpolate the acceleration linearly in time (pointwise) - KW
-     ograv(:) = 0.e0       ! initialize array to zero
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,ograv,GPOL_VAR)
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav,GPOT_VAR)
-     dtfac = dt/dt_old
-
-     do i = 1,numIntCells8
-        dg       = dtfac*(grav(i) - ograv(i))
-        hgrav(i) = grav(i) + 0.5e0*dg
-        ngrav(i) = grav(i) +       dg
-     enddo
+       ! Gravity implementation defines FLASH_GRAVITY_TIMEDEP -> time-dependent gravity field,
+       ! interpolate the acceleration linearly in time (pointwise) - KW
+       ograv(:) = 0.e0       ! initialize array to zero
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,ograv,GPOL_VAR)
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav,GPOT_VAR)
+       dtfac = dt/dt_old
+
+       do i = 1,numIntCells8
+          dg       = dtfac*(grav(i) - ograv(i))
+          hgrav(i) = grav(i) + 0.5e0*dg
+          ngrav(i) = grav(i) +       dg
+       enddo
 
 #else
-     ! FLASH_GRAVITY_TIMEDEP not defined -> assume time-independent gravity field.
-     ! Also if GPOT_VAR or GPOL_VAR defined -> use current accel without time
-     ! interpolation, i.e., handle like time-independent gravity field - KW
-     call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav)
-     hgrav = grav
-     ngrav = grav
+       ! FLASH_GRAVITY_TIMEDEP not defined -> assume time-independent gravity field.
+       ! Also if GPOT_VAR or GPOL_VAR defined -> use current accel without time
+       ! interpolation, i.e., handle like time-independent gravity field - KW
+       call Gravity_accelOneRow (pos, xyzswp, blockID, numIntCells8,grav)
+       hgrav = grav
+       ngrav = grav
 #endif
 
-  else
+    else
 
-     hgrav(:) = 0.e0
-     ngrav(:) = 0.e0
+       hgrav(:) = 0.e0
+       ngrav(:) = 0.e0
 
-  end if
+    end if
 
-  if (hy_updateHydroFluxes) then
+    if (hy_updateHydroFluxes) then
 
     !---------------------------
     ! For non-cartesian geometries, this call sets fict to have non-zero
     ! values.
     !---------------------------
-     call hy_ppm_force(numCells, numIntCells, jCell, kCell, igeom, &
-                primaryCoord, radialCoord, thirdCoord, u, ut, utt, fict)
+    call hy_ppm_force( numCells, numIntCells, jCell, kCell, igeom, &
+                       primaryCoord, radialCoord, thirdCoord, u, ut, utt, fict )
 
-
-    do i = 2, numIntCells8
-       ugrdl(i) = 0.5e0 * (ugrid(i) + ugrid(i-1))
-    end do
-    ugrdl(1) = ugrdl(2)
+    !call userForce( numCells, numIntCells, jCell, kCell, igeom, xyzswp,&
+    !                primaryCoord, radialCoord, secondCoord, thirdCoord,&
+    !                u, ut, utt, omgz, fict )
+
+    !do i = 2, numIntCells8
+    !   ugrdl(i) = 0.5e0 * (ugrid(i) + ugrid(i-1))
+    !end do
+    !ugrdl(1) = ugrdl(2)
 
     do i = 1, numIntCells8
-       v(i)  = 1.e0 / rho(i)
-       c     = sqrt (gamc(i) * p(i) * rho(i))
+       v(i) = 1.e0 / rho(i)
+       c = sqrt(gamc(i) * p(i) * rho(i))
        ce(i) = c*v(i)
     end do
 
 
-    ! Initialization -- grid/geometry factors
-
+    ! initialization -- grid/geometry factors
     do i = 1, numIntCells8
        dtdx(i) = dt / primaryDx(i)
     enddo
 
-    ! Note - if igeom = 3, 4, or 5, the x coordinate will be a radial
+    ! note - if igeom = 3, 4, or 5, the x coordinate will be a radial
     ! coordinate and the index jCell will always refer to the x direction.
-
-    if (igeom >= PHI_CYL) then
-       do i = 1, numIntCells8
-          dtdx(i) = dtdx(i) / radialCoord(jCell)
-       enddo
-    endif
-    if (igeom == PHI_SPH) then
-      do i = 1, numIntCells8
-        dtdx(i) = dtdx(i) / sin(thirdCoord(kCell))
-
-      enddo
-    endif
+    !if (igeom >= PHI_CYL) then
+    !   do i = 1, numIntCells8
+    !      dtdx(i) = dtdx(i) / radialCoord(jCell)
+    !   enddo
+    !endif
 
     ! compute the internal energy - first time
-    do i = 1,numIntCells8 
+    do i = 1,numIntCells8
        eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
        select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,1,4,5)
+       case(0,1,3,4)
           eint(i) = max(eint(i),hy_smallp/rho(i)) !primitive (mass-specific)
-       case(2,6)
+       case(2,5)
           eint(i) = max(eint(i),hy_smallp/rho(i)) * rho(i) !conserved (per-vol)
        end select
     enddo
-!!    hgrav = 0.
-! Obtain PPM interpolation coefficients.
-    call intrfc(xyzswp,numIntCells,numCells, guard,&
-         &      rho,u,ut,utt,p, &
-         &      rhol,rhor,ul,ur, &
-         &      utl,utr,uttl,uttr, &
-         &      pl,pr,vl,vr,gamcl, &
-         &      gamcr,game, &
-         &      gamel,gamer,gamc,hgrav,eint,eintl,eintr,xn, &
-         &      xnl,xnr,v,primaryDx, primaryCoord,tmp)
-
-    ! Determine input states for the Riemann solver.
-    call states (numIntCells,numCells,&
-                 jCell,igeom, &
-                 rho,u,rhol,rhor,ul,ur,&
-                 utl,utr,uttl,uttr,p, pl,pr, &
-                 gamcl,gamcr,&
-                 ugrid,ce,game,gamer,gamc,gamel,&
-                 eintl,eintr, &
-                 xnl,xnr, &
-                 dtdx, dt, &
-                 primaryCoord, primaryLeftCoord, radialCoord, hgrav, fict)
-    ! Solve Riemann problems at zone edges.
-    call rieman(numIntCells,numCells, &
-                rhoav,uav,utav,uttav,pav,&
-                urell,ugrdl,game,gameav,eintAv,xnav,primaryCoord)
 
+    ! obtain PPM interpolation coefficients.
+    call Timers_start("intrfc")
+    call ppm_intrfc(xyzswp,numCells,numFluxActv,numIntrfcActv,fluxKey, &
+                     intrfcKey,primaryDx,primaryCoord,rho,u,ut,utt,p,eint,hgrav,gamc,game,xn, &
+                     rho_left,rho_right,u_left,u_right, ut_left,ut_right,utt_left,utt_right, &
+                     p_left,p_right,eint_left,eint_right, grav_left,grav_right,v_left,v_right, &
+                     gamc_left,gamc_right,game_left,game_right,pw_left,pw_right,xn_left,xn_right, &
+                     drho_left,drho_right,rho6_left,rho6_right,du_left,du_right,u6_left,u6_right, &
+                     dut_left, dut_right, ut6_left, ut6_right, dutt_left, dutt_right, utt6_left, &
+                     utt6_right, dp_left, dp_right, p6_left, p6_right, deint_left, deint_right, &
+                     eint6_left, eint6_right, dgame_left, dgame_right, game6_left, game6_right, &
+                     dgamc_left, dgamc_right, gamc6_left, gamc6_right, dgrav_left, dgrav_right, &
+                     grav6_left, grav6_right, dpw_left, dpw_right, pw6_left, pw6_right, dxn_left, &
+                     dxn_right, xn6_left, xn6_right)
+    call Timers_stop("intrfc")
+
+    ! integrate profiles
+    call Timers_start("states")
+    call ppm_states(numCells, numIntCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                      rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                      rho_left,rho_right,u_left,u_right, &
+                      ut_left,ut_right,utt_left,utt_right, &
+                      p_left,p_right,eint_left,eint_right, &
+                      pw_left,pw_right,game_left,game_right, &
+                      gamc_left,gamc_right, grav_left,grav_right, &
+                      xn_left,xn_right,drho_left,drho_right,rho6_left,rho6_right,du_left,du_right,u6_left,u6_right, &
+                      dut_left, dut_right, ut6_left, ut6_right, dutt_left, dutt_right, utt6_left, &
+                      utt6_right, dp_left, dp_right, p6_left, p6_right, deint_left, deint_right, &
+                      eint6_left, eint6_right, dpw_left, dpw_right, pw6_left, &
+                      pw6_right, dgame_left, dgame_right, game6_left, game6_right, &
+                      dgamc_left, dgamc_right, gamc6_left, gamc6_right, &
+                      dgrav_left, dgrav_right, grav6_left, grav6_right, &
+                      dxn_left, dxn_right, xn6_left, xn6_right,clft, crght, &
+                      ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                      prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                      vlft, vrght, xnlft, xnrght, jCell, igeom, ugrid, ce, &
+                      dtdx, dt, primaryCoord, radialCoord, fict)
+    !endif
+    call Timers_stop("states")
+
+    ! riemann solver (could alternate here)
+    local_RiemannSolver = hy_RiemannSolver
+
+    ! riemann solver
+    call Timers_start("rieman")
+    select case(local_RiemannSolver)
+
+      case(EXACTRS)
+        call ppm_riemann(numCells, numFluxActv, numIntrfcActv, &
+                           fluxKey, intrfcKey, rhoav, uav, utav, uttav, pav, &
+                           eintav, xnav, gameav, clft, crght, &
+                           ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                           prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                           vlft, vrght, xnlft, xnrght, game)
+
+      case default
+      call Driver_abortFlash&
+      ("[Hydro_init]: The Riemann Solver is of unknown type: " // &
+      "Options are exact and that's it right now.")
 
+    end select
+    call Timers_stop("rieman")
+
+    ! special handling of reflecting boundary conditions
+    xl_noflow = .false.
+    xr_noflow = .false.
     select case (xyzswp)
 
     case (SWEEP_X)
-       if (bcs(LOW,IAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,IAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,IAXIS) == REFLECTING) .or. (hy_xl_boundary_noflow .and. primaryCoord(guard) < gr_imin)  ) then
+          uav  (1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,IAXIS) == REFLECTING) .or. (hy_xr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_imax)  ) then
+          uav  (numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
 
     case (SWEEP_Y)
-       if (bcs(LOW,JAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,JAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,JAXIS) == REFLECTING) .or. (hy_yl_boundary_noflow .and. primaryCoord(guard) < gr_jmin)  ) then
+          uav(1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,JAXIS) == REFLECTING) .or. (hy_yr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_jmax)  ) then
+          uav(numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
 
     case (SWEEP_Z)
-       if (bcs(LOW,KAXIS) .eq. REFLECTING) then
-          uav  (guard+1) = 0.e0
-          urell(guard+1) = 0.e0
-       endif
-       if (bcs(HIGH,KAXIS) .eq. REFLECTING) then
-          uav  (guard+numIntCells+1) = 0.e0
-          urell(guard+numIntCells+1) = 0.e0
-       endif
+       if ( (bcs(LOW,KAXIS) == REFLECTING) .or. (hy_zl_boundary_noflow .and. primaryCoord(guard) < gr_kmin)  ) then
+          uav(1) = 0.0e0
+          xl_noflow      = .true.
+       else
+          xl_noflow      = .false.
+       end if
+       if ( (bcs(HIGH,KAXIS) == REFLECTING) .or. (hy_zr_boundary_noflow .and. primaryCoord(guard+numIntCells+1) > gr_kmax)  ) then
+          uav(numFluxActv) = 0.0e0
+          xr_noflow      = .true.
+       else
+          xr_noflow      = .false.
+       end if
+
     end select
 
-    ! -------------------------------------------------------------------
-    ! Consistent Multi-fluid Advection (Plewa & Mueller 1999, CMA   Eq. 13)
+    if(local_RiemannSolver /= EXACTRS) then
+      if(xl_noflow) then
+        rhoflx (guard+1) = 0.0e0
+        uflx   (guard+1) = 0.0e0
+        utflx  (guard+1) = 0.0e0
+        uttflx (guard+1) = 0.0e0
+        eflx   (guard+1) = 0.0e0
+        eintflx(guard+1) = 0.0e0
+      endif
+
+      if(xr_noflow) then
+        rhoflx (guard+numIntCells+1) = 0.0e0
+        uflx   (guard+numIntCells+1) = 0.0e0
+        utflx  (guard+numIntCells+1) = 0.0e0
+        uttflx (guard+numIntCells+1) = 0.0e0
+        eflx   (guard+numIntCells+1) = 0.0e0
+        eintflx(guard+numIntCells+1) = 0.0e0
+      endif
+    endif
 
+    ! consistent Multi-fluid Advection (Plewa & Mueller 1999, CMA   Eq. 13)
     ! mass fractions renormalization and optional limiting (not if CMA)
-
     if ( NSPECIES > 1  ) then
 
-       scrch1(5:numIntCells5) = 0.e0
+      scrch1 = 0.0
 
-       do n = 1, NSPECIES
+      do n = 1, NSPECIES
 
-          ! renormalize and limit mass fractions: note that limiting introduces
-          ! non-conservation of species
+        ! renormalize and limit mass fractions: note that limiting introduces
+        ! non-conservation of species
+        if ( .not.hy_useCmaAdvection ) then
+          do i = 1, numFluxActv
+            xnav(i,n) = max(hy_smallx, min(1.e0, xnav(i,n)))
+          end do
+        end if
 
-          if ( .not.hy_useCmaAdvection ) then
-             do i = 5, numIntCells5
-                xnav(i,n) = max(hy_smallx, min(1.e0, xnav(i,n)))
-             end do
-          end if
+        do i = 1, numFluxActv
+          scrch1(i) = scrch1(i) + xnav(i,n)
+        enddo
 
-          do i = 5, numIntCells5
-             scrch1(i) = scrch1(i) + xnav(i,n)
-          end do
-       end do
+      enddo
 
-       do i = 5, numIntCells5
-          if ( scrch1(i) /= 0.e0 ) scrch1(i) = 1.e0 / scrch1(i)
-       end do
-
-       do n = 1, NSPECIES
-          do i = 5, numIntCells5
-             xnav(i,n) = xnav(i,n) * scrch1(i)
-          end do
-       end do
+      do i = 1, numFluxActv
+        if ( scrch1(i) /= 0.e0 ) scrch1(i) = 1.e0 / scrch1(i)
+      enddo
 
-    end if
+      do n = 1, NSPECIES
+        do i = 1, numFluxActv
+          xnav(i,n) = xnav(i,n) * scrch1(i)
+        end do
+      enddo
 
-    !--------------------------------------------------------------------------
-    ! Save old grid information and move the grid using the previously computed 
-    ! grid velocities (for artificial dissipation purposes).
+    end if
 
     do i = 1, numIntCells8
 !       xlold(i) = primaryLeftCoord(i) !  Use of xlold is commented out below.
@@ -496,102 +457,64 @@
 !       aold(i)  = area(i)       ! aold is never used.
     enddo
 
-    if (hy_movingGrid) then !! this is not defined yet
-!!$       do i = 2, numIntCells8
-!!$          primaryLeftCoord(i)   = xlold(i) + dt * ugrdl(i)
-!!$          primaryRghtCoord(i-1) = primaryLeftCoord(i)
-!!$       enddo
-!!$       
-!!$       do i = 2, numIntCells8
-!!$          primaryCoord(i)  = 0.5e0 * (primaryRghtCoord(i) + primaryLeftCoord(i))    
-!!$          primaryDx(i) = primaryRghtCoord(i) - primaryLeftCoord(i)
-!!$       enddo
-
-!!  This 2nd call to geom should not be necessary - the geometry better not
-!! have changed since the first call above - unless the grid is moving !
-!! The following geom call and the geom implementation may not be correct 
-!! for a moving grid anyway.
-!!$    call hy_ppm_geom (numIntCells, numCells,jCell, kCell, xyzswp, igeom, &
-!!$         &     areaLeft, arear, area, primaryDx, dvol, &
-!!$               primaryLeftCoord, primaryRghtCoord,  &
-!!$               radialCoord, thirdCoord)
-    endif
-
-    !------------------------------------------------------------------------------
-    ! Compute unmodified fluxes for each of the conserved quantities.
-    !
-    !For different ppmEnerFluxConstructionMeth methods, energy fluxes are
-    !constructed here from the following rieman outputs:
-    !
-    !        |                  Rieman results (assuming that urell==uav)
-    ! Method |    used for eintflx         |    used for eflx
-    !==============================================================================
-    !   0    | rhoav,uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   1,2* | rhoav,uav,eintAv,pav        | rhoav,uav,eintAv,pav       ,utav,uttav
-    !   4    | rhoav,uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   5,6* | rhoav,uav,eintAv,    gameav | rhoav,uav,eintAv,    gameav,utav,uttav
-    !Possible optimization:
-    !   0    |       uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   1,2* | rhoav,uav,eintAv,pav        | rhoav,uav,eintAv,pav       ,utav,uttav
-    !   4    |       uav,       pav,gameav | rhoav,uav,       pav,gameav,utav,uttav
-    !   5,6* | rhoav,uav,eintAv,    gameav | rhoav,uav,eintAv,    gameav,utav,uttav
-    !==============================================================================
-    ! * For methods 2 and 6, PPM reconstruction, interpolation, and advection for
-    !   eintAv is applied to a conserved internal energy variable (i.e., internal
-    !   energy expressed in per-volume form). Otherwise, the primitive (specific)
-    !   internal energy is used.
-
-
-    do i = 5, numIntCells5
-       rhoflx(i) = rhoav (i) * urell(i)
-       uflx(i)   = rhoflx(i) * uav  (i)
-       utflx(i)  = rhoflx(i) * utav (i)
-       uttflx(i) = rhoflx(i) * uttav(i)
-
-       select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,4)
+    ! check fluxes for CFL violations
+    cfl_max = max( maxval(abs(uav(:)*dtdx(5))), &
+                   maxval(abs(u(5:numIntCells5)*dtdx(5))) ) 
+    !cfl_max = maxval(abs(uav(:)*dtdx(5)))
+    hy_cfl_max(CW_FLX) = max(cfl_max, hy_cfl_max(CW_FLX))
+    if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_FLX) = .true.
+
+    ! compute unmodified fluxes for each of the conserved quantities.
+    if(local_RiemannSolver == EXACTRS) then
+
+      ! loop through active fluxes
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        rhoflx(k) = rhoav(i)  * uav(i)
+        uflx(k)   = rhoflx(k) * uav(i)
+        utflx(k)  = rhoflx(k) * utav(i)
+        uttflx(k) = rhoflx(k) * uttav(i)
+        pflx(k) = pav(i)
+
+        ! compute the internal energy flux
+        select case (hy_ppmEnerFluxConstructionMeth)
+        case(0,3)
           scrch1(i) = pav(i) / ( rhoav(i) * (gameav(i)-1.e0) )
-       case(1,5)
-          scrch1(i) = eintAv(i)
-       case(2,6)
-          scrch1(i) = eintAv(i) / rhoav(i)
-       end select
+        case(1,4)
+          scrch1(i) = eintav(i)
+        case(2,5)
+          scrch1(i) = eintav(i) / rhoav(i)
+        end select
+
+        ! compute the internal energy flux
+        select case (hy_ppmEnerFluxConstructionMeth)
+        case(0,1,2)
+          eintflx(k) = rhoflx(k) * scrch1(i) + uav(i) * pav(i)
+        case(3,4,5)
+          eintflx(k) = rhoflx(k) * scrch1(i) * gameav(i)
+        end select
 
-       ! compute the internal energy flux
-       
-       select case (hy_ppmEnerFluxConstructionMeth)
-       case(0,1,2)
-          eintflx(i) = rhoflx(i) * scrch1(i) + uav(i) * pav(i)
-       case(4,5,6)
-          eintflx(i) = rhoflx(i) * scrch1(i) * gameav(i) 
-       end select
+        ! add the kinetic energy
+        scrchEkin = 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
 
-       ! add the kinetic energy 
-!!$       scrch1(i) = scrch1(i) &
-!!$            &        + 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
-       scrchEkin(i) = 0.5e0 * (uav(i)**2 + utav(i)**2 + uttav(i)**2)
-
-       ! compute the total energy flux
-!!$       eflx(i)   = rhoflx(i) * scrch1(i) + uav(i) * pav(i)
-       eflx(i)   = eintflx(i) + rhoflx(i) * scrchEkin(i)
+        ! compute the total energy flux
+        eflx(k) = eintflx(k) + rhoflx(k) * scrchEkin
 
-       ! initialize the artificial viscosity coefficient
-    enddo
-999 format(A7,I3,':',9(1P,G16.9,1x))
-!!$    print 999,'eintflx',blockID,eintflx(5:numIntCells5)
-    avis = 0.0
-    ! recompute the internal energy, over the whole structure
-    do i = 1,numIntCells8 
-       eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
-       eint(i) = max(eint(i),hy_smallp/rho(i))
-    enddo
+      enddo
 
-    !------------------------------------------------------------------------------
-    ! Compute quantities needed for artificial viscosity.  Unfortunately in 
-    ! multidimensions this requires some direction-dependent code.
+      ! recompute the internal energy, over the whole structure
+      do i = 1,numIntCells8
+         eint(i) = e(i) - 0.5e0*(u(i)**2 + ut(i)**2 + utt(i)**2)
+         eint(i) = max(eint(i),hy_smallp/rho(i))
+      enddo
 
+    endif
 
-    if (hy_cvisc > 0.e0)  then 
+    if (hy_cvisc > 0.e0)  then
 
        if (xyzswp == SWEEP_X)  then
           xzn(:) = primaryCoord(:)
@@ -610,134 +533,209 @@
        endif
 
        call avisco( jCell, kCell , avis,                              &
-            hy_dirGeom, xyzswp, 5, numIntCells5, NDIM,    &
-            xtop, xbot, ytop, ybot, ylft, yrgt,           &
-            zlft, zrgt,                                       &
-            primaryCoord, primaryLeftCoord, xzn, yzn, zzn,     &
-            u, uttp, utbt, utrt, utlt, hy_cvisc  )
-       
-       ! there should be no flux through a reflecting boundary, so force the 
+                    hy_dirGeom, xyzswp, 5, numIntCells5, NDIM,    &
+                    xtop, xbot, ytop, ybot, ylft, yrgt,           &
+                    zlft, zrgt,                                       &
+                    primaryCoord, primaryLeftCoord, xzn, yzn, zzn,     &
+                    u, uttp, utbt, utrt, utlt, hy_cvisc  )
+
+       ! there should be no flux through a reflecting boundary, so force the
        ! artificial viscosity there to 0
 
-       if (xyzswp == SWEEP_X) then
-          if (bcs(LOW,IAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,IAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
-
-       if (xyzswp == SWEEP_Y) then
-          if (bcs(LOW,JAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,JAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
-       
-       if (xyzswp == SWEEP_Z) then
-          if (bcs(LOW,KAXIS) == &
-               REFLECTING) avis(guard+1) = 0.e0
-          if (bcs(HIGH,KAXIS) == &
-               REFLECTING) avis(guard+numIntCells+1) = 0.e0
-       endif
+       if ( xl_noflow ) avis(guard+1) = 0.e0
+       if ( xr_noflow ) avis(guard+numIntCells+1) = 0.e0
 
        avis(5:numIntCells5) = avis(5:numIntCells5)*alold(5:numIntCells5)
+
+    else
+
+       avis = 0.e0
+
     endif
 
     ! odd-even decoupling fix
     !
     ! now that we've called the accurate Riemann solver, loop over all the zones,
-    ! and for any that is inside a shock, call the HLLE Riemann solver, and 
+    ! and for any that is inside a shock, call the HLLE Riemann solver, and
     ! replace the fluxes computed above with those.  This fixes the odd-even
     ! decoupling problem (see Quirk 1997)
 
-    if (hy_hybridRiemann) then
+    if (hy_hybridRiemann .OR. hy_forceApproxRiemann) then
 
-       do i = 5, numIntCells5
+      ! loop through active flux interfaces
+      do i = 1, numFluxActv
 
-          ! check for the presence of shocks by looking at the artificial viscosity
-          ! and the pressure jump
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        ! check for the presence of shocks by looking at the artificial viscosity
+        ! and the pressure jump
+
+        !!pres_jump = abs(p(i) - p(i-1))/min(p(i),p(i-1))
+
+        !!if (pres_jump >= dp_sh .AND. avis(i) /= 0.e0) then
+        if (((shock_multid(k-1)==1 .OR. shock_multid(k)==1) .AND. (avis(k) /= 0.e0)) .OR. (hy_forceApproxRiemann)) then
+
+          ! the interface between zones i and i-1 is a shock.  Use the HLLE solver
+          ! and replace the fluxes computed above
+
+          !call riemann_hlle(1.e0/vlft(i), 1.e0/vrght(i), &
+          !                  ulft(i),     urght(i),       &
+          !                  utlft(i),    utrght(i),      &
+          !                  uttlft(i),   uttrght(i),     &
+          !                  plft(i),     prght(i),       &
+          !                  e(k-1),      e(k),     &
+          !                  eilft(i),    eirght(i),      &
+          !                  gmelft(i),   gmerght(i),     &
+          !                  gmclft(i),   gmcrght(i),     &
+          !                  0.e0,        0.e0,           &
+          !                  dt,                          &
+          !                  rhoflx(k), uflx(k), utflx(k),&
+          !                  uttflx(k), eflx(k), eintflx(k))
+
+          call riemann_hlle(rho(k-1),    rho(k),    &
+                             u(k-1),      u(k),     &
+                             ut(k-1),     ut(k),    &
+                             utt(k-1),    utt(k),   &
+                             p(k-1),      p(k),     &
+                             e(k-1),      e(k),     &
+                             eint(k-1),   eint(k),  &
+                             game(k-1),   game(k),  &
+                             gamc(k-1),   gamc(k),  &
+                             0.,          0.,       &
+                             dt,                    &
+                             rhoflx(k), uflx(k),    &
+                             utflx(k), uttflx(k),   &
+                             eflx(k), eintflx(k))
 
-!          pres_jump = abs(p(i) - p(i-1))/min(p(i),p(i-1))
+        endif
 
-!          if (pres_jump >= dp_sh .AND. avis(i) /= 0.e0) then
-          if ((shock_multid(i-1)==1 .OR. shock_multid(i)==1) .AND. avis(i) /= 0.e0) then
-
-             ! the interface between zones i and i-1 is a shock.  Use the HLLE solver
-             ! and replace the fluxes computed above
-
-             call riemann_hlle( &
-                  rho(i-1), rho(i), &
-                  u(i-1), u(i), &
-                  ut(i-1), ut(i), &
-                  utt(i-1), utt(i), &
-                  p(i-1), p(i), &
-                  e(i-1), e(i), &
-                  eint(i-1), eint(i), &
-                  game(i-1), game(i), &
-                  gamc(i-1), gamc(i), &
-                  hgrav(i-1), hgrav(i), &
-                  dt, &
-                  rhoflx(i), uflx(i), utflx(i), uttflx(i), eflx(i), eintflx(i))
-             
-          endif
-          
-       enddo
+      enddo
 
-    endif
+      ! For no-flow boundaries, ensure that the fluxes are zero if this is triggered near the boundary
+      if(xl_noflow) then
+        rhoflx (guard+1) = 0.e0
+        uflx   (guard+1) = 0.e0
+        utflx  (guard+1) = 0.e0
+        uttflx (guard+1) = 0.e0
+        eflx   (guard+1) = 0.e0
+        eintflx(guard+1) = 0.e0
+      endif
+
+      if(xr_noflow) then
+        rhoflx (guard+numIntCells+1) = 0.e0
+        uflx   (guard+numIntCells+1) = 0.e0
+        utflx  (guard+numIntCells+1) = 0.e0
+        uttflx (guard+numIntCells+1) = 0.e0
+        eflx   (guard+numIntCells+1) = 0.e0
+        eintflx(guard+numIntCells+1) = 0.e0
+      endif
 
-    ! Do the elemental abundance fluxes.
+    endif ! this is the end of hybrid riemann section
 
+    ! do the elemental abundance fluxes.
     do n = 1, hy_numXn
-       do i = 5, numIntCells5
-          xnflx(i,n) = xnav(i,n) * rhoflx(i)
-       enddo
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        xnflx(k,n) = xnav(i,n) * rhoflx(k)
+
+      enddo
     enddo
 
     !---------------------------------------------------------------
     ! Apply the diffusive fluxes to the unmodified conserved fluxes.
 
-    do i = 5, numIntCells5
-       rhoflx(i) = rhoflx(i) * alold(i)
-       uflx  (i) = uflx  (i) * alold(i)
-       utflx (i) = utflx (i) * alold(i)
-       uttflx(i) = uttflx(i) * alold(i)
-       eflx  (i) = eflx  (i) * alold(i)
-
-       eintflx(i) = eintflx(i)*alold(i)
-
-       rhoflx(i)  = rhoflx(i)  + avis(i) * (rho(i-1)           - rho(i))  
-       uflx  (i)  = uflx  (i)  + avis(i) * (rho(i-1)*u(i-1)    - rho(i)*u(i))
-       utflx (i)  = utflx (i)  + avis(i) * (rho(i-1)*ut(i-1)   - rho(i)*ut(i))
-       uttflx(i)  = uttflx(i)  + avis(i) * (rho(i-1)*utt(i-1)  - rho(i)*utt(i))
-       eflx  (i)  = eflx  (i)  + avis(i) * (rho(i-1)*e(i-1)    - rho(i)*e(i))
-       eintflx(i) = eintflx(i) + avis(i) * (rho(i-1)*eint(i-1) - rho(i)*eint(i))
+    do i = 1, numFluxActv
+
+      ! compute interface indices
+      j = fluxKey(i)
+      k = intrfcKey(j)
+
+      rhoflx(k)  = rhoflx(k)  * alold(k)
+      uflx  (k)  = uflx  (k)  * alold(k)
+      utflx (k)  = utflx (k)  * alold(k)
+      uttflx(k)  = uttflx(k)  * alold(k)
+      eflx  (k)  = eflx  (k)  * alold(k)
+      eintflx(k) = eintflx(k) * alold(k)
+
+      rhoflx(k)  = rhoflx(k)  + avis(k) * (rho(k-1)           - rho(k))
+      uflx  (k)  = uflx  (k)  + avis(k) * (rho(k-1)*u(k-1)    - rho(k)*u(k))
+      utflx (k)  = utflx (k)  + avis(k) * (rho(k-1)*ut(k-1)   - rho(k)*ut(k))
+      uttflx(k)  = uttflx(k)  + avis(k) * (rho(k-1)*utt(k-1)  - rho(k)*utt(k))
+      eflx  (k)  = eflx  (k)  + avis(k) * (rho(k-1)*e(k-1)    - rho(k)*e(k))
+      eintflx(k) = eintflx(k) + avis(k) * (rho(k-1)*eint(k-1) - rho(k)*eint(k))
+
     enddo
 
     do n = 1, hy_numXn
-       do i = 5, numIntCells5
-          xnflx(i,n) = xnflx(i,n) * alold(i)
-          xnflx(i,n) = xnflx(i,n) + &
-                       avis(i) * (rho(i-1)*xn(i-1,n) - rho(i)*xn(i,n))
-       enddo
+      do i = 1, numFluxActv
+
+        ! compute interface indices
+        j = fluxKey(i)
+        k = intrfcKey(j)
+
+        xnflx(k,n) = xnflx(k,n) * alold(k)
+        xnflx(k,n) = xnflx(k,n) + &
+                      avis(k) * (rho(k-1)*xn(k-1,n) - rho(k)*xn(k,n))
+
+      enddo
     enddo
 
-    else
-       fict = 0.0
-    end if
+    ! fill in missing fluxes (decompress the flux calculations)
+    !call Timers_start("ppm_decode")
+    call ppm_decode(numCells, numIntrfcActv, numFluxActv, hy_numXn, hy_fluxmask, &
+                      rhoflx, uflx, utflx, uttflx, &
+                      pflx, eintflx, eflx, xnflx)
+    !call Timers_stop("ppm_decode")
+
+  else
+    fict = 0
+  endif
+
     !------------------------------------------------------------------------------
     ! Store dt/dx, geometry factors, and the modified fluxes in 'global' arrays
     ! for use in updating the solution after all of the 1D sweeps in this direction
     ! are done. Note that dt/dx is not constant in non-Cartesian geometries, so it
     ! is saved for each zone in the tempDtDx() array.
+#ifdef DEBUG_HYDRO
+
+    do i = 5, numIntCells4
+       if (dvol(i) == 0.) print *,'[ppm_hydro] ERROR: dvol == 0, i= ',i,', numIntCells4=',numIntCells4
+    enddo
+#endif
 
     do i = 5, numIntCells4
-       if (dvol(i) == 0.) then
-          print *,' ERROR: dvol == 0 '
-       end if
        dtdx(i) = dt/dvol(i)
+#ifdef DEBUG_HYDRO
+       if ( dtdx(i) /= 0.e0 ) then
+          print *,               '[ppm_hydro] ERROR: dvol=0 '
+          call Driver_abortFlash("[ppm_hydro] ERROR: dvol=0")
+       end if
+#endif
     enddo
+#ifdef ZERO_HYDRO_FLUXES
+
+    ! the same can be achieved by setting updateHydroFluxes false
 
-!===================================================================
-    
-    return
-  end subroutine hydro_1d
+    rhoflx   = 0.e0
+    uflx     = 0.e0
+    utflx    = 0.e0
+    uttflx   = 0.e0
+    eflx     = 0.e0
+    eintflx  = 0.e0
+    xnflx    = 0.e0
+    pav      = 0.e0
+    dtdx     = 0.e0
+    area     = 0.e0
+    grav     = 0.e0
+    ngrav    = 0.e0
+    fict     = 0.e0
+    areaLeft = 1.e0
+#endif
+                         
+end subroutine ppm_hydro
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp_char.F90	2021-02-14 15:24:26.405762475 -0500
@@ -0,0 +1,416 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/interp_char
+!!
+!! NAME
+!! 
+!!  interp_char
+!!
+!! SYNOPSIS
+!!
+!!  call interp_char(integer(IN) :: numIntCells,
+!!                   integer(IN) :: numCells,
+!!                   real(OUT)   :: al(numCells), 
+!!                   real(IN)    :: a(numCells), 
+!!                   real(OUT)   :: ar(numCells), 
+!!                   real(IN)    :: coeff1(numCells), 
+!!                   real(IN)    :: coeff2(numCells), 
+!!                   real(IN)    :: coeff3(numCells), 
+!!                   real(IN)    :: coeff4(numCells), 
+!!                   real(IN)    :: coeff5(numCells))
+!!
+!! DESCRIPTION
+!!
+!!  Interpolate interface values and monotonize.
+!!  We solve eqns (7) and (8) from Colella and Sekora, or equivalantly, eqn (46) combined
+!!  with eqn (38) and (39) from Stone et al.
+!!
+!! ARGUMENTS
+!!
+!! numIntCells :
+!! numCells :
+!! al :
+!! a :
+!! ar :
+!! coeff1 :
+!! coeff2 :
+!! coeff3 :
+!! coeff4 :
+!! coeff5 :
+!!
+!!
+!! SIDE EFFECTS
+!!
+!!  Modifies array hy_dela, which is referenced in subroutine detect.
+!!
+!!***
+
+#define HY_FASTLEFT 1
+#define HY_SLOWLEFT 2
+#define HY_ENTROPY  3
+#define HY_SLOWRGHT 4
+#define HY_FASTRGHT 5
+
+#define HY_DENS 1
+#define HY_VELX 2
+#define HY_VELY 3
+#define HY_VELZ 4
+#define HY_PRES 5
+#define HY_GAMC 6
+#define HY_GAME 7
+
+subroutine ppm_interp_char(sweepDir,numIntCells, numCells, &
+                       numIntrfcActv, key, & 
+                       rhol, rho, rhor, &
+                       ul,   u,   ur,   &
+                       utl,  ut,  utr,  &
+                       uttl, utt, uttr, &
+                       pl,   p,   pr,   &
+                       gamc, game)
+
+
+  use Hydro_data, ONLY:  hy_dela
+                     
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+
+  ! args
+  integer, intent(in) :: sweepDir, numIntCells, numCells, numIntrfcActv
+  integer, intent(in), dimension(numIntrfcActv) :: key
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, gamc, game
+  real, intent(out), dimension(numIntrfcActv) ::  rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr
+
+  ! local
+  integer :: i, j, k
+  integer :: numVars,nWave
+  real :: del1, del2, u1, u2, u3, u4
+  real, dimension(5,5) :: reigL,reig0,reigR,leigL,leig0,leigR
+  real, dimension(5)   :: lambdaL,lambda0,lambdaR,delbarL,delbar0,delbarR
+  real, dimension(7)   :: wLL,wL,w0,wR,wRR
+
+  numVars = 7 ! rho,u,ut,utt,p,gamc,game
+
+  ! set solution vars to zero
+  rhol = 0.
+  rhor = 0.
+  ul   = 0.
+  ur   = 0.
+  utl  = 0.
+  utr  = 0.
+  uttl = 0.
+  uttr = 0.
+  pl   = 0.
+  pr   = 0.
+
+  ! loop through active interfaces
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed interface index
+    i = key(j)
+
+    ! compute differences
+    u1 = rho(i-1) - rho(i-2)
+    u2 = rho(i) - rho(i-1)
+    u3 = rho(i+1) - rho(i)
+    u4 = rho(i-1) + rho(i)
+
+    ! compute average slopes
+    del1 = 0.5e0*(u2 + u1)
+    del2 = 0.5e0*(u3 + u2)
+
+    if (del1.lt.0.0e0) then
+      del1 = -min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    else
+      del1 = min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    endif
+
+    if (-sign(1.0,u1)*sign(1.0,u2).ge.0.0e0) del1 = 0.0e0
+
+    if (del2.lt.0.0e0) then
+      del2 = -min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    else
+      del2 = min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    endif
+
+    if (-sign(1.0,u2)*sign(1.0,u3).ge.0.0e0) del2 = 0.0e0
+
+  end do
+
+  ! compute some common factors
+  !!* We solve eqns (7) and (8) in Colella & Sekora, instead of solving eqn 1.6 from
+  !!  Colella & Woodward (or eqn 12 from Colella & Sekora)
+  !!* We apply limitings to characteristic variables, NOT to primitive variables
+
+  !do i = 3, numIntCells8-2 (3:22)
+
+  do j = 1, numIntrfcActv ! (4:22)
+
+    ! compute uncompressed interface index
+    k = key(j)
+    i = k-1
+
+    select case(sweepDir)
+    case(1)
+       wLL=(/rho(i-2),u(i-2),ut(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),u(i-1),ut(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),u( i ),ut( i ),utt( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),u(i+1),ut(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),u(i+2),ut(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
+
+    case(2)
+       wLL=(/rho(i-2),ut(i-2),u(i-2),utt(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),ut(i-1),u(i-1),utt(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),ut( i ),u( i ),utt( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),ut(i+1),u(i+1),utt(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),ut(i+2),u(i+2),utt(i+2),p(i+2),gamc(i+2),game(i+2)/)
+
+    case(3)
+       wLL=(/rho(i-2),ut(i-2),utt(i-2),u(i-2),p(i-2),gamc(i-2),game(i-2)/)
+       wL =(/rho(i-1),ut(i-1),utt(i-1),u(i-1),p(i-1),gamc(i-1),game(i-1)/)
+       w0 =(/rho( i ),ut( i ),utt( i ),u( i ),p( i ),gamc( i ),game( i )/)
+       wR =(/rho(i+1),ut(i+1),utt(i+1),u(i+1),p(i+1),gamc(i+1),game(i+1)/)
+       wRR=(/rho(i+2),ut(i+2),utt(i+2),u(i+2),p(i+2),gamc(i+2),game(i+2)/)
+    end select
+
+    call eigensystem(sweepDir,wL,reigL,leigL,lambdaL)
+    call eigensystem(sweepDir,w0,reig0,leig0,lambda0)
+    call eigensystem(sweepDir,wR,reigR,leigR,lambdaR)
+
+    ! One can use a different slope limiter - default is MC limiter
+    do nWave = HY_FASTLEFT,HY_FASTRGHT
+       delbarL(nWave) = &
+            mc(dot_product(leigL(nWave,HY_DENS:HY_PRES),wL(HY_DENS:HY_PRES)-wLL(HY_DENS:HY_PRES)),&
+               dot_product(leigL(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL (HY_DENS:HY_PRES)))
+
+
+       delbar0(nWave) = &
+            mc(dot_product(leig0(nWave,HY_DENS:HY_PRES),w0(HY_DENS:HY_PRES)-wL(HY_DENS:HY_PRES)),&
+               dot_product(leig0(nWave,HY_DENS:HY_PRES),wR(HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)))
+
+
+       delbarR(nWave) = &
+            mc(dot_product(leigR(nWave,HY_DENS:HY_PRES),wR (HY_DENS:HY_PRES)-w0(HY_DENS:HY_PRES)),&
+               dot_product(leigR(nWave,HY_DENS:HY_PRES),wRR(HY_DENS:HY_PRES)-wR(HY_DENS:HY_PRES)))
+    enddo
+
+
+    delbarL(HY_DENS:HY_PRES) = reigL(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarL(HY_FASTLEFT)+&
+                               reigL(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarL(HY_SLOWLEFT)+&
+                               reigL(HY_DENS:HY_PRES,HY_ENTROPY) *delbarL(HY_ENTROPY) +&
+                               reigL(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarL(HY_SLOWRGHT)+&
+                               reigL(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarL(HY_FASTRGHT)
+
+
+    delbar0(HY_DENS:HY_PRES) = reig0(HY_DENS:HY_PRES,HY_FASTLEFT)*delbar0(HY_FASTLEFT)+&
+                               reig0(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbar0(HY_SLOWLEFT)+&
+                               reig0(HY_DENS:HY_PRES,HY_ENTROPY) *delbar0(HY_ENTROPY) +&
+                               reig0(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbar0(HY_SLOWRGHT)+&
+                               reig0(HY_DENS:HY_PRES,HY_FASTRGHT)*delbar0(HY_FASTRGHT)
+
+    delbarR(HY_DENS:HY_PRES) = reigR(HY_DENS:HY_PRES,HY_FASTLEFT)*delbarR(HY_FASTLEFT)+&
+                               reigR(HY_DENS:HY_PRES,HY_SLOWLEFT)*delbarR(HY_SLOWLEFT)+&
+                               reigR(HY_DENS:HY_PRES,HY_ENTROPY) *delbarR(HY_ENTROPY) +&
+                               reigR(HY_DENS:HY_PRES,HY_SLOWRGHT)*delbarR(HY_SLOWRGHT)+&
+                               reigR(HY_DENS:HY_PRES,HY_FASTRGHT)*delbarR(HY_FASTRGHT)
+
+    ! Parabolic interpolation at the left and right cell interfaces
+    ! Colella-Woodward Eqn 1.9, Sekora-Colella Eqn 7, Stone et al Eqn 46
+    wLL(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wL(HY_DENS:HY_PRES)) &
+         - (delbar0(HY_DENS:HY_PRES)-delbarL(HY_DENS:HY_PRES))/6.
+
+    wRR(HY_DENS:HY_PRES) = 0.5*(w0(HY_DENS:HY_PRES)+wR(HY_DENS:HY_PRES)) &
+         - (delbarR(HY_DENS:HY_PRES)-delbar0(HY_DENS:HY_PRES))/6.
+
+
+    ! Ensure that the interpolated values lie between the cell-centered values
+    do nWave=HY_DENS,HY_PRES
+       wLL(nWave) = max(min(w0(nWave),wL(nWave)),wLL(nWave))
+       wLL(nWave) = min(max(w0(nWave),wL(nWave)),wLL(nWave))
+       wRR(nWave) = max(min(w0(nWave),wR(nWave)),wRR(nWave))
+       wRR(nWave) = min(max(w0(nWave),wR(nWave)),wRR(nWave))
+    enddo
+
+    ! Prepare outputs
+    if (j.gt.1) rhor(j-1) = wLL(HY_DENS)
+    if (j.gt.1) pr(j-1)   = wLL(HY_PRES)
+
+    rhol(j) = wRR(HY_DENS)
+    pl(j)   = wRR(HY_PRES)
+
+    select case(sweepDir)
+    case(1)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELX)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELY)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELZ)
+
+       ul(j)   = wRR(HY_VELX)
+       utl(j)  = wRR(HY_VELY)
+       uttl(j) = wRR(HY_VELZ)
+
+    case(2)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELY)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELX)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELZ)
+
+       ul(j)   = wRR(HY_VELY)
+       utl(j)  = wRR(HY_VELX)
+       uttl(j) = wRR(HY_VELZ)
+    case(3)
+       if (j.gt.1) ur(j-1)   = wLL(HY_VELZ)
+       if (j.gt.1) utr(j-1)  = wLL(HY_VELX)
+       if (j.gt.1) uttr(j-1) = wLL(HY_VELY)
+
+       ul(j)   = wRR(HY_VELZ)
+       utl(j)  = wRR(HY_VELX)
+       uttl(j) = wRR(HY_VELY)
+    end select
+
+  enddo
+
+
+
+  contains
+
+    subroutine eigensystem(sweepDir,W,reig,leig,lambda)
+
+      implicit none
+      integer, intent(IN) :: sweepDir
+      real, intent(IN),dimension(7) :: W
+      real, intent(OUT), dimension(5,5) :: reig,leig
+      real, intent(OUT), dimension(5)   :: lambda
+
+
+      real :: a  ! sound speed
+      real :: uN ! normal velocity
+      real :: dinv
+
+      select case(sweepDir)
+      case(1)
+         uN = W(HY_VELX)
+      case(2)
+         uN = W(HY_VELY)
+      case(3)
+         uN = W(HY_VELZ)
+      end select
+
+      ! sound velocity
+      a = sqrt(W(HY_GAMC)*W(HY_PRES)/W(HY_DENS))
+
+      ! eigen value
+      lambda(HY_FASTLEFT:HY_FASTRGHT) = (/uN-a,uN,uN,uN,uN+a/)
+
+
+      dinv = 1./W(HY_DENS)
+
+      reig = 0.
+      leig = 0.
+
+      ! right eigenvectors: reig(1:nVars,1:nWave)
+      reig(HY_DENS,HY_FASTLEFT) = W(HY_DENS)
+      reig(HY_DENS,HY_FASTRGHT) = W(HY_DENS)
+
+      select case(sweepDir)
+      case(1)
+         reig(HY_VELX,HY_FASTLEFT)= -a
+         reig(HY_VELX,HY_FASTRGHT)=  a
+
+         reig(HY_VELY,HY_SLOWLEFT)= -dinv
+         reig(HY_VELZ,HY_SLOWRGHT)=  dinv
+
+      case(2)
+         reig(HY_VELY,HY_FASTLEFT)= -a
+         reig(HY_VELY,HY_FASTRGHT)=  a
+
+         reig(HY_VELX,HY_SLOWLEFT)=  dinv
+         reig(HY_VELZ,HY_SLOWRGHT)= -dinv
+
+      case(3)
+         reig(HY_VELZ,HY_FASTLEFT)= -a
+         reig(HY_VELZ,HY_FASTRGHT)=  a
+
+         reig(HY_VELX,HY_SLOWLEFT)= -dinv
+         reig(HY_VELY,HY_SLOWRGHT)=  dinv
+      end select
+      reig(HY_PRES,HY_FASTLEFT) =  W(HY_DENS)*a*a
+      reig(HY_PRES,HY_FASTRGHT) =  W(HY_DENS)*a*a
+
+
+      ! entropy wave
+      reig(HY_DENS,HY_ENTROPY) = 1.
+
+
+      ! left eigenvectors: leig(1:nWave,1:nVars)
+      select case(sweepDir)
+      case(1)
+         leig(HY_FASTLEFT,HY_VELX)= -a
+         leig(HY_FASTRGHT,HY_VELX)=  a
+
+         leig(HY_SLOWLEFT,HY_VELY)= -W(HY_DENS)
+         leig(HY_SLOWRGHT,HY_VELZ)=  W(HY_DENS)
+
+
+      case(2)
+         leig(HY_FASTLEFT,HY_VELY)= -a
+         leig(HY_FASTRGHT,HY_VELY)=  a
+
+         leig(HY_SLOWLEFT,HY_VELX)=  W(HY_DENS)
+         leig(HY_SLOWRGHT,HY_VELZ)= -W(HY_DENS)
+      case(3)
+         leig(HY_FASTLEFT,HY_VELZ)= -a
+         leig(HY_FASTRGHT,HY_VELZ)=  a
+
+         leig(HY_SLOWLEFT,HY_VELX)= -W(HY_DENS)
+         leig(HY_SLOWRGHT,HY_VELY)=  W(HY_DENS)
+      end select
+
+      leig(HY_FASTLEFT, HY_PRES) =  dinv
+      leig(HY_FASTRGHT, HY_PRES) =  dinv
+
+
+      ! scale fast waves with 1/2*a^2
+      leig(HY_FASTLEFT,:) = 0.5/a**2*leig(HY_FASTLEFT,:)
+      leig(HY_FASTRGHT,:) = 0.5/a**2*leig(HY_FASTRGHT,:)
+
+      ! entropy wave
+      leig(HY_ENTROPY,HY_DENS) = 1.
+      leig(HY_ENTROPY,HY_PRES) =-1./a**2
+
+
+
+    end subroutine eigensystem
+
+
+    function vanLeer(a,b)
+      implicit none
+      real :: a,b,vanLeer
+      if (a*b <=0.) then
+         vanLeer=0.
+      else
+         vanLeer=2.*a*b/(a+b)
+      endif
+    end function vanLeer
+
+
+    function mc(a,b)
+      implicit none
+      real :: a,b,mc
+      mc = (sign(1.,a)+sign(1.,b))*min(abs(a),.25*abs(a+b),abs(b))
+    end function mc
+
+
+    function minmod(a,b)
+      implicit none
+      real :: a,b,minmod
+      minmod=.5 * (sign(1.,a) + sign(1.,b))*min(abs(a),abs(b))
+    end function minmod
+
+
+    function signum(x)
+      implicit none
+      real :: x,signum
+      signum=sign(.5,x)-sign(.5,-x)
+    end function signum
+
+
+
+  end subroutine ppm_interp_char
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90	2021-02-22 23:57:38.576465142 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_interp.F90	2021-02-14 15:36:10.331229799 -0500
@@ -6,16 +6,17 @@
 !!
 !! SYNOPSIS
 !!
-!!  call interp(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells,
-!!              real(OUT)   :: al(numCells), 
-!!              real(IN)    :: a(numCells), 
-!!              real(OUT)   :: ar(numCells), 
-!!              real(IN)    :: coeff1(numCells), 
-!!              real(IN)    :: coeff2(numCells), 
-!!              real(IN)    :: coeff3(numCells), 
-!!              real(IN)    :: coeff4(numCells), 
-!!              real(IN)    :: coeff5(numCells))
+!!  call interp(integer(in) :: numIntCells,
+!!              integer(in) :: numCells,
+!!              real(out)   :: al(numCells), 
+!!              real(in)    :: a(numCells), 
+!!              real(in)    :: dx(numCells), 
+!!              real(out)   :: ar(numCells), 
+!!              real(in)    :: coeff1(numCells), 
+!!              real(in)    :: coeff2(numCells), 
+!!              real(in)    :: coeff3(numCells), 
+!!              real(in)    :: coeff4(numCells), 
+!!              real(in)    :: coeff5(numCells))
 !!
 !! DESCRIPTION
 !!
@@ -27,6 +28,7 @@
 !! numCells :
 !! al :
 !! a :
+!! dx :
 !! ar :
 !! coeff1 :
 !! coeff2 :
@@ -41,69 +43,61 @@
 !!
 !!***
 
-subroutine interp (numIntCells, numCells, al, a, ar, &
-                   coeff1, coeff2, coeff3, coeff4, coeff5)
+subroutine ppm_interp(numCells, numIntrfcActv, al, a, ar, key)
 
+  !-----------------------------------------------------------------------------
 
-  use Hydro_data, ONLY:  hy_dela
-                     
   implicit none
-  integer, intent(IN) :: numIntCells, numCells
-  real, intent(IN), DIMENSION(numCells) ::  a, coeff1, coeff2, coeff3, coeff4, coeff5
-  real, intent(OUT), DIMENSION(numCells) ::  al, ar
-  
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4
-  integer :: i, numIntCells5, numIntCells6, numIntCells8
-
-    numIntCells5 = numIntCells + 5
-    numIntCells6 = numIntCells + 6
-    numIntCells8 = numIntCells + 8
-    
-
-! compute some common factors
-! DONGWOOK: HERE, WE NEED TO USE CHARACTERISTIC VARIABLES FOR DIFFERENCING, NOT PRIMITIVE VARIABLES,
-!           BY MULTIPLYING LEFT EIGENVECTORS TO PRIMITIVE VARIABLES
-    do i = 2, numIntCells8
-       scrch1(i) = a(i) - a(i-1)
-       scrch2(i) = abs ( scrch1(i) + scrch1(i) )
-       scrch4(i) = sign (1.e00, scrch1(i))
-    end do
-
-
-! apply Eq. 1.8 of Colella & Woodward -- guarantee that a(i+1/2) lies
-! between a(i) and a(i+1)
-    
-    do i = 2, numIntCells6+1
-       hy_dela(i)   = coeff1(i) * scrch1(i+1) + coeff2(i) * scrch1(i)
-       
-       if (hy_dela(i) .LT. 0.e0) then
-          scrch3(i) = -1.e0
-       else
-          scrch3(i) = 1.e0
-       endif
-       
-       hy_dela(i)   = min(abs(hy_dela(i)), scrch2(i), scrch2(i+1))* scrch3(i)
-! DONGWOOK: AFTER THIS, WE THEN NEED TO PROJECT CHARACTERISTIC VARIABLES ONTO 
-!           PRIMITIVE VARIABLES BY MULTIPLYING RIGHT EIGENVECTORS
-       if (-scrch4(i)*scrch4(i+1) >= 0.e0) hy_dela(i) = 0.e0
-       
-    end do
-
-
-! assemble the left and right interface values using the quartic polynomial,
-! Eq. 1.6 from Colella & Woodward
-    
-    do i = 2, numIntCells6
-       ar(i)  = a (i) + coeff5(i) * scrch1(i+1) + coeff3(i) * hy_dela(i+1)
-       ar(i)  = ar(i) + coeff4(i) * hy_dela(i)
-       al(i+1)= ar(i)
-    end do
-    
-    return
-  end subroutine interp
-
-
-
 
+  ! arguments
+  integer, intent(in) :: numCells, numIntrfcActv
+  integer, intent(in), dimension(numIntrfcActv) :: key
+  real, intent(in), dimension(numCells) ::  a
+  real, intent(out), dimension(numIntrfcActv) ::  al, ar
+
+  ! local
+  real :: del1, del2, u1, u2, u3, u4
+  integer :: i, j
+
+  !-----------------------------------------------------------------------------
+
+  ! loop through active interfaces
+  do j = 1, numIntrfcActv
+
+    ! compute uncompressed interface index
+    i = key(j)
+
+    ! compute differences
+    u1 = a(i-1) - a(i-2)
+    u2 = a(i) - a(i-1)
+    u3 = a(i+1) - a(i)
+    u4 = a(i-1) + a(i)
+
+    ! compute average slopes
+    del1 = 0.5e0*(u2 + u1)
+    del2 = 0.5e0*(u3 + u2)
+
+    ! enforce eq. 1.8 for da_{j}
+    if (del1.lt.0.0e0) then
+      del1 = -min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    else
+      del1 = min(abs(del1),abs(2.0*u1),abs(2.0*u2)) !sign(min(min(abs(del1),2.0*abs(u1)),2.0*abs(u2)),del1)
+    endif
+
+    if (-sign(1.0,u1)*sign(1.0,u2).ge.0.0e0) del1 = 0.0e0
+
+    if (del2.lt.0.0e0) then
+      del2 = -min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    else
+      del2 = min(abs(del2),abs(2.0*u2),abs(2.0*u3)) !sign(min(min(abs(del2),2.0*abs(u1)),2.0*abs(u2)),del2)
+    endif
+
+    if (-sign(1.0,u2)*sign(1.0,u3).ge.0.0e0) del2 = 0.0e0
+
+    ! compute final right and left states (of the target interface)
+    al(j) = 0.5e0*u4 + (del1 - del2) * 0.166666666666666666e0
+    ar(j) = al(j)
 
+  enddo
 
+end subroutine ppm_interp
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_intrfc.F90	2021-02-14 15:24:26.405762475 -0500
@@ -1,61 +1,20 @@
 !!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/intrfc
 !!
 !! NAME
-!! 
-!!  subroutine intrfc
-!!
 !!
 !! SYNOPSIS
 !!
-!!  call intrfc(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells,
-!!              integer(IN) :: guard,
-!!              real(IN)    :: rho(numCells),
-!!              real(IN)    :: u(numCells),
-!!              real(IN)    :: ut(numCells),
-!!              real(IN)    :: utt(numCells),
-!!              real(IN)    :: p(numCells),
-!!              real(INOUT) :: rhol(numCells),
-!!              real(INOUT) :: rhor(numCells),
-!!              real(INOUT) :: ul(numCells),
-!!              real(INOUT) :: ur(numCells),
-!!              real(INOUT) :: utl(numCells),
-!!              real(INOUT) :: utr(numCells),
-!!              real(INOUT) :: uttl(numCells),
-!!              real(INOUT) :: uttr(numCells),
-!!              real(INOUT) :: pl(numCells),
-!!              real(INOUT) :: pr(numCells),
-!!              real(OUT)   :: vl(numCells),
-!!              real(OUT)   :: vr(numCells),
-!!              real(INOUT) :: gamcl(numCells),
-!!              real(INOUT) :: gamcr(numCells),
-!!              real(IN)    :: game(numCells),
-!!              real(INOUT) :: gamel(numCells),
-!!              real(INOUT) :: gamer(numCells),
-!!              real(IN)    :: gamc(numCells),
-!!              real(IN)    :: grav(numCells),
-!!              real(IN)    :: eint(numCells),
-!!              real(INOUT) :: eintl(numCells),
-!!              real(INOUT) :: eintr(numCells),
-!!              real(IN)    :: xn(numCells, hy_numXn),
-!!              real(INOUT) :: xnl(numCells, hy_numXn),
-!!              real(INOUT) :: xnr(numCells, hy_numXn),
-!!              real(OUT)   :: v(numCells),
-!!              real(IN)    :: dx(numCells),
-!!              real(IN)    :: x(numCells))
-!!
-!! 
 !! DESCRIPTION
-!!  
+!!
 !!  Calculate zone interface values of all variables.  Start by using a
 !!  high order polynomial to interpolate the zone average values to the
-!!  interface (Fry. Eq. 24).  The coefficients of this polynomial are 
-!!  constructed (by coeff() ) such that the polynomial reproduces the 
+!!  interface (Fry. Eq. 24).  The coefficients of this polynomial are
+!!  constructed (by coeff() ) such that the polynomial reproduces the
 !!  correct average values in each zone.
 !!
-!!  Once the coefficients are computed, the first guess at the interface 
-!!  values are made, and monotonicity must be enforced.  We need to ensure 
-!!  that the interface value does not fall outside the range of the 
+!!  Once the coefficients are computed, the first guess at the interface
+!!  values are made, and ppm_profileonicity must be enforced.  We need to ensure
+!!  that the interface value does not fall outside the range of the
 !!  adjacent zone average values --  this procedure is handled by interp()
 !!
 !!  intrfc() then looks for contact discontinuities (through detect() ) and
@@ -63,320 +22,248 @@
 !!  mass fractions.
 !!
 !!  Next, shocks are flattened if they are too thin, via flaten().  Shocks
-!!  that are too thin are not treated accurately, and oscillations can result. 
+!!  that are too thin are not treated accurately, and oscillations can result.
 !!  Flattening is applied to any shocks which are only one zone wide.
 !!  No flattening should be used for gravitational accelerations.
 !!
 !!  Finally, we need to ensure that the parabolic reconstruction of the
-!!  zone data is monotonic -- each point in the parabolic is required to
-!!  fall between the two zone interface values -- this procedure is 
-!!  handled by monot().
+!!  zone data is ppm_profileonic -- each point in the parabolic is required to
+!!  fall between the two zone interface values -- this procedure is
+!!  handled by ppm_profile().
 !!
 !! ARGUMENTS
 !!
-!!  numIntCells :
-!!  numCells :
-!!  guard :
-!!  rho(numCells) :
-!!  u(numCells) :
-!!  ut(numCells) :
-!!  utt(numCells) :
-!!  p(numCells) :
-!!  rhol(numCells) :
-!!  rhor(numCells) :
-!!  ul(numCells) :
-!!  ur(numCells) :
-!!  utl(numCells) :
-!!  utr(numCells) :
-!!  uttl(numCells) :
-!!  uttr(numCells) :
-!!  pl(numCells) :
-!!  pr(numCells) :
-!!  vl(numCells) :
-!!  vr(numCells) :
-!!  gamcl(numCells) :
-!!  gamcr(numCells) :
-!!  game(numCells) :
-!!  gamel(numCells) :
-!!  gamer(numCells) :
-!!  gamc(numCells) :
-!!  grav(numCells) :
-!!  eint(numCells) :
-!!  eintl(numCells) :
-!!  eintr(numCells) :
-!!  xn :
-!!  xnl :
-!!  xnr :
-!!  v :
-!!  dx(numCells) :
-!!  x(numCells) :
-!!
+!! NOTES
 !!
 !!***
 
-  subroutine intrfc(sweepDir,numIntCells, numCells, guard, &
-       &            rho, u, ut, utt, p, &
-       &            rhol, rhor, ul, ur, &
-       &            utl, utr, uttl, uttr, &
-       &            pl, pr, vl, vr, gamcl, &
-       &            gamcr, game, &
-       &            gamel,gamer,gamc,grav, eint, eintl, eintr, xn, &
-       &            xnl, xnr, v, dx, x,tmp)
-
-  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, hy_gravl, &
-                           hy_drho, hy_rho6, &
-                           hy_du, hy_u6, hy_dut, hy_ut6, &
-                           hy_dutt, hy_utt6, hy_dp, hy_dgame, hy_game6, &
-                           hy_gravr, hy_p6, hy_dgamc, hy_gamc6, hy_dgrav, &
-                           hy_grav6, hy_dxn, hy_xn6, &
-                           hy_deint, hy_eint6, &
-                           hy_pwcubic, hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, &
-                           hy_ppmModifystates, &
-                           hy_useSteepening, hy_useCmaFlattening,&
-                           hy_epsiln, hy_omg1, hy_omg2, hy_charLimiting
-
+  subroutine ppm_intrfc(sweepDir, numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, dx, x, &
+                          rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                          rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr, &
+                          eintl, eintr, gravl, gravr, vl, vr, gamcl, gamcr, &
+                          gamel, gamer, pwl, pwr, xnl, xnr, drhol, drhor, rho6l, &
+                          rho6r, dul, dur, u6l, u6r, dutl, dutr, ut6l, ut6r, duttl, &
+                          duttr, utt6l, utt6r, dpl, dpr, p6l, p6r, deintl, &
+                          deintr, eint6l, eint6r, dgamel, dgamer, game6l, &
+                          game6r, dgamcl, dgamcr, gamc6l, gamc6r, dgravl, &
+                          dgravr, grav6l, grav6r, dpwl, dpwr, pw6l, pw6r, &
+                          dxnl, dxnr, xn6l, xn6r)
+
+  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, &
+                           hy_ppmModifystates, hy_useSteepening, &
+                           hy_useCmaFlattening, hy_enrFlattening, hy_epsiln, &
+                           hy_omg1, hy_omg2, hy_charLimiting, hy_flatn, &
+                           hy_igodu, hy_useFlattening
+
+!  use Hydro_data,   ONLY:  hy_numXn, hy_smlrho, hy_smallx, hy_small, &
+!                           hy_pwcubic, hy_pwl, hy_pwr, hy_ppmModifystates, &
+!                           hy_useSteepening, hy_useCmaFlattening, hy_enrFlattening, &
+!                           hy_epsiln, hy_omg1, hy_omg2, hy_charLimiting
 
+  !use Timers_interface, ONLY : Timers_start, Timers_stop
 
   implicit none
-!!------ARGUMENTS-------------------
-#include "Flash.h"
 
+#include "Flash.h"
 
-  integer, intent(IN) :: sweepDir,numIntCells, numCells, guard
-  real, intent(IN),    DIMENSION(numCells,hy_numXn) :: xn
-  real, intent(INOUT), DIMENSION(numCells,hy_numXn) :: xnl, xnr
-  real, intent(IN), DIMENSION(numCells) :: &
-       rho, u, ut, utt, p, gamc, game, grav, eint, dx, x,tmp
-  real, intent(INOUT), DIMENSION(numCells) :: &
-       rhol, rhor, &
-       ul, ur, &
-       utl, utr, &
-       uttl, uttr, &
-       pl, pr,&
-       gamcl, gamcr, &
-       gamel, gamer, &
-       eintl, eintr
-  real, intent(OUT), DIMENSION(numCells) :: &
-       v, vl, vr
-       
-
-!! ----LOCAL ----------------
-  real,dimension(numCells) :: rhog, rhogl, rhogr, drhog, rg6,&
-                              coeff1, coeff2, coeff3, coeff4, coeff5, &
-                              flatn, flatn1
-
-  
-  integer :: i, j, k, n, numIntCells5
-  
+  ! arguments associated with cell-average data
+  integer, intent(in) :: sweepDir, numFluxActv, numIntrfcActv, numCells
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, &
+                                            gamc, game, grav, eint, dx, x
+  real, intent(in), dimension(numCells,hy_numXn) :: xn
+
+  ! arguments for compressed fluxes/reconstruction
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  real, intent(inout), dimension(numIntrfcActv) :: rhol, rhor, ul, ur, &
+                                                   utl, utr, uttl, uttr, &
+                                                   pl, pr, eintl, eintr, &
+                                                   gravl, gravr, vl, vr, &
+                                                   gamcl, gamcr, gamel, &
+                                                   gamer, pwl, pwr
+  real, intent(inout), dimension(numIntrfcActv,hy_numXn) :: xnl, xnr
+  real, intent(inout), dimension(numFluxActv) :: drhol, drhor, rho6l, rho6r, &
+                                                  dul, dur, u6l, u6r, dutl, dutr, &
+                                                  ut6l, ut6r, duttl, duttr, utt6l, &
+                                                  utt6r, dpl, dpr, p6l, p6r, deintl, &
+                                                  deintr, eint6l, eint6r, dgamel, &
+                                                  dgamer, game6l, game6r, dgamcl, &
+                                                  dgamcr, gamc6l, gamc6r, dgravl, &
+                                                  dgravr, grav6l, grav6r, dpwl, dpwr, &
+                                                  pw6l, pw6r
+  real, intent(inout), dimension(numFluxActv,hy_numXn) :: dxnl, dxnr, xn6l, xn6r
+  !real, intent(out), DIMENSION(numCells) :: v
+
+  ! local
+  integer :: i, j, k, n
+  real, dimension(numCells) :: etot, flatn1
   real :: checkl, checkr, check, &
-       dcheckl, dcheckr, dcheck  
+       dcheckl, dcheckr, dcheck
 
-  logical :: charLimiting
+  !***** needed for now (testing)
+  integer numIntCells5, numIntCells
+  numIntCells = numCells-8
+  numIntCells5 = numIntCells + 5
+
+  ! check if using characteristic or primitive variables for reconstruction
+  if ( hy_charLimiting ) then
+
+    ! Apply the limiting using the characteristic variables - this method project
+    ! the primitive variables (density, velocity fields, and pressure) onto the
+    ! chracteristic variables, apply limitings, and then project them back to the
+    ! primitive variables.
+
+    call ppm_interp_char(sweepDir, numIntCells, numCells, &
+                     numIntrfcActv, intrfcKey, &
+                     rhol, rho, rhor, &
+                     ul,   u,   ur,   &
+                     utl,  ut,  utr,  &
+                     uttl, utt, uttr, &
+                     pl,   p,   pr,   &
+                     gamc, game)
+
+    ! interpolate the mass fractions and look for contacts
+    do n = 1, hy_numXn
+      call ppm_interp(numCells, numIntrfcActv, xnl(:,n), xn(:,n), xnr(:,n), intrfcKey)
+    end do
 
-  numIntCells5 = numIntCells + 5 
-  
-! get the coefficients of the quartic polynomial through the zones neighboring
-! each zone.  The polynomial used is Eq. 1.6 in Colella & Woodward. 
-
-  do i = 1, numCells
-     coeff1(i) = 0.e0
-     coeff2(i) = 0.e0
-     coeff3(i) = 0.e0     
-     coeff4(i) = 0.e0
-     coeff5(i) = 0.e0
-     rhog(i) = 0.e0
-     rhogl(i) = 0.e0
-     rhogr(i) = 0.e0     
-     drhog(i) = 0.e0
-     rg6(i) = 0.e0
-     flatn(i) = 0.e0
-     flatn1(i) = 0.e0
-  end do
+  else
 
-  call coeff(numIntCells,numCells, dx, coeff1, coeff2, coeff3, coeff4, coeff5)
+    ! apply the limiting using the primitive variables
+    !call Timers_start("ppm_interp")
+    call ppm_interp(numCells, numIntrfcActv, rhol, rho, rhor, intrfcKey)
+
+    ! interpolate the mass fractions and look for contacts
+    do n = 1, hy_numXn
+      call ppm_interp(numCells, numIntrfcActv, xnl(:,n), xn(:,n), xnr(:,n), intrfcKey)
+    end do
+
+    ! interpolate the remainder of the variables
+    call ppm_interp(numCells, numIntrfcActv, ul, u, ur, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, utl, ut, utr, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, uttl, utt, uttr, intrfcKey)
+    call ppm_interp(numCells, numIntrfcActv, pl, p, pr, intrfcKey)
 
+  endif
 
-! interpolate the density to find the interface values, rhol and rhor for
-! each zone
+  ! interpolate the adiabatic indices (game and gamc) and gravity
+  call ppm_interp(numCells, numIntrfcActv, eintl, eint, eintr, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gamel, game, gamer, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gamcl, gamc, gamcr, intrfcKey)
+  call ppm_interp(numCells, numIntrfcActv, gravl, grav, gravr, intrfcKey)
+  !call Timers_stop("ppm_interp")
 
+  !call Timers_start("flattening")
+  if ( hy_igodu == 1 ) then
 
-  if (hy_charLimiting) then
-     ! Apply the limiting using the characteristic variables - this method project
-     ! the primitive variables (density, velocity fields, and pressure) onto the
-     ! chracteristic variables, apply limitings, and then project them back to the
-     ! primitive variables.
-
-     call interp_char(sweepDir, numIntCells, numCells, &
-                      rhol, rho, rhor, &
-                      ul,   u,   ur,   &
-                      utl,  ut,  utr,  &
-                      uttl, utt, uttr, &
-                      pl,   p,   pr,   &
-                      gamc, game,      &
-                      coeff1,coeff2,coeff3,coeff4,coeff5)
-
-     if (hy_useSteepening) &
-          call detect(numIntCells,numCells,rhol, rho, rhor, &
-                      hy_smlrho, rho, p, game, dx, x)
-
-
-     ! interpolate the mass fractions and look for contacts
-     do n = 1, hy_numXn
-
-        call interp(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n),  &
-                    coeff1, coeff2, coeff3, coeff4, coeff5)
-     
-        if (hy_useSteepening .and. n <= NSPECIES) & 
-             call detect(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n), hy_smallx,  &
-                         rho, p, game, dx, x)
-     
-     end do
+     ! select Godunov method, if desired
+     hy_flatn(4:numIntCells5) = 1.e0
 
   else
 
-     ! Apply the limiting using the primitive variables - original version of PPM
-     call interp(numIntCells,numCells,rhol, rho, rhor, coeff1, coeff2, coeff3, coeff4, coeff5)
+     if ( hy_useFlattening ) then
 
-     ! search for contact discontinuities, and steepen the profile if we find them
-     ! -- this prevents the contact from spreading out over too many zones as it
-     ! propagates
-     if (hy_useSteepening) &
-          call detect(numIntCells,numCells,rhol, rho, rhor, &
-                      hy_smlrho, rho, p, game, dx, x)
-    
-
-     ! interpolate the mass fractions and look for contacts
-     do n = 1, hy_numXn
-     
-        call interp(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n),  &
-                    coeff1, coeff2, coeff3, coeff4, coeff5)
-     
-        if (hy_useSteepening .and. n <= NSPECIES) & 
-             call detect(numIntCells, numCells,xnl(1,n), xn(1,n), xnr(1,n), hy_smallx,  &
-                         rho, p, game, dx, x)
-     
-     end do
-      
-     ! interpolate the remainder of the variables 
-     call interp(numIntCells,numCells,ul,   u,   ur,   coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,utl,  ut,  utr,  coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,uttl, utt, uttr, coeff1,coeff2,coeff3,coeff4,coeff5)
-     call interp(numIntCells,numCells,pl,   p,   pr,   coeff1,coeff2,coeff3,coeff4,coeff5)
+        ! look for shocks and flatten the structure if they are too thin
 
-  endif
+        ! TAH (3/16/2016): Pass total energy to the flaten call for energy steepness correction
+        if ( hy_enrFlattening ) &
+             etot(:) =  eint(:) + 0.5e0*(u(:)**2 + K2D*ut(:)**2 + K3D*utt(:)**2)
+
+        call flaten( numIntCells, numCells, u, p, etot, hy_flatn )
+
+        do i = 4, numIntCells5
+           flatn1(i) = 1.e0 - hy_flatn(i)
+        end do
+
+        ! modify left and right states using flattening
+        do i = 1, numIntrfcActv
+
+          ! compute uncompressed index
+          k = intrfcKey(i)
+
+          if ((k-1).ge.4) then
+            rhol (i) = hy_flatn(k-1) * rho (k-1) + flatn1(k-1) * rhol (i)
+            ul   (i) = hy_flatn(k-1) * u   (k-1) + flatn1(k-1) * ul   (i)
+            utl  (i) = hy_flatn(k-1) * ut  (k-1) + flatn1(k-1) * utl  (i)
+            uttl (i) = hy_flatn(k-1) * utt (k-1) + flatn1(k-1) * uttl (i)
+            pl   (i) = hy_flatn(k-1) * p   (k-1) + flatn1(k-1) * pl   (i)
+            gamel(i) = hy_flatn(k-1) * game(k-1) + flatn1(k-1) * gamel(i)
+            gamcl(i) = hy_flatn(k-1) * gamc(k-1) + flatn1(k-1) * gamcl(i)
+            eintl(i) = hy_flatn(k-1) * eint(k-1) + flatn1(k-1) * eintl(i)
+          endif
+
+          if (k.le.numIntCells5) then
+            rhor (i) = hy_flatn(k) * rho (k) + flatn1(k) * rhor (i)
+            ur   (i) = hy_flatn(k) * u   (k) + flatn1(k) * ur   (i)
+            utr  (i) = hy_flatn(k) * ut  (k) + flatn1(k) * utr  (i)
+            uttr (i) = hy_flatn(k) * utt (k) + flatn1(k) * uttr (i)
+            pr   (i) = hy_flatn(k) * p   (k) + flatn1(k) * pr   (i)
+            gamer(i) = hy_flatn(k) * game(k) + flatn1(k) * gamer(i)
+            gamcr(i) = hy_flatn(k) * gamc(k) + flatn1(k) * gamcr(i)
+            eintr(i) = hy_flatn(k) * eint(k) + flatn1(k) * eintr(i)
+          endif
+
+        end do
+
+        do n = 1, hy_numXn
+          do i = 1, numIntrfcActv
+            k = intrfcKey(i)
+            if ((k-1).ge.4) xnl(i,n) = hy_flatn(k-1) * xn(k-1,n) + flatn1(k-1) * xnl(i,n)
+            if (k.le.numIntCells5) xnr(i,n) = hy_flatn(k) * xn(k,n) + flatn1(k) * xnr(i,n)
+          enddo
+        end do
+        !call Timers_stop("flattening")
+
+     else
+
+        hy_flatn(4:numIntCells5) = 0.e0
+
+     end if
+
+  end if
+
+  ! monotonize and compute the final coefficients for the profile
+  !call Timers_start("ppm_profile")
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    rhol, rho, rhor, drhol, drhor, rho6l, rho6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    ul, u, ur, dul, dur, u6l, u6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    utl, ut, utr, dutl, dutr, ut6l, ut6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    uttl, utt, uttr, duttl, duttr, utt6l, utt6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    pl, p, pr, dpl, dpr, p6l, p6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    eintl, eint, eintr, deintl, deintr, eint6l, eint6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gamcl, gamc, gamcr, dgamcl, dgamcr, gamc6l, gamc6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gamel, game, gamer, dgamel, dgamer, game6l, game6r)
+  call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                    gravl, grav, gravr, dgravl, dgravr, grav6l, grav6r)
 
-  ! interpolate the adiabatic indices (game and gamc) and gravity
-  call interp(numIntCells,numCells,gamel,   game,gamer,   coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells,numCells,gamcl,   gamc,gamcr,   coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells,numCells,hy_gravl,grav,hy_gravr,coeff1,coeff2,coeff3,coeff4,coeff5)
-  call interp(numIntCells, numCells,eintl, eint, eintr,&
-              coeff1,coeff2,coeff3,coeff4,coeff5)
-
-
-  ! look for shocks and flatten the structure if they are too thin    
-  call flaten(numIntCells, numCells, u, p, flatn, flatn1)
-
-  do i = 4, numIntCells5
-     rhol (i) = flatn(i) * rho (i) + flatn1(i) * rhol (i)
-     rhor (i) = flatn(i) * rho (i) + flatn1(i) * rhor (i)
-     
-     ul   (i) = flatn(i) * u   (i) + flatn1(i) * ul   (i)
-     ur   (i) = flatn(i) * u   (i) + flatn1(i) * ur   (i)
-     
-     utl  (i) = flatn(i) * ut  (i) + flatn1(i) * utl  (i)
-     utr  (i) = flatn(i) * ut  (i) + flatn1(i) * utr  (i)
-     
-     uttl (i) = flatn(i) * utt (i) + flatn1(i) * uttl (i)
-     uttr (i) = flatn(i) * utt (i) + flatn1(i) * uttr (i)
-     
-     pl   (i) = flatn(i) * p   (i) + flatn1(i) * pl   (i)
-     pr   (i) = flatn(i) * p   (i) + flatn1(i) * pr   (i)
-     
-     gamel(i) = flatn(i) * game(i) + flatn1(i) * gamel(i)
-     gamer(i) = flatn(i) * game(i) + flatn1(i) * gamer(i)
-     
-     gamcl(i) = flatn(i) * gamc(i) + flatn1(i) * gamcl(i)
-     gamcr(i) = flatn(i) * gamc(i) + flatn1(i) * gamcr(i)
-
-     eintl(i) = flatn(i) * eint(i) + flatn1(i) * eintl(i)
-     eintr(i) = flatn(i) * eint(i) + flatn1(i) * eintr(i)
-  end do
-    
   do n = 1, hy_numXn
-     do  i = 4, numIntCells5
-        xnl(i,n) = flatn(i) * xn(i,n) + flatn1(i) * xnl(i,n)
-        xnr(i,n) = flatn(i) * xn(i,n) + flatn1(i) * xnr(i,n)
-     end do
+    call ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                      xnl(:,n), xn(:,n), xnr(:,n), dxnl(:,n), dxnr(:,n), &
+                      xn6l(:,n), xn6r(:,n))
   end do
+  !call Timers_stop("ppm_profile")
 
-
-  ! make sure every thing is monotonic -- no new maxima or minima
-  ! should have been introduced (see Colella & Woodward Eq. 1.10)
-
-  call monot(numIntCells, numCells,rhol,     rho,  rhor,     hy_drho,  hy_rho6 )
-  call monot(numIntCells, numCells,ul,       u,    ur,       hy_du,    hy_u6   )
-  call monot(numIntCells, numCells,utl,      ut,   utr,      hy_dut,   hy_ut6  )
-  call monot(numIntCells, numCells,uttl,     utt,  uttr,     hy_dutt,  hy_utt6 )
-  call monot(numIntCells, numCells,pl,       p,    pr,       hy_dp,    hy_p6   )
-  call monot(numIntCells, numCells,gamel,    game, gamer,    hy_dgame, hy_game6)
-  call monot(numIntCells, numCells,gamcl,    gamc, gamcr,    hy_dgamc, hy_gamc6)
-  call monot(numIntCells, numCells,eintl,    eint, eintr,    hy_deint, hy_eint6)
-  call monot(numIntCells, numCells,hy_gravl, grav, hy_gravr, hy_dgrav, hy_grav6)
-  
-  do n = 1, hy_numXn
-     call monot(numIntCells, numCells,xnl(1,n),xn(1,n),xnr(1,n),hy_dxn(1,n), hy_xn6(1,n))
-  end do
-    
-  do i = 4, numIntCells5
-     vl(i) = 1.e0 / rhol(i)
-     v (i) = 1.e0 / rho (i)
-     vr(i) = 1.e0 / rhor(i)
+  ! set the wave-generating pressure values (no 'modifystates')
+  pwr = pr
+  pwl = pl
+  dpwr = dpr
+  dpwl = dpl
+  pw6r = p6r
+  pw6l = p6l
+
+  !do i = 4, numIntCells5
+  !   v(i) = 1.e0 / rho(i)
+  !enddo
+  do i = 1, numIntrfcActv
+    vl(i) = 1.e0 / rhol(i)
+    vr(i) = 1.e0 / rhor(i)
   end do
 
-! if we are doing the modified states version of PPM, subtract the 
-! rho*g contribution off the pressure.
-!
-!  eqns (27)--(31), Zingale et al (2002) ApJ
-!
-
-  hy_pwl(4:numIntCells5)  = pl(4:numIntCells5)
-  hy_pwr(4:numIntCells5)  = pr(4:numIntCells5)
-  
-  if (hy_ppmModifystates) then
-
-! for the modified states formalism, interpolate the quantity rho*g, which
-! will be removed from the pressure when computing the wave structure
-
-     rhog = rho*grav
-     
-     call interp(numIntCells, numCells,rhogl, rhog, rhogr, &
-                 coeff1,coeff2,coeff3,coeff4,coeff5)
-     
-     do i = 4, numIntCells5
-        rhogl(i) = flatn(i) * rhog(i) + flatn1(i) * rhogl(i)
-        rhogr(i) = flatn(i) * rhog(i) + flatn1(i) * rhogr(i)
-     end do
-     
-     call monot(numIntCells, numCells,rhogl, rhog, rhogr, drhog, rg6)
-     
-     hy_pwcubic = dx/3.e0*rg6
-     hy_pw6r    = hy_p6 + 0.5e0*dx*(drhog+rg6)
-     hy_pw6l    = hy_p6 + 0.5e0*dx*(drhog-rg6)
-     hy_dpw     = hy_dp - dx*(rhogl + 0.5e0*(drhog+rg6))
-     
-  else
-     
-     hy_pwcubic = 0.e0
-     hy_dpw     = hy_dp
-     hy_pw6l    = hy_p6
-     hy_pw6r    = hy_p6
-     
-  endif
-
-! if we are doing the CMA flattening of the abundances, do it now
-  if (hy_useCmaFlattening) &
-       call cma_flatten(numIntCells, numCells, guard,xn, xnl, xnr, hy_dxn, hy_xn6)
-
-
-end subroutine intrfc
-
+end subroutine ppm_intrfc
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_mask.F90	2021-02-18 10:23:47.755524721 -0500
@@ -0,0 +1,232 @@
+!!****if* source/flashUtilities/Wavelet/ppm_mask
+!!
+!! NAME
+!!
+!!  ppm_mask
+!!
+!! SYNOPSIS
+!!
+!! DESCRIPTION
+!!
+!! ARGUMENTS
+!!
+!! NOTES
+!!
+!!***
+
+subroutine ppm_mask(lb, numCells, primDim, secCell, terCell, &
+                      numintrfc, numflx, mask, intrfcmask, flxmask)
+  
+  ! declare modules used
+  use Hydro_data, ONLY : hy_fluxmask, hy_lstart, hy_simpleMask, &
+                          hy_numAdaptiveFlux, hy_numTotFlux
+  use wvlt_data, ONLY : iCellsInt, jCellsInt, intrfcKey, &
+                        fluxKey, hydroSweepLvl, wvlt_maxLvl, &
+                        numFluxActv, numIntrfcActv, wvlt_interpHydro
+
+  implicit none
+
+#include "Flash.h"
+#include "constants.h"
+
+  ! arguments
+  integer, intent(in) :: lb, numCells, primDim, secCell, terCell
+  integer, intent(inout) :: numflx, numintrfc
+  real, dimension(numCells, 2), intent(in) :: mask
+  integer, allocatable, intent(inout) :: intrfcmask(:), flxmask(:)
+
+  ! local
+  integer :: l, i, j, k, itot, dl! n2
+  integer :: ng = 4
+  integer :: lstart
+  logical :: flag
+  logical, dimension(numCells) :: tmpmask1, tmpmask2
+
+  ! initialize values
+  numflx = 0
+  numintrfc = 0
+  tmpmask1 = .false.
+
+  if (wvlt_interpHydro) then
+
+    if (hy_simpleMask) then
+
+#if NDIM == 1
+      lstart = hydroSweepLvl(1,1,1,lb)
+#endif
+
+#if NDIM == 2
+      lstart = hydroSweepLvl(secCell,primDim,1,lb)
+#endif
+
+      ! emergency precaution (lstart is junk when restarting simulation)
+      ! this is not a perfect fix; if junk is 1 or 2... problem
+      flag = .false.
+      do l = 1, wvlt_maxLvl
+        if (lstart.eq.l) then
+          flag = .true.
+        endif
+      enddo
+      if (.not.flag) then
+        lstart = wvlt_maxLvl
+      endif
+
+      ! get number of interfaces and fluxes
+      numintrfc = numIntrfcActv(lstart)
+      numflx = numFluxActv(lstart)
+
+      ! allocate memory for intrfcmask and fluxmask
+      allocate(flxmask(numflx))
+      allocate(intrfcmask(numintrfc))
+
+      ! get the associated intrfckey & fluxkey
+      intrfcmask = intrfcKey(1:numintrfc,lstart)
+      flxmask = fluxKey(1:numflx,lstart)
+
+      ! set hydro_data lstart value
+      hy_lstart = lstart
+
+    ! compute custom mask
+    else
+
+      !------- first need to compute the mask for direct fluxes -------!
+
+      ! loop through hierarchy
+      do l = 1, wvlt_maxLvl-1
+      
+        ! put all coarse interfaces in mask
+        if (l.eq.1) then
+
+          ! current level difference
+          dl = wvlt_maxLvl - l
+
+          do i = 1, iCellsInt(l)+1
+
+            ! compute total index on fine grid
+            itot = 2**dl * (i-1) + 1 + ng
+
+            ! put in the mask
+            tmpmask1(itot) = .true.
+
+            numflx = numflx + 1
+
+          enddo
+
+        endif
+
+        ! recompute difference for level above
+        dl = wvlt_maxLvl - (l+1)
+
+        ! now check for even-indexed cells at level above
+        do i = 1, iCellsInt(l)
+
+          ! compute fine-grid index for target interface
+          itot = 2**dl * (2*i-1) + 1 + ng
+
+          ! evaluate if tmpmask1 is true or false
+          if (mask(itot,l).gt.0) then
+
+            ! set tmpmask1 and increment
+            tmpmask1(itot) = .true.
+
+            ! increment
+            numflx = numflx + 1
+
+          endif
+
+        enddo
+
+      enddo
+
+      !------- proceed to create compressed arrays -------!
+
+      ! zero out the ends of first mask (ghost regions)
+      tmpmask1(1:4) = .false.
+      tmpmask1((numCells-2):numCells) = .false.
+
+      ! intialize interface mask
+      tmpmask2 = .false.
+
+      ! loop over interior interfaces
+      do i = 2, numCells-1
+
+        ! check if fluxMask is active
+        if (tmpmask1(i)) then
+
+          ! need interfaces to left and right to be active as well
+          tmpmask2(i-1:i+1) = .true.
+
+        endif
+
+      enddo
+
+      ! now count up the number of interfaces active
+      numintrfc = count(tmpmask2)
+
+      ! allocate memory for intrfcmask and fluxmask
+      allocate(flxmask(numflx))
+      allocate(intrfcmask(numintrfc))
+
+      ! fill in these arrays with mappings
+      j = 1
+      k = 1
+      do i = 1, numCells
+
+        ! check tmpmask2 active 
+        if (tmpmask2(i)) then
+
+          ! set interface key value
+          intrfcmask(j) = i
+
+          if (tmpmask1(i)) then
+
+            ! set flux key value
+            flxmask(k) = j
+
+            ! increment
+            k = k + 1
+
+          endif
+
+          ! increment counter
+          j = j + 1
+
+        endif
+
+      enddo
+
+      ! copy into hydro_data vector
+      hy_fluxmask = tmpmask1
+
+    endif
+
+  else
+
+    ! this needs to be on for ppm_decode
+    hy_simpleMask = .true.
+
+    ! fluxes computed at finest level of local MR hierarchy
+    lstart = wvlt_maxLvl
+
+    ! get number of interfaces and fluxes
+    numintrfc = numIntrfcActv(lstart)
+    numflx = numFluxActv(lstart)
+
+    ! allocate memory for intrfcmask and fluxmask
+    allocate(flxmask(numflx))
+    allocate(intrfcmask(numintrfc))
+
+    ! get the associated intrfckey & fluxkey
+    intrfcmask = intrfcKey(1:numintrfc,lstart)
+    flxmask = fluxKey(1:numflx,lstart)
+
+    ! set hydro_data lstart value
+    hy_lstart = lstart
+
+  endif
+
+  ! set counters
+  hy_numAdaptiveFlux = hy_numAdaptiveFlux + numflx
+  hy_numTotFlux = hy_numTotFlux + numFluxActv(wvlt_maxLvl)
+
+end subroutine ppm_mask
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90	2021-02-22 23:57:38.576465142 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_profile.F90	2021-02-14 15:36:30.560817858 -0500
@@ -1,113 +1,130 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/monot
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/ppm_profile
 !!
 !! NAME
 !! 
-!!  monot
+!!  ppm_profile
 !!
 !! SYNOPSIS
 !!
-!!  call monot(integer(IN) :: numIntCells, 
-!!             integer(IN) :: numCells, 
-!!             real(INOUT), dimension(numCells) :: al,
-!!             real(IN),    dimension(numCells) :: a,
-!!             real(INOUT), dimension(numCells) :: ar,
-!!             real(OUT),   dimension(numCells) :: da,
-!!             real(OUT),   dimension(numCells) :: a6)
-!!
-!! 
 !! DESCRIPTION
 !!
 !!  Apply monotonicity constraint to interpolation parabola -- constrain
 !!  the parabolic distribution of each variable so that all points in the
 !!  parabola fall between the zone interface values.
 !!
-!!  Near a local minimum or maximum, the only way to preserve monotonicity
+!!  Near a local minimum or maximum, the only way to preserve ppm_profileonicity
 !!  is to set the interface values to the zone average.  Near a steep
 !!  gradient, one interface value is set so the slope of the parabola
 !!  at that interface is 0.
 !!
 !! ARGUMENTS
-!!   numIntCells - number if interior cells
-!!   numCells    - maximum of the number of cells along any dimension
-!!   al          - array containing left edge values
-!!   a           - array containing center values
-!!   ar          - array containing right edge values
-!!   da          - derivative values
-!!   a6          - 
 !!
 !!***
 
-subroutine monot(numIntCells, numCells,al,a,ar,da,a6)
-
-  use Hydro_data, ONLY: hy_iplm
+subroutine ppm_profile(numCells, numFluxActv, numIntrfcActv, fluxKey, &
+                       intrfcKey, al, a, ar, dal, dar, a6l, a6r)
 
   implicit none
-  integer, intent(IN) :: numIntCells, numCells
-  real, intent(INOUT), DIMENSION(numCells) :: al, ar
-  real, intent(IN),    DIMENSION(numCells) :: a
-  real, intent(OUT),   DIMENSION(numCells) :: da, a6
-  
-  real :: disval
-  integer :: i,numIntCells5
-  real s1, s2, s3
-  
-  numIntCells5 = numIntCells + 5
-  
-  do  i = 4, numIntCells5
-     
-     da(i) = (ar(i) - al(i))
-     da(i) = sign (1.e00, da(i))
-     
-     s1 = (ar(i) - a(i)) * (al(i) - a(i))
-     
-     if (s1 >= 0.e0) then
-        al(i) = a(i)
-        ar(i) = a(i)
-     endif
-     
-!-------  statements changed to avoid generation of spurious
-!         noise in case of a completely constant state in one
-!         coordinate direction     ( e.mueller, 26.2.88 )
-
-!    s2 = 3.e00 * a(i) - 2.e00 * ar(i)
-!    s3 = 3.e00 * a(i) - 2.e00 * al(i)
-
-
-! Eq. 1.10 of Colella & Woodward
-    
-     disval = (ar(i) - a(i)) * (al(i) - a(i))
-     
-     if (disval /= 0.e0) then
-        s2 = 3.e00 * a(i) - 2.e00 * ar(i)
-        s3 = 3.e00 * a(i) - 2.e00 * al(i)
-     else
-        s2 = al(i)
-        s3 = ar(i)
-     endif
-       
-
-! constraints in lines 2 and 3 of 1.10 (they've been factored
-! and simplified a bit)
-
-     if (da(i) * (al(i) - s2) < 0.e0) al(i) = s2
-     if (da(i) * (s3 - ar(i)) < 0.e0) ar(i) = s3
-     
-     da(i) = ar(i) - al(i)
-
-
-! if we are doing the Piecewise Linear Method, enforce it here
-
-     if (hy_iplm == 0) then
-        a6(i) = 6.e00 * a(i) - 3.e00 * (al(i) + ar(i))
-     else
-        a6(i) = 0.e00
-     endif
-     
-  end do
-  
-  return
-end subroutine monot
-  
 
+  ! arguments
+  integer, intent(in) :: numCells, numIntrfcActv, numFluxActv
+  real, intent(inout), dimension(numIntrfcActv) :: al, ar
+  real, intent(in),    dimension(numCells) :: a
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  real, intent(inout), dimension(numFluxActv) :: dal, dar, a6l, a6r
+
+  ! local
+  integer :: i, j, flag, k, jlo, jhi
+  real :: s1, s2, s3, ulo, uhi
+
+  !-----------------------------------------------------------------------------
+
+  ! set flag
+  flag = 0
+
+  ! monotonize profile in cells bordering active flux 
+  do i = 1, numFluxActv
+
+    ! compute indices in compressed space of neighboring interfaces
+    j = fluxKey(i)
+    jlo = j - 1
+    jhi = j + 1
+
+    ! fine-grid (right cell index of interface)
+    k = intrfcKey(j)
+
+    ! get left and right cell of target interface
+    ulo = a(k-1)
+    uhi = a(k)
+
+    if (flag.ne.(k-1)) then
+
+      dal(i) = al(j) - ar(jlo)
+
+      dal(i) = sign(1.e0,dal(i))
+
+      s1 = (al(j) - ulo)*(ar(jlo) - ulo)
+
+      if (s1.ge.0.e0) then
+         ar(jlo) = ulo 
+         al(j) = ulo
+      end if
+
+      s1 = (al(j) - ulo)*(ar(jlo) - ulo)
+
+      if (s1/=0.e0) then
+         s2 = 3.e0*ulo - 2.e0*al(j)
+         s3 = 3.e0*ulo - 2.e0*ar(jlo)
+      else
+         s2 = ar(jlo)
+         s3 = al(j)
+      end if
+
+      if ( dal(i)*(ar(jlo) - s2) < 0.e0) ar(jlo) = s2
+      if ( dal(i)*(s3 - al(j)) < 0.e0) al(j) = s3
+
+      dal(i) = al(j) - ar(jlo)
+      a6l(i) = 6.0*ulo - 3.0e0*(ar(jlo) + al(j))
+
+    else
+
+      dal(i) = dar(i-1)
+      a6l(i) = a6r(i-1)
+
+    endif ! checking flag
+
+    ! set flag
+    flag = k-1
+
+    ! if using this routine for Richardson-based LTE estimation, don't use monotonization
+    dar(i) = al(jhi) - ar(j)
+
+    dar(i) = sign(1.e0,dar(i))
+
+    s1 = (al(jhi) - uhi)*(ar(j) - uhi)
+
+    if (s1.ge.0.e0) then
+       ar(j) = uhi 
+       al(jhi) = uhi
+    end if
+
+    s1 = (al(jhi) - uhi)*(ar(j) - uhi)
+
+    if (s1/=0.e0) then
+       s2 = 3.e0*uhi - 2.e0*al(jhi)
+       s3 = 3.e0*uhi - 2.e0*ar(j)
+    else
+       s2 = ar(j)
+       s3 = al(jhi)
+    end if
+
+    if ( dar(i)*(ar(j) - s2) < 0.e0) ar(j) = s2
+    if ( dar(i)*(s3 - al(jhi)) < 0.e0) al(jhi) = s3
+
+    dar(i) = al(jhi) - ar(j)
+    a6r(i) = 6.0*uhi - 3.0e0*(ar(j) + al(jhi))
 
+  enddo
 
+end subroutine ppm_profile
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90	2021-02-22 23:57:38.576465142 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_riemann.F90	2021-02-14 15:24:26.405762475 -0500
@@ -1,27 +1,11 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/rieman
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/ppm_riemann
 !!
 !! NAME
 !! 
-!!  rieman
+!!  ppm_riemann
 !!
 !! SYNOPSIS
 !!
-!!       call rieman ( integer(IN) :: numIntCells, 
-!!                     integer(IN) :: numCells, 
-!!                     real(OUT)   :: rhoav(numCells), 
-!!                     real(OUT)   :: uav(numCells), 
-!!                     real(OUT)   :: utav(numCells), 
-!!                     real(OUT)   :: uttav(numCells), 
-!!                     real(OUT)   :: pav(numCells), 
-!!                     real(OUT)   :: urell(numCells), 
-!!                     real(IN)    :: ugrdl(numCells), 
-!!                     real(IN)    :: game(numCells), 
-!!                     real(OUT)   :: gameav(numCells), 
-!!                     real(OUT)   :: eintAv(numCells),
-!!                     real(OUT)   :: xnav(numCells, hy_numXn), 
-!!                     real(IN) :: x(numCells))
-!!                 
-!!
 !!
 !! DESCRIPTION
 !!  
@@ -71,422 +55,392 @@
 !!
 !! ARGUMENTS
 !!
-!! numIntCells :
-!! numCells :
-!! rhoav :
-!! uav :
-!! utav :
-!! uttav :
-!! pav :
-!! urell :
-!! ugrdl :
-!! game :
-!! gameav :
-!! eintAv :
-!! xnav :
-!! x :
-!!
-!!
-!!
 !!***
-subroutine rieman (numIntCells, numCells, &
-                   rhoav, uav, utav, uttav, pav, &
-                   urell, ugrdl, game, gameav, eintAv, xnav, x)
+subroutine ppm_riemann(numCells, numFluxActv, numIntrfcActv, &
+                         fluxKey, intrfcKey, rhoav, uav, utav, uttav, pav, &
+                         eintav, xnav, gameav, clft, crght, &
+                          ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                          prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                          vlft, vrght, xnlft, xnrght, game)
                    
-
   use Hydro_data, ONLY: hy_numXn, &
-                        hy_gmelft, hy_gmergt, &
-                        hy_plft,   hy_prght,  &
-                        hy_clft,   hy_crght,  &
-                        hy_ulft,   hy_urght,  &
-                        hy_vlft,   hy_vrght,  &
-                        hy_utlft,  hy_utrght, &
-                        hy_uttlft, hy_uttrgt, &
-                        hy_eiLft,  hy_eiRght, &
-                        hy_xnlft,  hy_xnrght, &
                         hy_smallp, hy_smallu, &
                         hy_smlrho, hy_nriem,  &
-                        hy_gmclft, hy_gmcrgt,hy_pstor, &
-                        hy_riemanTol
+                        hy_ptrial, hy_perror, &
+                        hy_wlft,   hy_wrght,  &
+                        hy_riemanTol, hy_riemanTolAbort, hy_rieman_printDiag
   use Driver_interface, ONLY : Driver_abortFlash
 
-
   implicit none
-!! Arguments ---------------------------------- 
-
-  integer, intent (IN) :: numIntCells,numCells
-  real, intent(IN), DIMENSION(numCells) :: x
-  real, intent(IN), DIMENSION(numCells) :: ugrdl, game
-  real, intent(OUT), DIMENSION(numCells) :: uav, rhoav, utav, uttav, pav, &
-                               urell, gameav, eintAv
-  real, intent(OUT), DIMENSION(numCells,hy_numXn) :: xnav
 
+#include "constants.h"
 
-!! Local variable ---------------------------------
-  real, DIMENSION(numCells) :: wlft, wrght, pstar, ustar, vstar, cestar, &
-       rhostr, westar, ps, us, uts, utts, vs, rhos, ces, ws, wes, &
-       gmstar, games, gamcs
+  ! arguments
+  integer, intent(in) :: numCells, numFluxActv, numIntrfcActv
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  real, intent(in), dimension(numCells) :: game
+  real, intent(in), dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                                  utrght, uttlft, uttrght, plft, &
+                                                  prght, eilft, eirght, gmelft, &
+                                                  gmerght, gmclft, gmcrght, &
+                                                  vlft, vrght
+  real, intent(in), dimension(numFluxActv, hy_numXn) :: xnlft, xnrght
+  real, intent(out), dimension(numFluxActv) :: uav, rhoav, utav, uttav, pav, &
+                                                gameav, eintav
+  real, intent(out), dimension(numFluxActv,hy_numXn) :: xnav
+
+
+  ! local data
+  real, dimension(numFluxActv) :: wlft, wrght, pstar, ustar, vstar, cestar, &
+                                  rhostr, westar, ps, us, uts, utts, vs, &
+                                  rhos, ces, ws, wes, gmstar, games, gamcs
+  real, dimension(numFluxActv) :: pstar1, pstar2, gmstrl, gmstrr, &
+                                  wlft1, wrght1, gmin, gmax, &
+                                  gamfac, aux, scrch1, scrch2, &
+                                  scrch3, scrch4
+  real  :: ge, gc, ustrl1, ustrr1, ustrl2, ustrr2, &
+           delu1, delu2, pres_err
+  integer :: i, j, k, n
+  integer :: perr_minloc(1)
+  real, parameter :: small_dp = 1.e2 * epsilon(1.e0)
 
   
-  real, DIMENSION(numCells) :: pstar1, pstar2, gmstrl, gmstrr, &
-       &   wlft1, wrght1, gmin, gmax, &
-       &   gamfac, aux
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4
+  ! We carry around two adiabatic indices (gammas).  gamc is usually
+  ! referred to as gamma_1, and is d(log P)/d(log rho) (CG Eq. 7).  game
+  ! is CG Eq. 8.      
 
-  real  ::  ge, gc, ustrl1, ustrr1, ustrl2, ustrr2, &
-       & delu1, delu2, pres_err
-  
-  integer :: i, j, k, n, numIntCells5, ierr
-  
-  
-  character(len=1), save :: dirs(3) = (/ 'x', 'y', 'z' /)
-  
-  real, parameter :: small_dp = 1.e2 * epsilon(1.e0)
+  ! calculate limits on gamma based on the values in the neighboring zones
+  ! gamfac is the max gamma factor in CG Eq. 31, and is used over and over,
+  ! so store it for efficiency.
+  do i = 1, numFluxActv
 
-  
-    !--------------------------------------------------------------------------
+    ! compute interface indices
+    j = fluxKey(i)
+    k = intrfcKey(j)
+
+    ! compute values
+    aux(i)    = sqrt (0.5e0 * (game(k) - 1.0e0) / game(k))
+    ge        = 0.5e0 * (gmelft(i) + gmerght(i))
+    gc        = 0.5e0 * (gmclft(i) + gmcrght(i))
+    gamfac(i) = (1.e0 - ge / gc) * (ge - 1.e0)
+    gmin(i)   = min(game(k-2), game(k-1), game(k), game(k+1))
+    gmax(i)   = max(game(k-2), game(k-1), game(k), game(k+1))
 
-    ! We carry around two adiabatic indices (gammas).  gamc is usually
-    ! referred to as gamma_1, and is d(log P)/d(log rho) (CG Eq. 7).  game
-    ! is CG Eq. 8.      
-
-    ! calculate limits on gamma based on the values in the neighboring zones
-    ! gamfac is the max gamma factor in CG Eq. 31, and is used over and over,
-    ! so store it for efficiency.
-
-  numIntCells5 = numIntCells + 5
-
-  do i = 5, numIntCells5
-     aux(i)    = sqrt (0.5e0 * (game(i) - 1.0e0) / game(i))
-     ge        = 0.5e0 * (hy_gmelft(i) + hy_gmergt(i))
-     gc        = 0.5e0 * (hy_gmclft(i) + hy_gmcrgt(i))
-     gamfac(i) = (1.e0 - ge / gc) * (ge - 1.e0)
-     gmin(i)   = min (game(i-1), game(i), game(i+1))
-     gmax(i)   = max (game(i-1), game(i), game(i+1))
   enddo
   
-    ! construct first guess for secant iteration by assuming that the nonlinear 
-    ! wave speed is equal to the sound speed -- the resulting expression is the
-    ! same as Toro, Eq. 9.28 in the Primitive Variable Riemann Solver (PVRS).
-    ! See also Fry Eq. 72.
-    
-  do i = 5, numIntCells5
-     pstar1(i) = hy_prght(i) - hy_plft(i) - hy_crght(i) * (hy_urght(i) - hy_ulft(i))
-     pstar1(i) = hy_plft(i) + pstar1(i) * (hy_clft(i) / (hy_clft(i) + hy_crght(i)))
-     pstar1(i) = max (hy_smallp, pstar1(i))
-  enddo
+  ! construct first guess for secant iteration by assuming that the nonlinear 
+  ! wave speed is equal to the sound speed -- the resulting expression is the
+  ! same as Toro, Eq. 9.28 in the Primitive Variable Riemann Solver (PVRS).
+  ! see also Fry Eq. 72.
+  do i = 1, numFluxActv
+
+    ! compute values
+    pstar1(i) = prght(i) - plft(i) - crght(i) * (urght(i) - ulft(i))
+    pstar1(i) = plft(i) + pstar1(i) * (clft(i) / (clft(i) + crght(i)))
+    pstar1(i) = max (hy_smallp, pstar1(i))
 
-    ! calculate approximation jump in gamma acrosss the interface based on the 
-    ! first guess for the pressure jump.  There is a left and right 'star' region,
-    ! so we need gamma add both places.  Use CG Eq. 31 and 32, with definitions
-    ! as in CG Eq. 33.
-    
-  do i = 5, numIntCells5
-     gmstrl(i) = gamfac(i) * (pstar1(i) - hy_plft(i))
-     gmstrl(i) = hy_gmelft(i) + 2.e0 * gmstrl(i) / (pstar1(i) + hy_plft(i))
-     
-     gmstrr(i) = gamfac(i) * (pstar1(i) - hy_prght(i))
-     gmstrr(i) = hy_gmergt(i) + 2.e0 * gmstrr(i) / (pstar1(i) + hy_prght(i))
-     
-     gmstrl(i) = max (gmin(i), min( gmstrl(i), gmax(i)))
-     gmstrr(i) = max (gmin(i), min( gmstrr(i), gmax(i)))
   enddo
 
-    ! calculate nonlinear wave speeds for the left and right moving waves based
-    ! on the first guess for the pressure jump.  Again, there is a left and a 
-    ! right wave speed.  Compute this using CG Eq. 34.
-    
-  do i = 5, numIntCells5
-     scrch1(i) = pstar1(i) - (gmstrl(i) - 1.e0) * hy_plft(i) &
-          & / (hy_gmelft(i) - 1.e0)
-     if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
-     
-     wlft1(i)  = pstar1(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
-          & * (pstar1(i) + hy_plft(i))
-     wlft1(i)  = (pstar1(i) - hy_plft(i)) * wlft1(i) / (hy_vlft(i) * scrch1(i))
-     wlft1(i)  = sqrt(abs(wlft1(i)))
-     
+  ! calculate approximation jump in gamma acrosss the interface based on the 
+  ! first guess for the pressure jump.  There is a left and right 'star' region,
+  ! so we need gamma add both places.  Use CG Eq. 31 and 32, with definitions
+  ! as in CG Eq. 33.
+  do i = 1, numFluxActv
 
-     scrch2(i) = pstar1(i) - (gmstrr(i) - 1.e0) * hy_prght(i) /(hy_gmergt(i) - 1.e0)
-     
-     if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
-     
-     wrght1(i) = pstar1(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
-          & * (pstar1(i) + hy_prght(i))
-     wrght1(i) = (pstar1(i) - hy_prght(i)) * wrght1(i) / (hy_vrght(i) * scrch2(i))
-     wrght1(i) = sqrt(abs(wrght1(i)))
-     
-       ! if the pressure jump is small, the wave speed is just the sound speed
+    ! compute values
+    gmstrl(i) = gamfac(i) * (pstar1(i) - plft(i))
+    gmstrl(i) = gmelft(i) + 2.e0 * gmstrl(i) / (pstar1(i) + plft(i))
 
-     if (abs (pstar1(i) - hy_plft(i)) < small_dp*(pstar1(i) + hy_plft(i))) wlft1(i) = hy_clft(i)
-     wlft1(i)  = max (wlft1(i),  aux(i) * hy_clft(i))
-     
-     if (abs (pstar1(i) - hy_prght(i)) < small_dp*((pstar1(i) + hy_prght(i)))) wrght1(i) = hy_crght(i)
-     wrght1(i) = max (wrght1(i), aux(i) * hy_crght(i))
-  enddo
+    gmstrr(i) = gamfac(i) * (pstar1(i) - prght(i))
+    gmstrr(i) = gmerght(i) + 2.e0 * gmstrr(i) / (pstar1(i) + prght(i))
 
-    ! construct second guess for the pressure using the nonlinear wave speeds
-    ! from the first guess.  This is basically the same thing we did to get
-    ! pstar1, except now we are using the better wave speeds instead of the 
-    ! sound speed.
+    gmstrl(i) = max (gmin(i), min (gmax(i), gmstrl(i) ))
+    gmstrr(i) = max (gmin(i), min (gmax(i), gmstrr(i) ))
 
-  do i = 5, numIntCells5
-     pstar2(i) = hy_prght(i) - hy_plft(i) - wrght1(i) * (hy_urght(i) - hy_ulft(i))
-     pstar2(i) = hy_plft(i) + pstar2(i) * wlft1(i) / (wlft1(i) + wrght1(i))
-     pstar2(i) = max (hy_smallp, pstar2(i))
   enddo
 
-    ! begin the secant iteration -- see CG Eq. 17 for details.  We will continue to
-    ! interate for convergence until the error falls below tol (in which case, 
-    ! things are good), or we hit hy_nriem iterations (in which case we have a 
-    ! problem, and we spit out an error).
+  ! calculate nonlinear wave speeds for the left and right moving waves based
+  ! on the first guess for the pressure jump.  Again, there is a left and a 
+  ! right wave speed.  Compute this using CG Eq. 34.
+  do i = 1, numFluxActv
 
-  do i = 5, numIntCells5
-     
-     hy_pstor(1) = pstar1(i)
-     hy_pstor(2) = pstar2(i)
-     
-     do n = 1, hy_nriem
-        
-        ! new values for the gamma at the "star" state -- again, using CG Eq. 31
-          
-        gmstrl(i) = gamfac(i) * (pstar2(i) - hy_plft(i))
-        gmstrl(i) = hy_gmelft(i) + 2.e0 * gmstrl(i) / (pstar2(i) + hy_plft(i))
-        
-        gmstrr(i) = gamfac(i) * (pstar2(i) - hy_prght(i))
-        gmstrr(i) = hy_gmergt(i) + 2.e0 * gmstrr(i) / (pstar2(i) + hy_prght(i))
-        
-        gmstrl(i) = max (gmin(i), min (gmax(i), gmstrl(i)))
-        gmstrr(i) = max (gmin(i), min (gmax(i), gmstrr(i)))
-        
-        ! new nonlinear wave speeds, using CG Eq. 34 and the updated gammas
-          
-        scrch1(i) = pstar2(i) - (gmstrl(i) - 1.e0) * hy_plft(i) &
-             & / (hy_gmelft(i) - 1.e0)
-        if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
-        
-        wlft(i)   = pstar2(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
-             & * (pstar2(i) + hy_plft(i))
-        wlft(i)   = (pstar2(i) - hy_plft(i)) * wlft(i) / (hy_vlft(i) * scrch1(i))
-        wlft(i)   = sqrt(abs(wlft(i)))
-
-        scrch2(i) = pstar2(i) - (gmstrr(i) - 1.e0) * hy_prght(i) /(hy_gmergt(i) - 1.e0)
-
-        if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
-        
-        wrght(i)  = pstar2(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
-             & * (pstar2(i) + hy_prght(i))
-        wrght(i)  = (pstar2(i) - hy_prght(i)) * wrght(i) / (hy_vrght(i) * scrch2(i))
-        wrght(i)  = sqrt(abs(wrght(i)))
-        
-        ! if the pressure jump is small, the wave speed is just the sound speed
-
-        if (abs (pstar2(i) - hy_plft(i)) < small_dp*(pstar2(i) + hy_plft(i))) wlft(i) = hy_clft(i)
-        wlft(i)  = max (wlft(i), aux(i) * hy_clft(i))
-        
-        if (abs (pstar2(i) - hy_prght(i)) < small_dp*(pstar2(i) + hy_prght(i))) wrght(i) = hy_crght(i)
-        wrght(i) = max (wrght(i), aux(i) * hy_crght(i))
-
-        ! compute the velocities in the "star" state -- using CG Eq. 18 -- ustrl2 and
-        ! ustrr2 are the velocities they define there.  ustrl1 and ustrl2 seem to be
-        ! the velocities at the last time, since pstar1 is the old 'star' pressure, and
-        ! wlft1 is the old wave speed.
-        
-        ustrl1    =  hy_ulft(i) - (pstar1(i) -  hy_plft(i)) /  wlft1(i)
-        ustrr1    = hy_urght(i) + (pstar1(i) - hy_prght(i)) / wrght1(i)
-        ustrl2    =  hy_ulft(i) - (pstar2(i) -  hy_plft(i)) /   wlft(i)
-        ustrr2    = hy_urght(i) + (pstar2(i) - hy_prght(i)) /  wrght(i)
-        
-        delu1     = ustrl1 - ustrr1
-        delu2     = ustrl2 - ustrr2
-        scrch1(i) = delu2  - delu1
-        
-        if (abs(pstar2(i)-pstar1(i)) .le. hy_smallp) scrch1(i) = 0.e0
-        
-        if (abs(scrch1(i)) .lt. hy_smallu) then
-           delu2 = 0.e0
-           scrch1(i) = 1.e0
-        endif
-
-        ! pressure at the "star" state -- using CG Eq. 18
-
-        pstar(i)  = pstar2(i) - delu2 * (pstar2(i) - pstar1(i)) / scrch1(i)
-        pstar(i)  = max (hy_smallp, pstar(i))
-        
-        ! check for convergence of iteration, hy_riemanTol is a run-time parameter
-        
-        pres_err = abs(pstar(i)-pstar2(i)) / pstar(i)
-        if (pres_err .lt. hy_riemanTol) goto 10
-        
-        ! reset variables for next iteration
-          
-        pstar1(i) = pstar2(i)
-        pstar2(i) = pstar(i)
-        hy_pstor(n+2) = pstar(i)
-        
-        wlft1(i)  = wlft(i)
-        wrght1(i) = wrght(i)
-        
-     enddo
-     
-     n = n - 1
-     
-     ! print error message and stop code if iteration fails to converge
-     
-     print *, ' '
-     print *, 'Nonconvergence in subroutine rieman'
-     print *, ' '
-     print *, 'Zone index       = ', i
-     print *, 'Zone center      = ', x(i)
-     print *, 'Iterations tried = ', n+2
-     print *, 'Pressure error   = ', pres_err
-     print *, 'rieman_tol       = ', hy_riemanTol
-     print *, ' '
-     print *, 'pL       = ', hy_plft(i),   ' pR       =', hy_prght(i)
-     print *, 'uL       = ', hy_ulft(i),   ' uR       =', hy_urght(i)
-     print *, 'cL       = ', hy_clft(i),   ' cR       =', hy_crght(i)
-     print *, 'gamma_eL = ', hy_gmelft(i), ' gamma_eR =', hy_gmergt(i)
-     print *, 'gamma_cL = ', hy_gmclft(i), ' gamma_cR =', hy_gmcrgt(i)
-     print *, ' '
-     print *, 'Iteration history:'
-     print *, ' '
-     print '(A4, 2X, A20)', 'n', 'p*'
-     do j = 1, n+2
-        print '(I4, 2X, E20.12)', j, hy_pstor(j)
-     enddo
-     print *, ' '
-     print *, 'Terminating execution.'
-     call Driver_abortFlash('Nonconvergence in subroutine rieman')
-       
-       ! land here if the iterations have converged
-       
-10     continue
-     
-  enddo
+    ! compute values
+    scrch1(i) = pstar1(i) - (gmstrl(i) - 1.e0) * plft(i) &
+                  / (gmelft(i) - 1.e0)
+    if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
 
-! end of secant iteration
+    wlft1(i)  = pstar1(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
+                  * (pstar1(i) + plft(i))
+    wlft1(i)  = (pstar1(i) - plft(i)) * wlft1(i) / (vlft(i) * scrch1(i))
+    wlft1(i)  = sqrt(abs(wlft1(i)))
 
-! calculate fluid velocity for the "star" state -- this comes from the shock
-! jump equations, Fry Eq. 68 and 69.  The ustar velocity can be computed
-! using either the jump eq. for a left moving or right moving shock -- we use
-! the average of the two.
-! NOTE: Also look at Fry Eqn. 75 and 76.
+    scrch2(i) = pstar1(i) - (gmstrr(i) - 1.e0) * prght(i) /(gmerght(i) - 1.e0)
 
-  do i = 5, numIntCells5
-     scrch3(i) = hy_ulft (i) - (pstar(i) -  hy_plft(i)) /  wlft(i)
-     scrch4(i) = hy_urght(i) + (pstar(i) - hy_prght(i)) / wrght(i)
-     ustar(i)  = 0.5e0 * (scrch3(i) + scrch4(i))
-  enddo
+    if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
+
+    wrght1(i) = pstar1(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
+                  * (pstar1(i) + prght(i))
+    wrght1(i) = (pstar1(i) - prght(i)) * wrght1(i) / (vrght(i) * scrch2(i))
+    wrght1(i) = sqrt(abs(wrght1(i)))
 
-! account for grid velocity
+    ! if the pressure jump is small, the wave speed is just the sound speed
+    if (abs (pstar1(i) - plft(i)) < small_dp*(pstar1(i) + plft(i))) wlft1(i) = clft(i)
+    wlft1(i)  = max (wlft1(i),  aux(i) * clft(i))
+
+    if (abs (pstar1(i) - prght(i)) < small_dp*((pstar1(i) + prght(i)))) wrght1(i) = crght(i)
+    wrght1(i) = max (wrght1(i), aux(i) * crght(i))
 
-  do i = 5, numIntCells5
-     urell(i)   = ustar(i) - ugrdl(i)
-!!$     scrch1(i)  = sign (1.e0, urell(i))
-     scrch1(i)  = sign (0.5, urell(i)) - sign(0.5,-urell(i))     
   enddo
 
-! decide which state is located at the zone iterface based on the values 
-! of the wave speeds.  This is just saying that if ustar > 0, then the state
-! is U_L.  if ustar < 0, then the state on the axis is U_R.
+  ! construct second guess for the pressure using the nonlinear wave speeds
+  ! from the first guess.  This is basically the same thing we did to get
+  ! pstar1, except now we are using the better wave speeds instead of the 
+  ! sound speed.
+  do i = 1, numFluxActv
 
-  do i = 5, numIntCells5
-     
-     scrch2(i) = 0.5e0 * ( 1.e0 + scrch1(i))
-     scrch3(i) = 0.5e0 * ( 1.e0 - scrch1(i))
-     
-     ps(i)    = hy_plft(i)   * scrch2(i) + hy_prght(i)  * scrch3(i)
-     us(i)    = hy_ulft(i)   * scrch2(i) + hy_urght(i)  * scrch3(i)
-     uts(i)   = hy_utlft(i)  * scrch2(i) + hy_utrght(i) * scrch3(i)
-     utts(i)  = hy_uttlft(i) * scrch2(i) + hy_uttrgt(i) * scrch3(i)
-     vs(i)    = hy_vlft(i)   * scrch2(i) + hy_vrght(i)  * scrch3(i) !v for v=1/rho
-     games(i) = hy_gmelft(i) * scrch2(i) + hy_gmergt(i) * scrch3(i)
-     gamcs(i) = hy_gmclft(i) * scrch2(i) + hy_gmcrgt(i) * scrch3(i)
-     
-     rhos(i)  = 1.e0 / vs(i)
-     rhos(i)  = max (hy_smlrho, rhos(i))
-     
-     vs(i)    = 1.e0 / rhos(i)
-     ws(i)    = wlft(i) * scrch2(i) + wrght(i) * scrch3(i)
-     ces(i)   = sqrt (gamcs(i) * ps(i) * vs(i))
-     
-     ! compute rhostar, using the shock jump condition (Fry Eq. 80)
-     
-     vstar(i)  = vs(i) - (pstar(i) - ps(i)) / ws(i) / ws(i)
-     rhostr(i) = 1.e0 / vstar(i)
-     cestar(i) = sqrt (gamcs(i) * pstar(i) * vstar(i))
-     
-! compute some factors, Fry Eq. 81 and 82       
+    ! compute values
+    pstar2(i) = prght(i) - plft(i) - wrght1(i) * (urght(i) - ulft(i))
+    pstar2(i) = plft(i) + pstar2(i) * wlft1(i) / (wlft1(i) + wrght1(i))
+    pstar2(i) = max(hy_smallp, pstar2(i))
 
-     wes(i)    = ces(i)    - scrch1(i) * us(i)
-     westar(i) = cestar(i) - scrch1(i) * ustar(i)
-     
-     scrch4(i) = ws(i) * vs(i) - scrch1(i) * us(i)
-     
-     
-     if (pstar(i) - ps(i) .ge. 0.e0) then
-        wes(i)    = scrch4(i)
-        westar(i) = scrch4(i)
-     endif
-     
-     wes(i)    = wes(i)    + scrch1(i) * ugrdl(i)
-     westar(i) = westar(i) + scrch1(i) * ugrdl(i)
   enddo
 
+  ! begin the secant iteration -- see CG Eq. 17 for details.  We will continue to
+  ! interate for convergence until the error falls below tol (in which case, 
+  ! things are good), or we hit hy_nriem iterations (in which case, Houston, we
+  ! have a problem, and we spit out an error).
+  hy_perror(1:2) = 1.e0
+  do i = 1, numFluxActv
+
+    hy_ptrial(1) = pstar1(i)
+    hy_ptrial(2) = pstar2(i)
+    
+    ! nonlinear solve
+    do n = 1, hy_nriem
+      
+      ! new values for the gamma at the "star" state -- again, using CG Eq. 31
+      gmstrl(i) = gamfac(i) * (pstar2(i) - plft(i))
+      gmstrl(i) = gmelft(i) + 2.e0 * gmstrl(i) / (pstar2(i) + plft(i))
+      
+      gmstrr(i) = gamfac(i) * (pstar2(i) - prght(i))
+      gmstrr(i) = gmerght(i) + 2.e0 * gmstrr(i) / (pstar2(i) + prght(i))
+      
+      gmstrl(i) = max(gmin(i), min(gmax(i), gmstrl(i)))
+      gmstrr(i) = max(gmin(i), min(gmax(i), gmstrr(i)))
+      
+      ! new nonlinear wave speeds, using CG Eq. 34 and the updated gammas
+      scrch1(i) = pstar2(i) - (gmstrl(i) - 1.e0) * plft(i) &
+                    / (gmelft(i) - 1.e0)
+      if (scrch1(i) .EQ. 0.e0) scrch1(i) = hy_smallp
+      
+      wlft(i)   = pstar2(i) + 0.5e0 * (gmstrl(i) - 1.e0) &
+           & * (pstar2(i) + plft(i))
+      wlft(i)   = (pstar2(i) - plft(i)) * wlft(i) / (vlft(i) * scrch1(i))
+      wlft(i)   = sqrt(abs(wlft(i)))
+
+      scrch2(i) = pstar2(i) - (gmstrr(i) - 1.e0) * prght(i) /(gmerght(i) - 1.e0)
+
+      if (scrch2(i) .EQ. 0.e0) scrch2(i) = hy_smallp
+      
+      wrght(i)  = pstar2(i) + 0.5e0 * (gmstrr(i) - 1.e0) &
+                    * (pstar2(i) + prght(i))
+      wrght(i)  = (pstar2(i) - prght(i)) * wrght(i) / (vrght(i) * scrch2(i))
+      wrght(i)  = sqrt(abs(wrght(i)))
+      
+      ! if the pressure jump is small, the wave speed is just the sound speed
+      if (abs (pstar2(i) - plft(i)) < small_dp*(pstar2(i) + plft(i))) wlft(i) = clft(i)
+      wlft(i)  = max (wlft(i), aux(i) * clft(i))
+      
+      if (abs (pstar2(i) - prght(i)) < small_dp*(pstar2(i) + prght(i))) wrght(i) = crght(i)
+      wrght(i) = max (wrght(i), aux(i) * crght(i))
+
+      ! compute the velocities in the "star" state -- using CG Eq. 18 -- ustrl2 and
+      ! ustrr2 are the velocities they define there.  ustrl1 and ustrl2 seem to be
+      ! the velocities at the last time, since pstar1 is the old 'star' pressure, and
+      ! wlft1 is the old wave speed.
+      ustrl1 = ulft(i) - (pstar1(i) -  plft(i)) /  wlft1(i)
+      ustrr1 = urght(i) + (pstar1(i) - prght(i)) / wrght1(i)
+      ustrl2 = ulft(i) - (pstar2(i) -  plft(i)) /   wlft(i)
+      ustrr2 = urght(i) + (pstar2(i) - prght(i)) /  wrght(i)
+      
+      delu1     = ustrl1 - ustrr1
+      delu2     = ustrl2 - ustrr2
+      scrch1(i) = delu2  - delu1
+      
+      if (abs(pstar2(i)-pstar1(i)) .le. hy_smallp) scrch1(i) = 0.e0
+      
+      if (abs(scrch1(i)) .lt. hy_smallu) then
+         delu2 = 0.e0
+         scrch1(i) = 1.e0
+      endif
+
+      ! pressure at the "star" state -- using CG Eq. 18
+      pstar(i)  = pstar2(i) - delu2 * (pstar2(i) - pstar1(i)) / scrch1(i)
+      pstar(i)  = max (hy_smallp, pstar(i))
+      
+      ! check for convergence of iteration, hy_riemanTol is a run-time parameter
+      pres_err = abs(pstar(i)-pstar2(i)) / pstar(i)
+      if (pres_err .lt. hy_riemanTol) goto 10
+      
+      ! reset variables for next iteration
+      pstar1(i) = pstar2(i)
+      pstar2(i) = pstar(i)
+
+      hy_ptrial(n+2) = pstar(i)
+      hy_perror(n+2) = pres_err
+      hy_wlft(n+2)   = wlft(i)
+      hy_wrght(n+2)  = wrght(i)
+      
+      wlft1(i)  = wlft(i)
+      wrght1(i) = wrght(i)
+      
+    enddo
+
+    n = n - 1
+
+    ! accept the solution if the error is reasonable...
+    if ( minval(hy_perror) <= hy_riemanTolAbort ) then
+
+      perr_minloc = minloc(hy_perror)
+
+      pstar(i) = hy_ptrial(perr_minloc(1))
+      wlft(i)  = hy_wlft(perr_minloc(1))
+      wrght(i) = hy_wrght(perr_minloc(1))
+
+      write(*,*) 'adopted'
+      write(*,'(i2, es13.5, es10.2)') perr_minloc(1), pstar(i), hy_perror(perr_minloc(1))
+      write(*,*)
+
+    else ! otherwise abort
+
+      write(*,*)
+      write(*,*)             '[RIEMAN] ERROR: Nonconvergence.'
+      call Driver_abortFlash('[RIEMAN] ERROR: Nonconvergence.')
+
+    end if
+     
+    ! land here if the iterations have converged
+    10   continue
+
+  end do
+
+  ! calculate fluid velocity for the "star" state -- this comes from the shock
+  ! jump equations, Fry Eq. 68 and 69.  The ustar velocity can be computed
+  ! using either the jump eq. for a left moving or right moving shock -- we use
+  ! the average of the two.
+  ! NOTE: Also look at Fry Eqn. 75 and 76.
+  do i = 1, numFluxActv
+
+    ! compute values
+    scrch3(i) = ulft(i) - (pstar(i) -  plft(i)) /  wlft(i)
+    scrch4(i) = urght(i) + (pstar(i) - prght(i)) / wrght(i)
+    ustar(i)  = 0.5e0 * (scrch3(i) + scrch4(i))
+
+  enddo
+
+  ! decide which state is located at the zone iterface based on the values 
+  ! of the wave speeds.  This is just saying that if ustar > 0, then the state
+  ! is U_L.  if ustar < 0, then the state on the axis is U_R.
+  do i = 1, numFluxActv
+
+    ! compute values
+    scrch1(i) = sign(1.e0, ustar(i))
+    scrch2(i) = 0.5e0 * ( 1.e0 + scrch1(i))
+    scrch3(i) = 0.5e0 * ( 1.e0 - scrch1(i))
+
+    ps(i)    = plft(i)   * scrch2(i) + prght(i)  * scrch3(i)
+    us(i)    = ulft(i)   * scrch2(i) + urght(i)  * scrch3(i)
+    uts(i)   = utlft(i)  * scrch2(i) + utrght(i) * scrch3(i)
+    utts(i)  = uttlft(i) * scrch2(i) + uttrght(i) * scrch3(i)
+    vs(i)    = vlft(i)   * scrch2(i) + vrght(i)  * scrch3(i)
+    games(i) = gmelft(i) * scrch2(i) + gmerght(i) * scrch3(i)
+    gamcs(i) = gmclft(i) * scrch2(i) + gmcrght(i) * scrch3(i)
+
+    rhos(i)  = 1.e0 / vs(i)
+    rhos(i)  = max (hy_smlrho, rhos(i))
+
+    vs(i)    = 1.e0 / rhos(i)
+    ws(i)    = wlft(i) * scrch2(i) + wrght(i) * scrch3(i)
+    ces(i)   = sqrt (gamcs(i) * ps(i) * vs(i))
+
+    ! compute rhostar, using the shock jump condition (Fry Eq. 80)
+    vstar(i)  = vs(i) - (pstar(i) - ps(i)) / ws(i) / ws(i)
+    rhostr(i) = 1.e0 / vstar(i)
+    cestar(i) = sqrt (gamcs(i) * pstar(i) * vstar(i))
+
+    ! compute some factors, Fry Eq. 81 and 82       
+    wes(i)    = ces(i)    - scrch1(i) * us(i)
+    westar(i) = cestar(i) - scrch1(i) * ustar(i)
+
+    scrch4(i) = ws(i) * vs(i) - scrch1(i) * us(i)
+
+
+    if (pstar(i) - ps(i) .ge. 0.e0) then
+      wes(i)    = scrch4(i)
+      westar(i) = scrch4(i)
+    endif
+
+    wes(i)    = wes(i)
+    westar(i) = westar(i)
 
+  enddo
+  
   ! compute Fry Eq. 86
-  do i = 5, numIntCells5
-     gamfac(i) = (1.e0 - games(i) / gamcs(i)) * (games(i) - 1.e0)
-     gmstar(i) = gamfac(i) * (pstar(i) - ps(i))
-     gmstar(i) = games(i) + 2.e0 * gmstar(i) / (pstar(i) + ps(i))
-     gmstar(i) = max (gmin(i), min (gmax(i), gmstar(i)))
+  do i = 1, numFluxActv
+
+    ! comput values
+    gamfac(i) = (1.e0 - games(i) / gamcs(i)) * (games(i) - 1.e0)
+    gmstar(i) = gamfac(i) * (pstar(i) - ps(i))
+    gmstar(i) = games(i) + 2.e0 * gmstar(i) / (pstar(i) + ps(i))
+    gmstar(i) = max (gmin(i), min (gmax(i), gmstar(i)))
+
   enddo
 
-  do i = 5, numIntCells5
-     eintAv(i) = hy_eiLft(i) * scrch2(i) + hy_eiRght(i) * scrch3(i)
+  do i = 1, numFluxActv
+    eintAv(i) = eilft(i) * scrch2(i) + eirght(i) * scrch3(i)
   enddo
   
   do n = 1, hy_numXn 
-     do i = 5, numIntCells5
-        xnav(i,n) = hy_xnlft(i,n) * scrch2(i) + hy_xnrght(i,n) * scrch3(i)
-     enddo
+    do i = 1, numFluxActv
+      xnav(i,n) = xnlft(i,n) * scrch2(i) + xnrght(i,n) * scrch3(i)
+    enddo
   enddo
   
-! compute correct state for rarefaction fan by linear interpolation
+  ! compute correct state for rarefaction fan by linear interpolation
+  do i = 1, numFluxActv
+
+    scrch1(i) = max (wes(i) - westar(i), wes(i) + westar(i), hy_smallu)
+    scrch1(i) =     (wes(i) + westar(i)) / scrch1(i)
+
+    scrch1(i) = 0.5e0 * (1.e0 + scrch1(i))
+    scrch2(i) =          1.e0 - scrch1(i)
+
+    rhoav(i)  = scrch1(i) * rhostr(i) + scrch2(i) * rhos (i)
+    uav  (i)  = scrch1(i) * ustar(i)  + scrch2(i) * us(i)
+    utav (i)  = uts(i)
+    uttav(i)  = utts(i)
+    pav(i) = scrch1(i) * pstar(i)  + scrch2(i) * ps(i)
+    gameav(i) = scrch1(i) * gmstar(i) + scrch2(i) * games(i)
 
-  do i = 5, numIntCells5
-     scrch1(i) = max (wes(i) - westar(i), wes(i) + westar(i), hy_smallu)
-     scrch1(i) =     (wes(i) + westar(i)) / scrch1(i)
-     
-     scrch1(i) = 0.5e0 * (1.e0 + scrch1(i))
-     scrch2(i) =          1.e0 - scrch1(i)
-     
-     rhoav(i)  = scrch1(i) * rhostr(i) + scrch2(i) * rhos (i)
-     uav  (i)  = scrch1(i) * ustar(i)  + scrch2(i) * us(i)
-     utav (i)  = uts(i)
-     uttav(i)  = utts(i)
-     pav   (i) = scrch1(i) * pstar(i)  + scrch2(i) * ps(i)
-     gameav(i) = scrch1(i) * gmstar(i) + scrch2(i) * games(i)
   enddo
   
-  do i = 5, numIntCells5
-     if (westar(i) .ge. 0.e0) then
-        rhoav(i)  = rhostr(i)
-        uav(i)    = ustar(i)
-        pav(i)    = pstar(i)
-        gameav(i) = gmstar(i)
-     endif
-     
-     if (wes(i) .lt. 0.e0) then
-        rhoav(i)  = rhos(i)
-        uav(i)    = us(i)
-        pav(i)    = ps(i)
-        gameav(i) = games(i)
-     endif
-     
-     urell(i) = uav(i) - ugrdl(i)
-  enddo
+  do i = 1, numFluxActv
 
-  return
-end subroutine rieman
-  
+    if (westar(i) .ge. 0.e0) then
+      rhoav(i)  = rhostr(i)
+      uav(i)    = ustar(i)
+      pav(i)    = pstar(i)
+      gameav(i) = gmstar(i)
+    endif
+
+    if (wes(i) .lt. 0.e0) then
+      rhoav(i)  = rhos(i)
+      uav(i)    = us(i)
+      pav(i)    = ps(i)
+      gameav(i) = games(i)
+    endif
+
+  end do
+
+end subroutine ppm_riemann
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90	2021-02-22 23:57:38.576465142 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/ppm_states.F90	2021-02-14 15:24:26.406762503 -0500
@@ -1,53 +1,15 @@
-!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/states
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/ppm_states
 !!
 !! NAME
 !! 
-!!  states
+!!  ppm_states
 !!
 !! SYNOPSIS
 !!
-!!  call states(integer(IN) :: numIntCells,
-!!              integer(IN) :: numCells,
-!!              integer(IN) :: j,
-!!              integer(IN) :: igeom,
-!!              real(IN)    :: rho(numCells),
-!!              real(IN)    :: u(numCells),
-!!              real(INOUT) :: rhol(numCells),
-!!              real(INOUT) :: rhor(numCells),
-!!              real(INOUT) :: ul(numCells),
-!!              real(INOUT) :: ur(numCells),
-!!              real(INOUT) :: utl(numCells),
-!!              real(INOUT) :: utr(numCells),
-!!              real(INOUT) :: uttl(numCells),
-!!              real(INOUT) :: uttr(numCells),
-!!              real(IN)    :: p(numCells),
-!!              real(INOUT) :: pl(numCells),
-!!              real(INOUT) :: pr(numCells),
-!!              real(IN) ::    gamcl(numCells),
-!!              real(IN) ::    gamcr(numCells),
-!!              real(IN)    :: ugrid(numCells),
-!!              real(IN) ::    ce(numCells),
-!!              real(IN) ::    game(numCells),
-!!              real(IN) ::    gamer(numCells),
-!!              real(IN) ::    gamc(numCells),
-!!              real(IN) ::    gamel(numCells),
-!!              real(IN)    :: eintl(numCells),
-!!              real(IN)    :: eintr(numCells),
-!!              real(IN)    :: xnl(numCells, hy_numXn),
-!!              real(IN)    :: xnr(numCells, hy_numXn),
-!!              real(IN)    :: dtdx(numCells),
-!!              real(IN)    :: dt,
-!!              real(IN)    :: x(numCells),
-!!              real(IN)    :: xl(numCells),
-!!              real(IN)    :: radial_coord(numCells),
-!!              real(IN) ::    grav(numCells),
-!!              real(IN) ::    fict(numCells))
-!!
-!! 
 !! DESCRIPTION
 !!  
-!!  Computes effective left and right states for input to Riemann
-!!  problems in PPM.  Naive guesses for these states based on the
+!!  Computes effective left and right ppm_states for input to Riemann
+!!  problems in PPM.  Naive guesses for these ppm_states based on the
 !!  left and right limits of the cubic interpolants are corrected
 !!  by taking into account information which reaches each cell
 !!  interface via the different characteristics.  This is done by
@@ -57,128 +19,89 @@
 !!
 !! SIDE EFFECTS
 !!
-!!  Modifies the following arrays exported by Hydro_data:
-!!   hy_clft,    hy_crght,
-!!   hy_plft,    hy_prght,
-!!   hy_ulft,    hy_urght,
-!!   hy_vlft,    hy_vrght,
-!!   hy_utlft,   hy_utrght,
-!!   hy_uttlft,  hy_uttrgt,
-!!   hy_gmelft,  hy_gmergt,
-!!   hy_gmclft,  hy_gmcrgt,
-!!   hy_eiLft,   hy_eiRght
-!!
 !! ARGUMENTS
 !!
-!! numIntCells :
-!! numCells :
-!! j :
-!! igeom :
-!! rho :
-!! u :
-!! rhol :
-!! rhor :
-!! ul :
-!! ur :
-!! utl :
-!! utr :
-!! uttl :
-!! uttr :
-!! p :
-!! pl :
-!! pr :
-!! gamcl :
-!! gamcr :
-!! ugrid :
-!! ce :
-!! game :
-!! gamer :
-!! gamc :
-!! gamel :
-!! eintl :
-!! eintr :
-!! xnl :
-!! xnr :
-!! dtdx :
-!! dt :
-!! x :
-!! xl :
-!! radial_coord :
-!! grav :
-!! fict :
-!!
-!!
 !!***
-subroutine states (numIntCells, numCells, &
-                   j, igeom,&
-                   rho, u, rhol, rhor, ul, ur, &
-                   utl, utr, uttl, uttr, p, pl, pr, &
-                   gamcl, gamcr, &
-                   ugrid, ce, game, gamer, gamc, gamel, &
-                   eintl, eintr, &
-                   xnl, xnr, &
-                   dtdx, dt, &
-                   x, xl, radial_coord, grav, fict)
-
-
 
-!=====================================================================
-!     compute left and right states for input to rieman problem
-  use Hydro_data, ONLY : hy_numXn
-  use Hydro_data, ONLY : hy_clft, hy_plft, hy_ulft, hy_utlft, hy_gmelft, hy_gmclft, &
-                         hy_dp, hy_p6, hy_du, hy_u6, hy_drho, hy_rho6, &
-                         hy_gravr, hy_dgrav, hy_grav6, hy_smallp, hy_smlrho, &
-                         hy_vlft, hy_uttlft, hy_xnlft, hy_crght, hy_prght, hy_urght, &
-                         hy_vrght, hy_utrght, hy_uttrgt, hy_gmergt, hy_gmcrgt, &
-                         hy_xnrght, hy_deint, hy_eint6, hy_eiLft, hy_eiRght, &
-                         hy_dut, hy_dutt, hy_utt6, hy_dgame, hy_game6, hy_dgamc, hy_gamc6, &
-                         hy_dxn, hy_xn6, hy_gravl, hy_ut6, &
-                         hy_ppmModifystates, hy_leveque, &
-                         hy_pwl, hy_pwr, hy_dpw, hy_pw6l, hy_pw6r, hy_pwcubic 
+subroutine ppm_states(numCells, numIntCells, numFluxActv, numIntrfcActv, fluxKey, intrfcKey, &
+                          rho, u, ut, utt, p, eint, grav, gamc, game, xn, &
+                          rhol, rhor, ul, ur, utl, utr, uttl, uttr, pl, pr, &
+                          eintl, eintr, pwl, pwr, gamel, gamer, gamcl, gamcr, &
+                          gravl, gravr, xnl, xnr, drhol, drhor, rho6l, rho6r, &
+                          dul, dur, u6l, u6r, dutl, dutr, ut6l, ut6r, duttl, &
+                          duttr, utt6l, utt6r, dpl, dpr, p6l, p6r, deintl, &
+                          deintr, eint6l, eint6r, dpwl, dpwr, pw6l, pw6r, &
+                          dgamel, dgamer, game6l, game6r, dgamcl, dgamcr, &
+                          gamc6l, gamc6r, dgravl, dgravr, grav6l, grav6r, &
+                          dxnl, dxnr, xn6l, xn6r, clft, crght, &
+                          ulft, urght, utlft, utrght, uttlft, uttrght, plft, &
+                          prght, eilft, eirght, gmelft, gmerght, gmclft, gmcrght, &
+                          vlft, vrght, xnlft, xnrght, jcell, igeom, ugrid, ce, &
+                          dtdx, dt, x, radial_coord, fict)
+
+  ! inputs from hydro module
+  use Hydro_data, ONLY : hy_ppmModifystates, hy_leveque, hy_numXn, &
+                         hy_cfl_crit, hy_cfl_warning, hy_cfl_max, CW_STATES, &
+                         hy_smallp, hy_smlrho
 
   implicit none
 
+  ! arguments
+  integer, intent(in) :: jcell, igeom, numIntCells, numCells, numFluxActv, &
+                          numIntrfcActv
+  real, intent(in) :: dt
+  integer, intent(in), dimension(numIntrfcActv) :: intrfcKey
+  integer, intent(in), dimension(numFluxActv) :: fluxKey
+  real, intent(in), dimension(numCells) :: rho, u, ut, utt, p, &
+                                            gamc, game, grav, eint
+  real, intent(in), dimension(numCells,hy_numXn) :: xn
+  real, intent(in), dimension(numIntrfcActv) :: rhol, rhor, ul, ur, utl, utr, &
+                                                 uttl, uttr, pl, pr, eintl, &
+                                                 eintr, pwl, pwr, gamel, &
+                                                 gamer, gamcl, gamcr, gravl, &
+                                                 gravr
+  real, intent(in), dimension(numIntrfcActv,hy_numXn) :: xnl, xnr
+  real, intent(in), dimension(numFluxActv) :: drhol, drhor, rho6l, rho6r, &
+                                               dul, dur, u6l, u6r, dutl, dutr, &
+                                               ut6l, ut6r, duttl, duttr, utt6l, &
+                                               utt6r, dpl, dpr, p6l, p6r, deintl, &
+                                               deintr, eint6l, eint6r, dgamel, &
+                                               dgamer, game6l, game6r, dgamcl, &
+                                               dgamcr, gamc6l, gamc6r, dgravl, &
+                                               dgravr, grav6l, grav6r, dpwl, dpwr, &
+                                               pw6l, pw6r
+  real, intent(in), dimension(numFluxActv,hy_numXn) :: dxnl, dxnr, xn6l, xn6r
+  real, intent(inout), dimension(numFluxActv) :: clft, crght, ulft, urght, utlft, &
+                                                  utrght, uttlft, uttrght, plft, &
+                                                  prght, eilft, eirght, gmelft, &
+                                                  gmerght, gmclft, gmcrght, &
+                                                  vlft, vrght
+  real, intent(inout), dimension(numFluxActv, hy_numXn) :: xnlft, xnrght
+  real, intent(in), dimension(numCells) :: ugrid, x, radial_coord
+  real, intent(in), dimension(numCells) :: dtdx, fict, ce
+
+  ! local
+  integer :: j, jlo, jhi, klo, khi
+  real, dimension(numFluxActv) :: pallpl, pallml
+  real, dimension(numFluxActv) :: ppl, pml, p0l
+  real, dimension(numFluxActv) :: upl, uml, u0l
+  real, dimension(numFluxActv) :: ut0l, utt0l
+  real, dimension(numFluxActv) :: rhopl, rhoml, rho0l
+  real, dimension(numFluxActv) :: gravpl, gravml
+  real, dimension(numFluxActv) :: game0l, gamc0l
+  real, dimension(numFluxActv) :: eint0l
+  real, dimension(numFluxActv, hy_numXn) :: xn0l
+  real, dimension(numFluxActv) :: scrch1, scrch2, scrch3, scrch4, cflno
+  real, dimension(numFluxActv) :: cel, cer, urell, urelr
+  real, dimension(numCells) :: dloga, urel ! need this?
 
-!!! ------ARGUMENTS -------------------------
-  integer, intent(IN):: j, igeom, numIntCells, numCells
-  real, intent(IN) :: dt
-  real, intent(IN), dimension(numCells) :: rho, u, p, ugrid, x, xl, &
-       radial_coord
-  real, intent(INOUT), dimension(numCells) :: rhol, rhor, ul, ur
-  real, intent(INOUT), dimension(numCells) :: utl, utr, uttl, uttr, pl, pr
-  real, intent(IN),    dimension(numCells) :: gamcl, gamc, gamcr
-  real, intent(IN),    dimension(numCells) :: ce, game, gamer, gamel
-  real, intent(IN),    dimension(numCells) :: eintl, eintr
-  real, intent(IN),    dimension(numCells) :: dtdx
-  real, intent(IN),    dimension(numCells) :: grav, fict
-  real, intent(INOUT), dimension(numCells, hy_numXn) :: xnl, xnr
-  
-
-
-!!! ---------LOCAL -----------------------------
-  real, dimension(numCells) :: pallpl, pallml
-  real, dimension(numCells) :: ppl, pml, p0l
-  real, dimension(numCells) :: upl, uml, u0l
-  real, dimension(numCells) :: ut0l, utt0l
-  real, dimension(numCells) :: rhopl, rhoml, rho0l
-  real, dimension(numCells) :: gravpl, gravml
-  real, dimension(numCells) :: game0l, gamc0l
-  real, dimension(numCells) :: eint0l
-  
-  real, dimension(numCells, hy_numXn) :: xn0l
-  
-  real, dimension(numCells) :: scrch1, scrch2, scrch3, scrch4,&
-                               dloga,cflno,urel
-
-
-
-!!  local
   integer :: numIntCells5, numIntCells6, numIntCells7, numIntCells8
   integer :: i, n
 
   real :: eta
   real :: clft_inv, crght_inv
   real :: qdt, hdt, fdt, slamm, slamp, scrch1_,  scrch2_
+  real :: const_dtdx
 
   real, PARAMETER :: forthd = 4.e00 / 3.e00
     
@@ -192,6 +115,7 @@
   real :: eplus, eminus
   real :: dele, delrho
 
+  real :: cfl_max
 
   numIntCells5 = numIntCells+5
   numIntCells6 = numIntCells+6
@@ -201,174 +125,128 @@
   qdt  = 0.25e0*dt
   hdt  = 0.50e0*dt
 
-!======================================================================
-!  Compute fluid velocities relative to the grid, which may be moving.
+  ! set constant dtdx to random
+  const_dtdx = dtdx(5)
 
-  do i = 1,numIntCells8
-     urel(i)  = u(i) - ugrid(i)
-     cflno(i) = 0.e0
+  !do i = 1,numIntCells8
+  !   urel(i)  = u(i) - ugrid(i)
+  !enddo
+
+  ! convert ce to two arrays
+  do i = 1, numFluxActv
+    j = fluxKey(i)
+    khi = intrfcKey(j)
+    cel(i) = ce(khi-1)
+    cer(i) = ce(khi)
+    urell(i) = u(khi-1)
+    urelr(i) = u(khi)
   enddo
 
-!!
-!!   LeVeque and Bale, 1988    Proc 7th Intl Conf on Hyperbolic Problems 
-!!   but the expressions below are closer to ``Accurate Simulation of
-!!   Rayleigh-Taylor-Instabilities'', Ralf Deiterding, Technical University
-!!   Cottbus.   Some of L&B's expressions aren't dimensionally correct??!
-!!
-  if (hy_leveque) then 
-     do i = 1,numIntCells8
-        capGamma = (game(i)*game(i)-game(i)+2.)/(game(i)-1.)
-        m     = rho(i)*u(i)
-        ei    = p(i)/(game(i)-1.)+(m*m/(2.*rho(i)))
-        if(i<numCells) h = xl(i+1)-xl(i)
-        
-        delrho = grav(i)*h/((game(i)-1.)*(m/rho(i)*m/rho(i)*capGamma - &
-             &      2.*game(i)*ei/rho(i)))
-        dele   = -rho(i)*grav(i)*h/(2.*ei*(game(i)-1))* &
-             &              ( 1. - m*m*(3.-game(i))/   &
-             & ((game(i)-1.)*(capGamma*m*m-2.*ei*game(i)*rho(i))))
-        
-        eplus  = ei*(1. + dele)
-        eminus = ei*(1. - dele)
-        
-        rplus  = rho(i)*(1. + delrho)
-        rminus = rho(i)*(1. - delrho)
-        rdelta = rho(i)*delrho
-        
-        pplus  = (game(i)-1.)*(eplus  - m*m/(2.*rplus))
-        pminus = (game(i)-1.)*(eminus - m*m/(2.*rminus))
-        pdelta = (pplus-pminus)/2.
-        
-        uplus  = m/rplus
-        uminus = m/rminus
-        udelta = (uplus-uminus)/2.
-        
-        pl(i) = pl(i) + pdelta
-        pr(i) = pr(i) - pdelta
-        
-        rhol(i) = rhol(i) + rdelta
-        rhor(i) = rhor(i) - rdelta
-        
-        ul(i) = ul(i) + udelta
-        ur(i) = ur(i) - udelta
-     enddo
-  endif
-
-! 1. FOR LEFT STATES : FRYXELL SECTION 3.1.5, EQNS 58 - 59
-!----------------------------------------------------------------------
-!       Compute averages for the left side of each interface.
-
-!       scrch#() here are domain factors used to compute the interpolant
-!       averages.  See Colella & Woodward (1984), eq. 1.12.
-
-!       Compute averages over the domain of dependence of the u+c characteri-
-!       stic, if it reaches the left sides of the interfaces.
-
-!
-!       the pressure is calculated twice.  One will only contain
-!       the `wave generating' pressure -- pressure in excess of 
-!       hydrostatic -- if ppm_modifystates is .true.   The other
-!       contains the full pressure; this is needed for the sound speed.
-!
-!       p{l,r},hy_dp,hy_p6 are the coefficients for the reconstruction of
-!                    the total pressure;
-!       pw{l,r},hy_dpw,pw6{l,r},hy_pwcubic are the coefficients for the 
-!                    reconstruction of the wave-generating pressure.
-!
-
-  ! 1-(a): u+c characteristic
-  do i = 5, numIntCells5
-     scrch1(i) = dtdx(i-1) * (urel(i-1) + ce(i-1)) ! eqn 59
-     cflno(i)  = max (0.e00, scrch1(i))            ! eqn 59
-     scrch1(i) = 0.5e00 * min (1.e00, cflno(i))    ! eqn 59: 1/2*beta
-     scrch2(i) = 1.e00 - forthd * scrch1(i)        ! eqn 58: 1-2/3*beta
-
-     ! now solve eqn 58
-     ppl(i)   = hy_pwr(i-1) - &
-          & scrch1(i) * (hy_dpw(i-1)   - scrch2(i) * hy_pw6l(i-1))    &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-     
-     pallpl(i)   = pr(i-1) - &
-          & scrch1(i) * (hy_dp(i-1)   - scrch2(i) * hy_p6(i-1))   
-     
-     upl(i)   = ur(i-1) - &
-          & scrch1(i) * (hy_du(i-1)   - scrch2(i) * hy_u6(i-1))
-
-     rhopl(i) = rhor(i-1) - &
-          & scrch1(i) * (hy_drho(i-1) - scrch2(i) * hy_rho6(i-1))
-     
-     gravpl(i) = hy_gravr(i-1) - &
-          & scrch1(i) * (hy_dgrav(i-1) - scrch2(i) * hy_grav6(i-1))
-     
-     rhopl(i)    = max (hy_smlrho, rhopl(i))
-     pallpl(i)   = max (hy_smallp, pallpl(i))
+  ! compute fluid velocities relative to the grid, which may be moving
+  !********* in this adaptive version we are not doing moving grids *******
+  cflno(:) = 0.0
+
+  !------- left states -------!
+
+  ! compute max cfl (replacing urel with u)
+  !cfl_max = maxval( const_dtdx * (abs(u(4:numIntCells5)) + abs(ce(4:numIntCells5))) )
+  !hy_cfl_max(CW_STATES) = max(cfl_max, hy_cfl_max(CW_STATES))
+  !if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_STATES) = .true.
+  cfl_max = maxval( const_dtdx * (abs(urell) + abs(cel)) )
+  cfl_max = maxval( const_dtdx * (abs(urelr) + abs(cer)) )
+  hy_cfl_max(CW_STATES) = max(cfl_max, hy_cfl_max(CW_STATES))
+  if (cfl_max > hy_cfl_crit) hy_cfl_warning(CW_STATES) = .true.
+
+  ! u+c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch variables
+    scrch1(i) = const_dtdx * (urell(i) + cel(i)) ! eqn 59
+    cflno(i)  = max (0.e00, scrch1(i))            ! eqn 59
+    scrch1(i) = 0.5e00 * min (1.e00, cflno(i))    ! eqn 59: 1/2*beta
+    scrch2(i) = 1.e00 - forthd * scrch1(i)        ! eqn 58: 1-2/3*beta
+
+    ! now solve eqn 58
+    ppl(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    pallpl(i) = pl(j) - scrch1(i) * (dpl(i) - scrch2(i) * p6l(i))
+    upl(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    rhopl(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    gravpl(i) = gravl(j) - scrch1(i) * (dgravl(i) - scrch2(i) * grav6l(i))
+    rhopl(i) = max(hy_smlrho, rhopl(i))
+    pallpl(i) = max(hy_smallp, pallpl(i))
+
   end do
   
-!       Compute averages over the domain of dependence of the u-c characteri-
-!       stic, if it reaches the left sides of the interfaces.
+  ! u-c characteristic
+  do i = 1, numFluxActv 
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch vars
+    scrch3(i) = const_dtdx * (urell(i) - cel(i))            ! eqn 59
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i))) ! eqn 59: 1/2*beta
+    scrch2(i) = 1.e00 - forthd * scrch1(i)                   ! eqn 58: 1-2/3*beta
+
+    ! eq. 58
+    pml(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    uml(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    rhoml(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    gravml(i) = gravl(j) - scrch1(i) * (dgravl(i) - scrch2(i) * grav6l(i))
 
-  ! 1-(b): u-c characteristic
-  do i = 5, numIntCells5
-     scrch3(i) = dtdx(i-1) * (urel(i-1) - ce(i-1))            ! eqn 59
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i))) ! eqn 59: 1/2*beta
-     scrch2(i) = 1.e00 - forthd * scrch1(i)                   ! eqn 58: 1-2/3*beta
-     
-     pml(i)   = hy_pwr(i-1) - &
-          & scrch1(i) * (hy_dpw(i-1)   - scrch2(i) * hy_pw6l(i-1))    &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-
-     uml(i)   = ur(i-1) - &
-          & scrch1(i) * (hy_du(i-1)   - scrch2(i) * hy_u6(i-1))
-
-     rhoml(i) = rhor(i-1) - &
-          & scrch1(i) * (hy_drho(i-1) - scrch2(i) * hy_rho6(i-1))
-     
-     gravml(i) = hy_gravr(i-1) - &
-          & scrch1(i) * (hy_dgrav(i-1) - scrch2(i) * hy_grav6(i-1))
   end do
 
   ! 1-(c): u characteristic
-  do i = 5, numIntCells5
-     scrch4(i) = dtdx(i-1) * urel(i-1)
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     p0l(i)    = hy_pwr(i-1) &
-          & - scrch1(i) * (hy_dpw(i-1)    - scrch2(i) * hy_pw6l(i-1)) &
-          & - (scrch1(i)**3)*hy_pwcubic(i)
-     
-     rho0l(i)  = rhor(i-1) &
-          & - scrch1(i) * (hy_drho(i-1)  - scrch2(i) * hy_rho6(i-1))
-     u0l(i)    = ur (i-1) &
-          & - scrch1(i) * (hy_du(i-1)    - scrch2(i) * hy_u6(i-1))
-     ut0l(i)   = utr(i-1) &
-          & - scrch1(i) * (hy_dut(i-1)   - scrch2(i) * hy_ut6(i-1))
-     utt0l(i)  = uttr(i-1) &
-          & - scrch1(i) * (hy_dutt(i-1)  - scrch2(i) * hy_utt6(i-1))
-     game0l(i) = gamer(i-1) &
-          &- scrch1(i) * (hy_dgame(i-1) - scrch2(i) * hy_game6(i-1))
-     gamc0l(i) = gamcr(i-1) &
-          &- scrch1(i) * (hy_dgamc(i-1) - scrch2(i) * hy_gamc6(i-1))
-  end do
-
-  do i = 5, numIntCells5
-     eint0l(i) = eintr(i-1) &
-          & - scrch1(i) * (hy_deint(i-1) - scrch2(i) * hy_eint6(i-1))
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! scratch vars
+    scrch4(i) = const_dtdx * urell(i)
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    ! eq. 58
+    p0l(i) = pwl(j) - scrch1(i) * (dpwl(i) - scrch2(i) * pw6l(i))
+    rho0l(i) = rhol(j) - scrch1(i) * (drhol(i) - scrch2(i) * rho6l(i))
+    u0l(i) = ul(j) - scrch1(i) * (dul(i) - scrch2(i) * u6l(i))
+    ut0l(i) = utl(j) - scrch1(i) * (dutl(i) - scrch2(i) * ut6l(i))
+    utt0l(i) = uttl(j) - scrch1(i) * (duttl(i) - scrch2(i) * utt6l(i))
+    game0l(i) = gamel(j) - scrch1(i) * (dgamel(i) - scrch2(i) * game6l(i))
+    gamc0l(i) = gamcl(j) - scrch1(i) * (dgamcl(i) - scrch2(i) * gamc6l(i))
+
+  end do
+
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! internal energy
+    eint0l(i) = eintl(j) - scrch1(i) * (deintl(i) - scrch2(i) * eint6l(i))
+
   end do
   
+  ! loop over species
   do n = 1, hy_numXn 
-     do i = 5, numIntCells5
-        xn0l(i,n) = xnr(i-1,n) &
-             & - scrch1(i) * (hy_dxn(i-1,n) - scrch2(i) * hy_xn6(i-1,n))
-     end do
-  end do
+
+    do i = 1, numFluxActv
+      j = fluxKey(i)
+      xn0l(i,n) = xnl(j,n) - scrch1(i) * (dxnl(i,n) - scrch2(i) * xn6l(i,n))
+    enddo
+
+  enddo
 
 ! 2. FOR LEFT STATES : FRYXELL SECTION 3.1.5, EQNS 62 - 67
 !-------------------------------------------------------------------------------
 !       Now compute the modified states for the left sides of cell interfaces,
 !       excluding the effects of source terms and geometry, which are taken
 !       into account later.  The computation of the Lagrangian sound speed
-!       (hy_clft) takes into account a bug correction relayed by E. Muller (was
+!       (clft) takes into account a bug correction relayed by E. Muller (was
 !       using gamc(i), should use gamc(i-1)).
 
 !       scrch1() and scrch2() here are, respectively, C*(beta+ +/- beta-) and
@@ -377,284 +255,305 @@
 !       domain of dependence to the size of the zone) for the u-c and u charac-
 !       teristics, respectively.
 
-  do i = 5, numIntCells5
-     hy_clft(i)  = sqrt (gamc(i-1) * pallpl(i) * rhopl(i))       ! (rho*c)
-     clft_inv = 1.e0 / hy_clft(i)                                ! 1./(rho*c)
-     
-     scrch1_   = 0.5e00 * (upl(i) - uml(i) - (ppl(i) - pml(i)) & ! C*beta^{-}_l -- a part of eqn Fry 62
-          * clft_inv)                                            ! NOTE: beta^{+}_l = 0.
-     
-     scrch2_   = (ppl(i) - p0l(i)) * clft_inv * clft_inv &       ! eqn Fry 63
-          + 1.e00/rhopl(i)
-     
-     scrch2_   = scrch2_ - 1.e00 / rho0l(i)                      ! beta^{0}, eqn Fry 63
-     
-     if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
-     if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
-     
-     hy_plft(i)   = ppl(i) + hy_clft(i) * scrch1_
-     hy_plft(i)   = max (hy_plft(i), hy_smallp)
-     
-     hy_ulft(i)   = upl(i) - scrch1_ + hdt*fict(i-1)
-     
-     hy_vlft(i)   = 1.e00 / rhopl(i) - scrch2_ - scrch1_ * clft_inv !v=1/rho
-     hy_vlft(i)   = min (hy_vlft(i), 1.e0/hy_smlrho)
-     
-     hy_utlft(i)  = ut0l(i)
-     hy_uttlft(i) = utt0l(i)
-     hy_gmelft(i) = game0l(i)
-     hy_gmclft(i) = gamc0l(i)
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(j) - 1
+
+    ! compute
+    clft(i) = sqrt(gamc(klo) * pallpl(i) * rhopl(i))       ! (rho*c)
+    clft_inv = 1.e0 / clft(i)                                ! 1./(rho*c)
+    scrch1_ = 0.5e00 * (upl(i) - uml(i) - (ppl(i) - pml(i)) & ! C*beta^{-}_l -- a part of eqn Fry 62
+                * clft_inv)                                            ! NOTE: beta^{+}_l = 0.
+    scrch2_ = (ppl(i) - p0l(i)) * clft_inv * clft_inv &       ! eqn Fry 63
+              + 1.e00/rhopl(i)
+    scrch2_ = scrch2_ - 1.e00 / rho0l(i)                      ! beta^{0}, eqn Fry 63
+
+    if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
+    if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
+
+    plft(i)   = ppl(i) + clft(i) * scrch1_
+    plft(i)   = max(plft(i), hy_smallp)
+
+    ulft(i)   = upl(i) - scrch1_ + hdt*fict(klo)
+
+    vlft(i)   = 1.e00 / rhopl(i) - scrch2_ - scrch1_ * clft_inv !v=1/rho
+    vlft(i)   = min(vlft(i), 1.e0/hy_smlrho)
+
+    utlft(i)  = ut0l(i)
+    uttlft(i) = utt0l(i)
+    gmelft(i) = game0l(i)
+    gmclft(i) = gamc0l(i)
+
   end do
-  do i = 5, numIntCells5
-     hy_eiLft(i) = eint0l(i)
+
+  do i = 1, numFluxActv
+    eilft(i) = eint0l(i)
   end do
+
+  ! loop over species
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        hy_xnlft(i,n) = xn0l(i,n)
-     end do
+    do i = 1, numFluxActv
+      xnlft(i,n) = xn0l(i,n)
+    end do
   end do
+
+  ! now correct the left states to include geometry terms
+  !if (igeom .eq. 0)   then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = 0.e00
+  !   end do
+  !else if (igeom .le. 2) then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = igeom / x(i)
+  !   end do
+  !else if (igeom .eq. 3  .or. igeom .eq. 5) then
+  !   do i = 1, numIntCells8
+  !      dloga(i) = 0.e00
+  !   end do
+  !else
+  !   do i = 1, numIntCells8
+  !      dloga(i) = cos(x(i))/(sin(x(i)) * radial_coord(jcell))
+  !   enddo
+  !   
+  !end if
+ 
+  !if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
+  !   do i = 1, numIntCells8
+  !      scrch1_  = (abs (u(i) - ugrid(i)) + ce(i)) * const_dtdx
+  !      if ( dt < TINY(1.e0) ) then
+  !         eta = 1.e0
+  !      else
+  !         eta = (1.e00 - scrch1_) / (ce(i) * dt * abs (dloga(i)))
+  !      end if
+  !      eta      = min (eta, 1.e00)
+  !      dloga(i) = eta * dloga(i)
+  !   end do
+  !endif
   
-!       Now correct the left states to include geometry terms.
-  
-  
-  if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
-     if (igeom .eq. 1)   then
-        do i = 4, numIntCells5
-           dloga(i) = 1.0 / x(i)
-        end do
-     else if (igeom .eq. 2) then
-        do i = 4, numIntCells5
-           dloga(i) = 2.0 / x(i)
-        end do
-     else
-        do i = 4, numIntCells5
-           dloga(i) = cos(x(i))/(sin(x(i)) * radial_coord(j))
-        enddo
-     end if
-     do i = 4, numIntCells5
-        scrch1_  = (abs (u(i) - ugrid(i)) + ce(i)) * dtdx(i)
-        eta      = (1.e00 - scrch1_) / (ce(i) * dt * abs (dloga(i)))
-        eta      = min (eta, 1.e00)
-        dloga(i) = eta * dloga(i)
-     end do
-  
-     do i = 5, numIntCells5
-        scrch1_   = 0.5e00 * rho(i-1) * u(i-1) * dt * dloga(i-1)
-        hy_vlft(i)   = 1.e00 / hy_vlft(i) - scrch1_
-        hy_vlft(i)   = 1.e00 / hy_vlft(i)
-        hy_plft(i)   = hy_plft(i) - scrch1_ * ce(i-1)**2
-        hy_plft(i)   = max (hy_plft(i), hy_smallp)
-        hy_vlft(i)   = min (hy_vlft(i), 1.e0/hy_smlrho)
-     end do
-  end if
-  
-  if (.not. (hy_ppmModifystates .or. hy_leveque)) then
-     
-     do i = 5, numIntCells5
-        slamm = urel(i-1) - ce(i-1)
-        slamp = urel(i-1) + ce(i-1)
-        
-        if ( slamm.le.0.e0 ) gravml(i) = 0.e0
-        if ( slamp.le.0.e0 ) gravpl(i) = 0.e0
-        
-        if ( slamm.gt.0.e0 .and. slamp.gt.0.e0 ) then
-           fdt = qdt
-        else
-           fdt = hdt
-        end if
-        
-        hy_ulft(i) = hy_ulft(i) + fdt*(gravpl(i)+gravml(i))
-     end do
-     
-  end if
+  do i = 1, numFluxActv
 
-! 3. FOR RIGHT STATES : FRYXELL SECTION 3.1.5, EQNS 60 - 61
-!-------------------------------------------------------------------------------
-!       Compute averages for the right side of each interface.
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    klo = intrfcKey(j) - 1
+
+    scrch1_   = 0.0e0 ! 0.5e00 * rho(klo) * u(klo) * dt * dloga(klo)
+    vlft(i)   = 1.e00 / vlft(i) - scrch1_
+    vlft(i)   = 1.e00 / vlft(i)
+    plft(i)   = plft(i) - scrch1_ * cel(i)**2
+    plft(i)   = max (plft(i), hy_smallp)
+    vlft(i)   = min (vlft(i), 1.e0/hy_smlrho)
+
+  end do
+
+  ! done need this if not using gravity?? *******************
+  !if (.not. (hy_ppmModifystates.or.hy_leveque)) then
 
-!       scrch#() here are geometry factors used to compute the interpolant
-!       averages.  See Colella & Woodward (1984), eq. 1.12.
+  !  do i = 1, numFluxActv
 
-!       Compute averages over the domain of dependence of the u+c characteri-
-!       stic, if it reaches the right sides of the interfaces.
+  !    ! compute interface mapping
+  !    j = fluxKey(i)
+  !    jlo = fluxKey(i) - 1
+
+  !    ! compute cell indices left and right of target interface
+  !    klo = intrfcKey(jlo)
+  !    khi = intrfcKey(j)
+
+  !    slamm = urel(klo) - ce(klo)
+  !    slamp = urel(klo) + ce(klo)
+
+  !    if ( slamm.le.0.e0 ) gravml(i) = 0.e0
+  !    if ( slamp.le.0.e0 ) gravpl(i) = 0.e0
+
+  !    if ( slamm.gt.0.e0 .and. slamp.gt.0.e0 ) then
+  !      fdt = qdt
+  !    else
+  !      fdt = hdt
+  !    end if
+
+  !    ulft(khi) = ulft(khi) + fdt*(gravpl(i)+gravml(i))
+
+  !  end do
+
+  !end if
+
+  !------- right states -------!
+
+  ! u+c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute
+    scrch3(i) = -const_dtdx * (urelr(i) + cer(i))
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i)))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    ppl(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    upl(i) = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    rhopl(i) = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    gravpl(i) = gravr(j) + scrch1(i) * (dgravr(i) + scrch2(i) * grav6r(i))
+
+  end do
+
+  ! u-c characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute
+    scrch1(i) = -const_dtdx * (urelr(i) - cer(i))
+    scrch1(i) = max(0.e00, scrch1(i))
+    cflno(i)  = max(cflno(i), scrch1(i))
+    scrch1(i) = 0.5e00 * min(1.e00, scrch1(i))
+    scrch2(i) = 1.e00 - forthd * scrch1(i)
+
+    pml(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    pallml(i) = pr(j) + scrch1(i) * (dpr(i) + scrch2(i) * p6r(i))
+    uml(i) = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    rhoml(i) = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    gravml(i) = gravr(j) + scrch1(i) * (dgravr(i) + scrch2(i) * grav6r(i))
+
+    pallml(i) = max(pallml(i), hy_smallp)
+    rhoml(i)  = max(rhoml(i), hy_smlrho)
+
+  end do
+
+  ! u characteristic
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    scrch4(i) = -const_dtdx * urelr(i)
+    scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
+    scrch2(i) = 1.0e00 - forthd * scrch1(i)
+
+    p0l(i) = pwr(j) + scrch1(i) * (dpwr(i) + scrch2(i) * pw6r(i))
+    rho0l(i)  = rhor(j) + scrch1(i) * (drhor(i) + scrch2(i) * rho6r(i))
+    u0l(i)    = ur(j) + scrch1(i) * (dur(i) + scrch2(i) * u6r(i))
+    ut0l(i)   = utr(j) + scrch1(i) * (dutr(i) + scrch2(i) * ut6r(i))
+    utt0l(i)  = uttr(j) + scrch1(i) * (duttr(i) + scrch2(i) * utt6r(i))
+    game0l(i) = gamer(j) + scrch1(i) * (dgamer(i) + scrch2(i) * game6r(i))
+    gamc0l(i) = gamcr(j) + scrch1(i) * (dgamcr(i) + scrch2(i) * gamc6r(i))       
 
-!
-!       the pressure is calculated twice.  One will only contain
-!       the `wave generating' pressure -- pressure in excess of 
-!       hydrostatic -- if ppm_modifystates is .true.   The other
-!       contains the full pressure; this is needed for the sound speed.
-!
-!       p{l,r},hy_dp,hy_p6 are the coefficients for the reconstruction of
-!                    the total pressure;
-!       p{l,r},hy_dpw,pw6{l,r},hy_pwcubic are the coefficients for the 
-!                    reconstruction of the wave-generating pressure.
-!
-
-  ! 3-(a): u+c characteristic
-  do i= 5, numIntCells5
-     scrch3(i) = -dtdx(i) * (urel(i) + ce(i))
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch3(i)))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     ppl(i)   = hy_pwl(i)   + scrch1(i) * (hy_dpw(i)   + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     upl(i)   = ul(i)   + scrch1(i) * (hy_du(i)   + scrch2(i) * hy_u6(i))
-     rhopl(i) = rhol(i) + scrch1(i) * (hy_drho(i) + scrch2(i) * hy_rho6(i))
-     
-     gravpl(i) = hy_gravl(i) +  &
-          & scrch1(i) * (hy_dgrav(i) + scrch2(i) * hy_grav6(i))
-  end do
-
-!       Compute averages over the domain of dependence of the u-c characteri-
-!       stic, if it reaches the right sides of the interfaces.
-  ! 3-(b): u-c characteristic
-  do i = 5, numIntCells5
-     scrch1(i) = -dtdx(i) * (urel(i) - ce(i))
-     scrch1(i) = max (0.e00, scrch1(i))
-     cflno(i)  = max (cflno(i), scrch1(i))
-     scrch1(i) = 0.5e00 * min (1.e00, scrch1(i))
-     scrch2(i) = 1.e00 - forthd * scrch1(i)
-     
-     pml(i)   = hy_pwl(i)   + scrch1(i) * (hy_dpw(i)   + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     pallml(i)   = pl(i)   + scrch1(i) * (hy_dp(i)   + scrch2(i) * hy_p6(i))
-     
-     uml(i)   = ul(i)   + scrch1(i) * (hy_du(i)   + scrch2(i) * hy_u6(i))
-     rhoml(i) = rhol(i) + scrch1(i) * (hy_drho(i) + scrch2(i) * hy_rho6(i))
-     
-     gravml(i) = hy_gravl(i) + &
-          & scrch1(i) * (hy_dgrav(i) + scrch2(i) * hy_grav6(i))
-     
-     pallml(i) = max (pallml(i), hy_smallp)
-     rhoml(i)  = max (rhoml(i), hy_smlrho)
-  end do
-
-  ! 3-(c): u characteristic
-  do i = 5, numIntCells5
-     scrch4(i) = -dtdx(i) * urel(i)
-     scrch1(i) = 0.5e00 * min (1.e00, max (0.e00, scrch4(i)))
-     scrch2(i) = 1.0e00 - forthd * scrch1(i)
-     
-     p0l(i)    = hy_pwl(i)   &
-          &        + scrch1(i) * (hy_dpw(i)    + scrch2(i) * hy_pw6r(i)) &
-          & + (scrch1(i)**3)*hy_pwcubic(i)
-     
-     rho0l(i)  = rhol(i) &
-          &        + scrch1(i) * (hy_drho(i)  + scrch2(i) * hy_rho6(i))
-     u0l(i)    = ul(i)   &
-          &        + scrch1(i) * (hy_du(i)    + scrch2(i) * hy_u6(i))
-     ut0l(i)   = utl(i)  &
-          &        + scrch1(i) * (hy_dut(i)   + scrch2(i) * hy_ut6(i))
-     utt0l(i)  = uttl(i) &
-          &        + scrch1(i) * (hy_dutt(i)  + scrch2(i) * hy_utt6(i))
-     game0l(i) = gamel(i) &
-          &        + scrch1(i) * (hy_dgame(i) + scrch2(i) * hy_game6(i))
-     gamc0l(i) = gamcl(i) &
-          &        + scrch1(i) * (hy_dgamc(i) + scrch2(i) * hy_gamc6(i))       
   end do
   
-  do i = 5, numIntCells5
-     eint0l(i) = eintl(i) &
-          &        + scrch1(i) * (hy_deint(i) + scrch2(i) * hy_eint6(i))
+  do i = 1, numFluxActv
+    j = fluxKey(i)
+    eint0l(i) = eintr(j) + scrch1(i) * (deintr(i) + scrch2(i) * eint6r(i))
   end do
 
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        xn0l(i,n) = xnl(i,n) &
-             &        + scrch1(i) * (hy_dxn(i,n) + scrch2(i) * hy_xn6(i,n))
-     end do
+
+    do i = 1, numFluxActv
+      j = fluxKey(i)
+      xn0l(i,n) = xnr(j,n) + scrch1(i) * (dxnr(i,n) + scrch2(i) * xn6r(i,n))
+    end do
+
   end do
   
-! 4. FOR RIGHT STATES : FRYXELL SECTION 3.1.5, EQNS 62 - 67
-!-------------------------------------------------------------------------------
-!       Now compute the modified states for the right sides of cell interfaces,
-!       excluding the effects of source terms and geometry, which are taken
-!       into account later.
+  !------- modifed states for right side -------!
 
-!       scrch1() and scrch2() here are, respectively, C*(beta+ +/- beta-) and
-!       beta0.  See Colella & Woodward (1984), eq. 3.6 and 3.7.  The arrays
-!       scrch3() and scrch4() are domain factors (the ratio of the size of the
-!       domain of dependence to the size of the zone) for the u+c and u charac-
-!       teristics, respectively.
+  do i = 1, numFluxActv
+
+    ! compute interface mapping
+    j = fluxKey(i)
+
+    ! compute cell indices left and right of target interface
+    khi = intrfcKey(j)
+
+    crght(i)  = sqrt(gamc(khi) * pallml(i) * rhoml(i))           ! (rho*c)
+    crght_inv = 1.e0 / crght(i)                                 ! 1./(rho*c)
+
+    scrch1_   = -0.5e00 * (uml(i) - upl(i) + (pml(i) - ppl(i))  &  ! C*beta^{+}_r -- a part of eqn Fry 62
+                  * crght_inv)                                              ! NOTE: beta^{-1}_r = 0.
+
+    scrch2_   = (pml(i) - p0l(i)) * crght_inv * crght_inv  &       ! eqn Fry 63
+        + 1.e00 / rhoml(i)
+
+    scrch2_   = scrch2_ - 1.e00 / rho0l(i)                         ! beta^{0}_r, eqn Fry 63
+
+    if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
+    if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
 
-  do i = 5, numIntCells5
-     hy_crght(i)  = sqrt (gamc(i) * pallml(i) * rhoml(i))           ! (rho*c)
-     crght_inv = 1.e0 / hy_crght(i)                                 ! 1./(rho*c)
-     
-     scrch1_   = -0.5e00 * (uml(i) - upl(i) + (pml(i) - ppl(i))  &  ! C*beta^{+}_r -- a part of eqn Fry 62
-          * crght_inv)                                              ! NOTE: beta^{-1}_r = 0.
-     
-     scrch2_   = (pml(i) - p0l(i)) * crght_inv * crght_inv  &       ! eqn Fry 63
-          + 1.e00 / rhoml(i)
-     
-     scrch2_   = scrch2_ - 1.e00 / rho0l(i)                         ! beta^{0}_r, eqn Fry 63
-     
-     if (-scrch3(i) .GE. 0.e0) scrch1_   = 0.e0
-     if (-scrch4(i) .GE. 0.e0) scrch2_   = 0.e0
-     
-     hy_prght(i)  = pml(i) + hy_crght(i) * scrch1_                  ! eqn Fry 65
-     hy_prght(i)  = max (hy_prght(i), hy_smallp)
-
-     hy_urght(i)  = uml(i) + scrch1_ + hdt*fict(i)                  ! eqn Fry 66
-     
-     hy_vrght(i)  = 1.e00 / rhoml(i) - scrch2_ - scrch1_ *crght_inv ! v=1/rho
-     hy_vrght(i)  = min (hy_vrght(i), 1.e0/hy_smlrho)
-     
-     hy_utrght(i) = ut0l(i)
-     hy_uttrgt(i) = utt0l(i)
-     hy_gmergt(i) = game0l(i)
-     hy_gmcrgt(i) = gamc0l(i)
+    prght(i)  = pml(i) + crght(i) * scrch1_                  ! eqn Fry 65
+    prght(i)  = max(prght(i), hy_smallp)
+    urght(i)  = uml(i) + scrch1_ + hdt*fict(khi)                  ! eqn Fry 66
+    vrght(i)  = 1.e00 / rhoml(i) - scrch2_ - scrch1_ *crght_inv ! v=1/rho
+    vrght(i)  = min (vrght(i), 1.e0/hy_smlrho)
+    utrght(i) = ut0l(i)
+    uttrght(i) = utt0l(i)
+    gmerght(i) = game0l(i)
+    gmcrght(i) = gamc0l(i)
 
   end do
 
-  do i = 5, numIntCells5
-     hy_eiRght(i) = eint0l(i)
+  do i = 1, numFluxActv
+    eirght(i) = eint0l(i)
   end do
 
   do n = 1, hy_numXn
-     do i = 5, numIntCells5
-        hy_xnrght(i,n) = xn0l(i,n)
-     end do
+    do i = 1, numFluxActv
+      xnrght(i,n) = xn0l(i,n)
+    end do
   end do
   
-  !       Now correct the right states to include geometry terms.
+  ! Now correct the right states to include geometry terms.
+  do i = 1, numFluxActv
 
+    ! compute interface mapping
+    j = fluxKey(i)
 
-  if (igeom .eq. 1 .or. igeom .eq. 2 .or. igeom .eq. 4)   then
-     do i = 5, numIntCells5
-        scrch1_   = 0.5e00 * rho(i) * u(i) * dt * dloga(i)
-        hy_vrght(i)  = 1.e00 / hy_vrght(i) - scrch1_
-        hy_vrght(i)  = 1.e00 / hy_vrght(i)
-        hy_prght(i)  = hy_prght(i) - scrch1_ * ce(i)**2
-        hy_prght(i)  = max (hy_prght(i), hy_smallp)
-        hy_vrght(i)  = min (hy_vrght(i), 1.e0/hy_smlrho)
-     end do
-  end if
-
-  if (.not. (hy_ppmModifystates .or. hy_leveque)) then
-     
-     do i = 5, numIntCells5
-        slamm = urel(i) - ce(i)
-        slamp = urel(i) + ce(i)
-        
-        if ( slamm.ge.0.e0 ) gravml(i) = 0.e0
-        if ( slamp.ge.0.e0 ) gravpl(i) = 0.e0
-        
-        if ( slamm.lt.0.e0 .and. slamp.lt.0.e0 ) then
-           fdt = qdt
-        else
-           fdt = hdt
-        end if
-        
-        hy_urght(i) = hy_urght(i) + fdt*(gravpl(i)+gravml(i))
-     end do
-     
-  end if
+    ! compute cell indices left and right of target interface
+    khi = intrfcKey(j)
+
+    scrch1_   = 0.0 !0.5e00 * rho(khi) * u(khi) * dt * dloga(khi)
+    vrght(i)  = 1.e00 / vrght(i) - scrch1_
+    vrght(i)  = 1.e00 / vrght(i)
+    prght(i)  = prght(i) - scrch1_ * cer(i)**2
+    prght(i)  = max(prght(i), hy_smallp)
+    vrght(i)  = min(vrght(i), 1.e0/hy_smlrho)
+
+  end do
+ 
+  !if (.not. (hy_ppmModifystates .or. hy_leveque)) then
+
+  !  do i = 1, numFluxActv
+
+  !    ! compute interface mapping
+  !    j = fluxKey(i)
+  !    jlo = fluxKey(i) - 1
+
+  !    ! compute cell indices left and right of target interface
+  !    klo = intrfcKey(jlo)
+  !    khi = intrfcKey(j)
+
+  !    slamm = urel(khi) - ce(khi)
+  !    slamp = urel(khi) + ce(khi)
+
+  !    if ( slamm.ge.0.e0 ) gravml(i) = 0.e0
+  !    if ( slamp.ge.0.e0 ) gravpl(i) = 0.e0
+
+  !    if ( slamm.lt.0.e0 .and. slamp.lt.0.e0 ) then
+  !    fdt = qdt
+  !    else
+  !    fdt = hdt
+  !    end if
+
+  !    urght(khi) = urght(khi) + fdt*(gravpl(i)+gravml(i))
+
+  !  end do
+
+  !end if
 
-  if(xl(5) .ne. 0.e00) return
-  
   return
-end subroutine states
 
+end subroutine ppm_states
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmp.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmp.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmp.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmp.F90	2021-02-14 15:24:26.404762445 -0500
@@ -0,0 +1,234 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_ausmp
+!!
+!! NAME
+!!
+!!  riemann_ausmp
+!!
+!!
+!! SYNOPSIS
+!!
+!!  call riemann_ausmp ( real(in)    :: rho_left,
+!!                       real(in)    :: rho_right,
+!!                       real(in)    :: u_left,
+!!                       real(in)    :: u_right,
+!!                       real(in)    :: ut_left,
+!!                       real(in)    :: ut_right,
+!!                       real(in)    :: utt_left,
+!!                       real(in)    :: utt_right,
+!!                       real(in)    :: p_left,
+!!                       real(in)    :: p_right,
+!!                       real(in)    :: e_left,
+!!                       real(in)    :: e_right,
+!!                       real(in)    :: ei_left,
+!!                       real(in)    :: ei_right,
+!!                       real(in)    :: game_left,
+!!                       real(in)    :: game_right,
+!!                       real(in)    :: gamc_left,
+!!                       real(in)    :: gamc_right,
+!!                       real(in)    :: grav_left,
+!!                       real(in)    :: grav_right,
+!!                       real(in)    :: dt,
+!!                       real(inout) :: rho_flux,
+!!                       real(inout) :: u_flux,
+!!                       real(inout) :: ut_flux,
+!!                       real(inout) :: utt_flux,
+!!                       real(inout) :: e_flux,
+!!                       real(inout) :: ei_flux)
+!!
+!! DESCRIPTION
+!!
+!!  An approximate-flux Riemann solver that implements the AUSM+
+!!  (Advection Upstream Splitting Algorithm) of Liou (1996). This is used in shocks
+!!  to avoid carbuncle pheonomenon or odd-even decoupling. Also performs well with
+!!  slowly moving/stationary shocks.
+!!
+!!  Given the states on the left and right of the interface, compute the
+!!  fluxes through the interface.
+!!
+!!  See Liou, M.S., 1996, JCP, 129, 364 "A Sequel to AUSM: AUSM+"
+!!   (equation numbers refer to the first reference, unless otherwise noted)
+!!
+!!
+!! NOTES
+!!
+!!  -- This operates on the zone average values to the left and the
+!!     right of the interface, *NOT* the reconstructed interface values
+!!     as returned from states.
+!!
+!!  -- We ignore the grid velocity in here.
+!!
+!!  -- This code is adapted from HOTB
+!!
+!! ARGUMENTS
+!!
+!! rho_left:
+!! rho_right:
+!! u_left:
+!! u_right:
+!! ut_left:
+!! ut_right:
+!! utt_left:
+!! utt_right:
+!! p_left:
+!! p_right:
+!! e_left:
+!! e_right:
+!! ei_left:
+!! ei_right:
+!! game_left:
+!! game_right:
+!! gamc_left:
+!! gamc_right:
+!! grav_left:
+!! grav_right:
+!! dt:
+!! rho_flux:
+!! u_flux:
+!! ut_flux:
+!! utt_flux:
+!! e_flux:
+!! ei_flux:
+!!
+!!
+!!
+!!***
+
+subroutine riemann_ausmp(rho_left,  rho_right, &
+                         u_left,    u_right, &
+                         ut_left,   ut_right, &
+                         utt_left,  utt_right, &
+                         p_left,    p_right, &
+                         e_left,    e_right, &
+                         ei_left,   ei_right, &
+                         game_left, game_right, &
+                         gamc_left, gamc_right, &
+                         xn_left,   xn_right,   &
+                         grav_left, grav_right, &
+                         fict_left, fict_right, &
+                         dt, &
+                         rho_flux, u_flux, ut_flux, utt_flux, &
+                         pav, e_flux, ei_flux, xnav)
+
+  use Hydro_data, ONLY : hy_small, hy_numXn
+
+  implicit none
+
+#include "Flash.h"
+
+  real, INTENT(in) :: rho_left, rho_right
+  real, INTENT(in) :: u_left, u_right
+  real, INTENT(in) :: ut_left, ut_right
+  real, INTENT(in) :: utt_left, utt_right
+  real, INTENT(in) :: p_left, p_right
+  real, INTENT(in) :: e_left, e_right
+  real, INTENT(in) :: ei_left, ei_right
+  real, INTENT(in) :: game_left, game_right
+  real, INTENT(in) :: gamc_left, gamc_right
+  real, INTENT(in) :: xn_left(hy_numXn), xn_right(hy_numXn)
+  real, INTENT(in) :: grav_left, grav_right
+  real, INTENT(in) :: fict_left, fict_right
+  real, INTENT(in) :: dt
+
+  real, INTENT(inout) :: rho_flux, u_flux, ut_flux, utt_flux, &
+                         pav, e_flux, ei_flux, xnav(hy_numXn)
+
+  integer :: i
+  real :: hdt
+  real :: u_l, u_r, urel_l, urel_r
+  real :: ei_l, ei_r, e_l, e_r, h_l, h_r
+  real :: alst2, arst2, altld, artld, ah
+  real :: cml, cmr, cmlp, cmrm, plp, prm
+  real :: wmh, wmhp, wmhm
+
+  ! Tunable parameters (see Lemma 3.2)
+  real, parameter :: alpha = 3.e0/16.e0, &
+                     beta  = 1.e0/8.e0
+
+!===============================================================================
+
+  hdt = 0.5e0*dt
+
+  ! Store left/right velocities
+  u_l = u_left
+  u_r = u_right
+
+  !--------------------------------
+  ! Apply sources. If this function is being called using the L/R states from states.F90,
+  ! then the input grav and fict sources should be set to zero, as they've already been applied.
+  ! Otherwise, if this is used as part of the cell-centered hybrid approach, these should be
+  ! the half timestep advanced values
+
+  ! Apply gravity
+  u_l = u_l + hdt*grav_left
+  u_r = u_r + hdt*grav_right
+
+  ! Apply fict forces
+  u_l = u_l + hdt*fict_left
+  u_r = u_r + hdt*fict_right
+
+  !--------------------------------
+
+  ! Compute the energies
+  ei_l = p_left /(game_left  - 1.e0)/rho_left
+  ei_r = p_right/(game_right - 1.e0)/rho_right
+
+  e_l  = ei_l*rho_left  + 0.5e0*rho_left *(u_l**2 + K2D*ut_left**2  + K3D*utt_left**2 )
+  e_r  = ei_r*rho_right + 0.5e0*rho_right*(u_r**2 + K2D*ut_right**2 + K3D*utt_right**2)
+
+  ! Compute specific total enthalpies
+  h_l = (e_l + p_left ) / rho_left
+  h_r = (e_r + p_right) / rho_right
+
+  ! Common (critical) sound speed
+  ! Eqns (27) & (40)
+  alst2 = h_l/(game_left /((game_left  - 1.e0)*gamc_left ) + 0.5e0)
+  arst2 = h_r/(game_right/((game_right - 1.e0)*gamc_right) + 0.5e0)
+  altld = alst2/max(sqrt(alst2), abs(u_l))
+  artld = arst2/max(sqrt(arst2), abs(u_r))
+  ah    = min(altld, artld)
+
+  ! Pressure and Mach number splittings
+  ! Eqns (19a), (21a) when M=urel/ah < 1.e0
+  cml = u_l/ah
+  cmr = u_r/ah
+  cmlp = 0.5e0*(cml + abs(cml))
+  cmrm = 0.5e0*(cmr - abs(cmr))
+  plp  = 0.5e0*(1.e0 + sign(1.e0,cml))
+  prm  = 0.5e0*(1.e0 - sign(1.e0,cmr))
+
+  ! When M=urel/ah >= 1.e0, Eqns (19b), (21b)
+  if(abs(cml) < 1.e0) then
+    cmlp = 0.25e0*(cml + 1.e0)**2 + beta*(cml*cml - 1.e0)**2
+    plp  = 0.25e0*(cml + 1.e0)**2 * (2.e0 - cml) + alpha*cml*(cml*cml - 1.e0)**2
+  endif
+
+  if(abs(cmr) < 1.e0) then
+    cmrm = -0.25e0*(cmr - 1.e0)**2 - beta*(cmr*cmr - 1.e0)**2
+    prm  =  0.25e0*(cmr - 1.e0)**2 * (2.e0 + cml) - alpha*cmr*(cmr*cmr - 1.e0)**2
+  endif
+
+  ! Mass flux
+  wmh  = cmlp + cmrm
+  wmhp = 0.5e0*(wmh + abs(wmh))
+  wmhm = 0.5e0*(wmh - abs(wmh))
+
+  pav = plp*p_left + prm*p_right
+
+  ! Total flux
+  e_l = e_l/rho_left
+  e_r = e_r/rho_right
+
+  rho_flux = ah*(wmhp*rho_left           + wmhm*rho_right          )
+  u_flux   = ah*(wmhp*rho_left*u_l       + wmhm*rho_right*u_r      )
+  ut_flux  = ah*(wmhp*rho_left*ut_left   + wmhm*rho_right*ut_right )
+  utt_flux = ah*(wmhp*rho_left*utt_left  + wmhm*rho_right*utt_right)
+  e_flux   = ah*(wmhp*rho_left*h_l       + wmhm*rho_right*h_r      )
+  ei_flux  = ah*(wmhp*rho_left*ei_l      + wmhm*rho_right*ei_r     )
+
+  ! Set average species
+  do i=1,hy_numXn
+    xnav(i) = wmhp*xn_left(i) + wmhm*xn_right(i)
+  enddo
+
+
+end subroutine riemann_ausmp
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpup.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpup.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpup.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpup.F90	2021-02-14 15:24:26.405762475 -0500
@@ -0,0 +1,271 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_ausmpup
+!!
+!! NAME
+!!
+!!  riemann_ausmpup
+!!
+!!
+!! SYNOPSIS
+!!
+!!  call riemann_ausmpup ( real(in)    :: rho_left,
+!!                       real(in)    :: rho_right,
+!!                       real(in)    :: u_left,
+!!                       real(in)    :: u_right,
+!!                       real(in)    :: ut_left,
+!!                       real(in)    :: ut_right,
+!!                       real(in)    :: utt_left,
+!!                       real(in)    :: utt_right,
+!!                       real(in)    :: p_left,
+!!                       real(in)    :: p_right,
+!!                       real(in)    :: e_left,
+!!                       real(in)    :: e_right,
+!!                       real(in)    :: ei_left,
+!!                       real(in)    :: ei_right,
+!!                       real(in)    :: game_left,
+!!                       real(in)    :: game_right,
+!!                       real(in)    :: gamc_left,
+!!                       real(in)    :: gamc_right,
+!!                       real(in)    :: grav_left,
+!!                       real(in)    :: grav_right,
+!!                       real(in)    :: dt,
+!!                       real(inout) :: rho_flux,
+!!                       real(inout) :: u_flux,
+!!                       real(inout) :: ut_flux,
+!!                       real(inout) :: utt_flux,
+!!                       real(inout) :: e_flux,
+!!                       real(inout) :: ei_flux)
+!!
+!! DESCRIPTION
+!!
+!!  An approximate-flux Riemann solver that implements the AUSM+
+!!  (Advection Upstream Splitting Algorithm) of Liou (1996). This is used in shocks
+!!  to avoid carbuncle pheonomenon or odd-even decoupling. Also performs well with
+!!  slowly moving/stationary shocks.
+!!
+!!  Given the states on the left and right of the interface, compute the
+!!  fluxes through the interface.
+!!
+!!  See Liou, M.S., 1996, JCP, 129, 364 "A Sequel to AUSM: AUSM+"
+!!   (equation numbers refer to the first reference, unless otherwise noted)
+!!
+!!
+!! NOTES
+!!
+!!  -- This operates on the zone average values to the left and the
+!!     right of the interface, *NOT* the reconstructed interface values
+!!     as returned from states.
+!!
+!!  -- We ignore the grid velocity in here.
+!!
+!!  -- This code is adapted from HOTB
+!!
+!! ARGUMENTS
+!!
+!! rho_left:
+!! rho_right:
+!! u_left:
+!! u_right:
+!! ut_left:
+!! ut_right:
+!! utt_left:
+!! utt_right:
+!! p_left:
+!! p_right:
+!! e_left:
+!! e_right:
+!! ei_left:
+!! ei_right:
+!! game_left:
+!! game_right:
+!! gamc_left:
+!! gamc_right:
+!! grav_left:
+!! grav_right:
+!! dt:
+!! rho_flux:
+!! u_flux:
+!! ut_flux:
+!! utt_flux:
+!! e_flux:
+!! ei_flux:
+!!
+!!
+!!
+!!***
+
+subroutine riemann_ausmpup(rho_left,  rho_right,  &
+                           u_left,    u_right,    &
+                           ut_left,   ut_right,   &
+                           utt_left,  utt_right,  &
+                           p_left,    p_right,    &
+                           e_left,    e_right,    &
+                           ei_left,   ei_right,   &
+                           game_left, game_right, &
+                           gamc_left, gamc_right, &
+                           xn_left,   xn_right,   &
+                           grav_left, grav_right, &
+                           fict_left, fict_right, &
+                           dt,                    &
+                           rho_flux, u_flux, ut_flux, utt_flux, &
+                           pav, e_flux, ei_flux, xnav_flux)
+
+  use Hydro_data, ONLY : hy_small, hy_numXn
+
+  implicit none
+
+#include "Flash.h"
+
+  real, INTENT(in) :: rho_left, rho_right
+  real, INTENT(in) :: u_left, u_right
+  real, INTENT(in) :: ut_left, ut_right
+  real, INTENT(in) :: utt_left, utt_right
+  real, INTENT(in) :: p_left, p_right
+  real, INTENT(in) :: e_left, e_right
+  real, INTENT(in) :: ei_left, ei_right
+  real, INTENT(in) :: game_left, game_right
+  real, INTENT(in) :: gamc_left, gamc_right
+  real, INTENT(in) :: xn_left(hy_numXn), xn_right(hy_numXn)
+  real, INTENT(in) :: grav_left, grav_right
+  real, INTENT(in) :: fict_left, fict_right
+  real, INTENT(in) :: dt
+
+  real, INTENT(inout) :: rho_flux, u_flux, ut_flux, utt_flux, &
+                         pav, e_flux, ei_flux, xnav_flux(hy_numXn)
+
+  integer :: i
+  real :: hdt
+  real :: u_l, u_r, urel_l, urel_r, umag_l, umag_r
+  real :: ei_l, ei_r, e_l, e_r, h_l, h_r
+  real :: alst2, arst2, altld, artld, ah
+
+  real :: ML, MR, Mh, Mm2, Mo2, Mo, fa
+
+  real :: Mp1L, Mm1R, Mp2L, Mm2L, Mp2R, Mm2R, Mp4L, Pp5L, Mm4R, Pm5R
+  real :: tmp, mdot, mdotL, mdotR, w_l, w_r
+
+  ! Tunable parameters (see Lemma 3.2)
+  real :: alpha, beta
+  real, parameter :: Ku    = 0.75e0, &
+                     Kp    = 0.25e0, &
+                     sigma = 1.e0,   &
+                     Minf2 = 0.4e0
+
+!===============================================================================
+
+  hdt = 0.5e0*dt
+
+  ! Store left/right velocities
+  u_l = u_left
+  u_r = u_right
+
+  !--------------------------------
+  ! Apply sources. If this function is being called using the L/R states from states.F90,
+  ! then the input grav and fict sources should be set to zero, as they've already been applied.
+  ! Otherwise, if this is used as part of the cell-centered hybrid approach, these should be
+  ! the half timestep advanced values
+
+  ! Apply gravity
+  u_l = u_l + hdt*grav_left
+  u_r = u_r + hdt*grav_right
+
+  ! Apply fict forces
+  u_l = u_l + hdt*fict_left
+  u_r = u_r + hdt*fict_right
+
+  !--------------------------------
+
+  ! Compute the energies
+  ei_l = p_left /(game_left  - 1.e0)/rho_left
+  ei_r = p_right/(game_right - 1.e0)/rho_right
+
+  e_l  = ei_l*rho_left  + 0.5e0*rho_left *(u_l**2 + K2D*ut_left**2  + K3D*utt_left**2 )
+  e_r  = ei_r*rho_right + 0.5e0*rho_right*(u_r**2 + K2D*ut_right**2 + K3D*utt_right**2)
+
+  ! Compute specific total enthalpies
+  h_l = (e_l + p_left ) / rho_left
+  h_r = (e_r + p_right) / rho_right
+
+  ! Common (critical) sound speed
+  ! Eqns (27) & (40)
+  alst2 = h_l/(game_left /((game_left  - 1.e0)*gamc_left ) + 0.5e0)
+  arst2 = h_r/(game_right/((game_right - 1.e0)*gamc_right) + 0.5e0)
+  altld = alst2/max(sqrt(alst2), abs(u_l))
+  artld = arst2/max(sqrt(arst2), abs(u_r))
+  ah    = min(altld, artld)
+
+  ! Compute alpha and beta
+  Mm2 = 0.5e0*(u_l**2 + u_r**2)/ah**2
+  Mo2 = min(1.e0, max(Minf2, Mm2))
+  Mo  = sqrt(Mo2)
+  fa  = Mo*(2.e0 - Mo)
+
+  alpha = (3.e0/16.e0)*(-4.e0 + 5.e0*fa*fa)
+  beta  = 1.e0/8.e0
+
+  ! Pressure and Mach number splittings
+  ML = u_l/ah
+  MR = u_r/ah
+
+  Mp1L = 0.5e0*(ML + abs(ML))
+  Mm1R = 0.5e0*(MR - abs(MR))
+  Mp2L =   0.25e0*(ML + 1.0e0)*(ML + 1.0e0)
+  Mm2L = - 0.25e0*(ML - 1.0e0)*(ML - 1.0e0)
+  Mp2R =   0.25e0*(MR + 1.0e0)*(MR + 1.0e0)
+  Mm2R = - 0.25e0*(MR - 1.0e0)*(MR - 1.0e0)
+
+  if(abs(ML) >= 1.0e0) then
+    Mp4L = Mp1L
+    Pp5L = Mp1L/ML
+  else
+    Mp4L = Mp2L*(1.0e0 - 16.0e0*beta*Mm2L)
+    Pp5L = Mp2L*((2.0e0 - ML) - 16.0e0*alpha*ML*Mm2L)
+  endif
+
+  if(abs(MR) >= 1.0e0) then
+    Mm4R = Mm1R
+    Pm5R = Mm1R/MR
+  else
+    Mm4R = Mm2R*(1.0e0 + 16.0e0*beta*Mp2R);
+    Pm5R = Mm2R*(( -2.0e0 - MR) + 16.0e0*alpha*MR*Mp2R);
+  endif
+
+  tmp = max(0.e0, 1.e0-sigma*Mm2)
+
+  Mh  = Mp4L + Mm4R - 2.e0*(Kp/fa)*tmp*(p_right - p_left)/(rho_left + rho_right)/ah**2
+
+  pav = Pp5L*p_left + Pm5R*p_right
+  pav = pav - Ku*Pp5L*Pm5R*(rho_left + rho_right)*(fa*ah)*(u_r - u_l)
+
+  mdot = ah*Mh
+  if(Mh > 0.e0) then
+    mdot = mdot*rho_left
+  else
+    mdot = mdot*rho_right
+  endif
+
+  mdotL = 0.e0
+  mdotR = 0.e0
+  w_l   = 0.e0
+  w_r   = 0.e0
+  if(mdot > 0.e0) then
+    mdotL = mdot
+    w_l   = 1.e0
+  else
+    mdotR = mdot
+    w_r   = 1.e0
+  endif
+
+  ! Total flux
+  rho_flux = mdotL          + mdotR
+  u_flux   = mdotL*u_l      + mdotR*u_r
+  ut_flux  = mdotL*ut_left  + mdotR*ut_right
+  utt_flux = mdotL*utt_left + mdotR*utt_right
+  e_flux   = mdotL*h_l      + mdotR*h_r
+  ei_flux  = mdotL*ei_l     + mdotR*ei_r
+
+  ! Set average species
+  do i=1,hy_numXn
+    xnav_flux(i) = w_l*xn_left(i) + w_r*xn_right(i)
+  enddo
+
+end subroutine riemann_ausmpup
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpupit.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpupit.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpupit.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_ausmpupit.F90	2021-02-14 15:24:26.400762329 -0500
@@ -0,0 +1,333 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_ausmpupit
+!!
+!! NAME
+!!
+!!  riemann_ausmpupit
+!!
+!!
+!! SYNOPSIS
+!!
+!!  call riemann_ausmpup ( real(in)    :: rho_left,
+!!                       real(in)    :: rho_right,
+!!                       real(in)    :: u_left,
+!!                       real(in)    :: u_right,
+!!                       real(in)    :: ut_left,
+!!                       real(in)    :: ut_right,
+!!                       real(in)    :: utt_left,
+!!                       real(in)    :: utt_right,
+!!                       real(in)    :: p_left,
+!!                       real(in)    :: p_right,
+!!                       real(in)    :: e_left,
+!!                       real(in)    :: e_right,
+!!                       real(in)    :: ei_left,
+!!                       real(in)    :: ei_right,
+!!                       real(in)    :: game_left,
+!!                       real(in)    :: game_right,
+!!                       real(in)    :: gamc_left,
+!!                       real(in)    :: gamc_right,
+!!                       real(in)    :: grav_left,
+!!                       real(in)    :: grav_right,
+!!                       real(in)    :: dt,
+!!                       real(inout) :: rho_flux,
+!!                       real(inout) :: u_flux,
+!!                       real(inout) :: ut_flux,
+!!                       real(inout) :: utt_flux,
+!!                       real(inout) :: e_flux,
+!!                       real(inout) :: ei_flux)
+!!
+!! DESCRIPTION
+!!
+!!  An approximate-flux Riemann solver that implements the AUSM+
+!!  (Advection Upstream Splitting Algorithm) of Liou (1996). This is used in shocks
+!!  to avoid carbuncle pheonomenon or odd-even decoupling. Also performs well with
+!!  slowly moving/stationary shocks.
+!!
+!!  Given the states on the left and right of the interface, compute the
+!!  fluxes through the interface.
+!!
+!!  See Liou, M.S., 1996, JCP, 129, 364 "A Sequel to AUSM: AUSM+"
+!!   (equation numbers refer to the first reference, unless otherwise noted)
+!!
+!!
+!! NOTES
+!!
+!!  -- This operates on the zone average values to the left and the
+!!     right of the interface, *NOT* the reconstructed interface values
+!!     as returned from states.
+!!
+!!  -- We ignore the grid velocity in here.
+!!
+!!  -- This code is adapted from HOTB
+!!
+!! ARGUMENTS
+!!
+!! rho_left:
+!! rho_right:
+!! u_left:
+!! u_right:
+!! ut_left:
+!! ut_right:
+!! utt_left:
+!! utt_right:
+!! p_left:
+!! p_right:
+!! e_left:
+!! e_right:
+!! ei_left:
+!! ei_right:
+!! game_left:
+!! game_right:
+!! gamc_left:
+!! gamc_right:
+!! grav_left:
+!! grav_right:
+!! dt:
+!! rho_flux:
+!! u_flux:
+!! ut_flux:
+!! utt_flux:
+!! e_flux:
+!! ei_flux:
+!!
+!!
+!!
+!!***
+
+subroutine riemann_ausmpupit(rho_left,  rho_right,  &
+                             u_left,    u_right,    &
+                             ut_left,   ut_right,   &
+                             utt_left,  utt_right,  &
+                             p_left,    p_right,    &
+                             e_left,    e_right,    &
+                             ei_left,   ei_right,   &
+                             game_left, game_right, &
+                             gamc_left, gamc_right, &
+                             xn_left,   xn_right,   &
+                             grav_left, grav_right, &
+                             fict_left, fict_right, &
+                             dt,dx,             &
+                             rho_flux, u_flux, ut_flux, utt_flux, &
+                             pav, e_flux, ei_flux, xnav, vhOld)
+
+  use Hydro_data, ONLY : hy_small, hy_numXn
+
+  implicit none
+
+#include "Flash.h"
+
+  real, INTENT(in) :: rho_left, rho_right
+  real, INTENT(in) :: u_left, u_right
+  real, INTENT(in) :: ut_left, ut_right
+  real, INTENT(in) :: utt_left, utt_right
+  real, INTENT(in) :: p_left, p_right
+  real, INTENT(in) :: e_left, e_right
+  real, INTENT(in) :: ei_left, ei_right
+  real, INTENT(in) :: game_left, game_right
+  real, INTENT(in) :: gamc_left, gamc_right
+  real, INTENT(in) :: xn_left(hy_numXn), xn_right(hy_numXn)
+  real, INTENT(in) :: grav_left, grav_right
+  real, INTENT(in) :: fict_left, fict_right
+  real, INTENT(in) :: dt, dx
+
+  real, INTENT(inout) :: rho_flux, u_flux, ut_flux, utt_flux, pav, &
+                         e_flux, ei_flux, xnav(hy_numXn), vhOld
+
+  integer :: i
+  real :: hdt
+  real :: u_l, u_r, urel_l, urel_r, umag_l, umag_r
+  real :: ei_l, ei_r, e_l, e_r, h_l, h_r
+  real :: alst2, arst2, altld, artld, ah
+
+  real :: ML, MR, Mh, Mm2, Mo2, Mo, fa, MhIT, dudx, dpdx, dvdt, vh
+
+  real :: Mp1L, Mm1R, Mp2L, Mm2L, Mp2R, Mm2R, Mp4L, Pp5L, Mm4R, Pm5R
+  real :: tmp, mdot, mdotL, mdotR, w_l, w_r
+
+  ! Tunable parameters (see Lemma 3.2)
+  real :: alpha, beta
+  real, parameter :: Ku    = 0.75e0, &
+                     Kp    = 0.25e0, &
+		     Ki    = 0.25e0,   &
+                     sigma = 1.e0,   &
+                     Minf2 = 0.4e0
+
+!===============================================================================
+
+  hdt = 0.5e0*dt
+
+  ! Store left/right velocities
+  u_l = u_left
+  u_r = u_right
+
+  !--------------------------------
+  ! Apply sources. If this function is being called using the L/R states from states.F90,
+  ! then the input grav and fict sources should be set to zero, as they've already been applied.
+  ! Otherwise, if this is used as part of the cell-centered hybrid approach, these should be
+  ! the half timestep advanced values
+
+  ! Apply gravity
+  u_l = u_l + hdt*grav_left
+  u_r = u_r + hdt*grav_right
+
+  ! Apply fict forces
+  u_l = u_l + hdt*fict_left
+  u_r = u_r + hdt*fict_right
+
+
+  !Take spatial derivative
+  dudx = (u_r - u_l)/dx
+  dpdx = (p_right - p_left)/dx
+  !--------------------------------
+
+  ! Compute the energies
+  ei_l = p_left /(game_left  - 1.e0)/rho_left
+  ei_r = p_right/(game_right - 1.e0)/rho_right
+
+  e_l  = ei_l*rho_left  + 0.5e0*rho_left *(u_l**2 + K2D*ut_left**2  + K3D*utt_left**2 )
+  e_r  = ei_r*rho_right + 0.5e0*rho_right*(u_r**2 + K2D*ut_right**2 + K3D*utt_right**2)
+
+  ! Compute specific total enthalpies
+  h_l = (e_l + p_left ) / rho_left
+  h_r = (e_r + p_right) / rho_right
+
+  ! Common (critical) sound speed
+  ! Eqns (27) & (40)
+  alst2 = h_l/(game_left /((game_left  - 1.e0)*gamc_left ) + 0.5e0)
+  arst2 = h_r/(game_right/((game_right - 1.e0)*gamc_right) + 0.5e0)
+  altld = alst2/max(sqrt(alst2), abs(u_l))
+  artld = arst2/max(sqrt(arst2), abs(u_r))
+  ah    = min(altld, artld)
+
+!
+
+  ! Compute alpha and beta
+  Mm2 = 0.5e0*(u_l**2 + u_r**2)/ah**2
+  Mo2 = min(1.e0, max(Minf2, Mm2))
+  Mo  = sqrt(Mo2)
+  fa  = Mo*(2.e0 - Mo)
+
+  alpha = (3.e0/16.e0)*(-4.e0 + 5.e0*fa*fa)
+  beta  = 1.e0/8.e0
+
+  ! Pressure and Mach number splittings
+  ML = u_l/ah
+  MR = u_r/ah
+
+  Mp1L = 0.5e0*(ML + abs(ML))
+  Mm1R = 0.5e0*(MR - abs(MR))
+  Mp2L =   0.25e0*(ML + 1.0e0)*(ML + 1.0e0)
+  Mm2L = - 0.25e0*(ML - 1.0e0)*(ML - 1.0e0)
+  Mp2R =   0.25e0*(MR + 1.0e0)*(MR + 1.0e0)
+  Mm2R = - 0.25e0*(MR - 1.0e0)*(MR - 1.0e0)
+
+  if(abs(ML) >= 1.0e0) then
+    Mp4L = Mp1L
+    Pp5L = Mp1L/ML
+  else
+    Mp4L = Mp2L*(1.0e0 - 16.0e0*beta*Mm2L)
+    Pp5L = Mp2L*((2.0e0 - ML) - 16.0e0*alpha*ML*Mm2L)
+  endif
+
+  if(abs(MR) >= 1.0e0) then
+    Mm4R = Mm1R
+    Pm5R = Mm1R/MR
+  else
+    Mm4R = Mm2R*(1.0e0 + 16.0e0*beta*Mp2R);
+    Pm5R = Mm2R*(( -2.0e0 - MR) + 16.0e0*alpha*MR*Mp2R);
+  endif
+
+  tmp = max(0.e0, 1.e0-sigma*Mm2)
+
+ 
+  Mh  = Mp4L + Mm4R - 2.e0*(Kp/fa)*tmp*(p_right - p_left)/(rho_left + rho_right)/ah**2 
+  !write(*,*)"RIEM", u_l, u_r, dudx, (Mh - MhIT)/Mh, Mh*ah, MhIT*ah
+  !write(*,*) "RIEM2", Ki, fa, tmp, ah**2
+  pav = Pp5L*p_left + Pm5R*p_right
+  pav = pav - Ku*Pp5L*Pm5R*(rho_left + rho_right)*(fa*ah)*(u_r - u_l)
+  !if (tmp .gt. 0.e0) then
+      vh = vhalf(ah, Mp4L+Mm4R, Kp, (rho_left+rho_right)/2.e0, fa, vhOld, Ki, tmp, dx,dt)
+  !write(*,*) "Riem", vh, Mh*ah, tmp, vhOld, u_l, u_r
+  !else 
+      vh  = ah*(Mp4L + Mm4R - 2.e0*(Kp/fa)*tmp*(p_right - p_left)/(rho_left + rho_right)/ah**2) 
+  !endif
+  !write(*,*), "RIEM", vhOld - vh
+  vhOld = vh
+  
+  ! $a^b = \int{\phi^2(x)dx}$ 
+  MhIT = vh/ah 
+  !Get set to compute the mass flux
+  mdot = ah*MhIT
+  if(Mh > 0.e0) then
+    mdot = mdot*rho_left
+  else 
+    mdot = mdot*rho_right
+  endif
+
+  mdotL = 0.e0
+  mdotR = 0.e0
+  w_l   = 0.e0
+  w_r   = 0.e0
+  if(mdot > 0.e0) then
+    mdotL = mdot
+    w_l   = 1.e0
+  else
+    mdotR = mdot
+    w_r   = 1.e0
+  endif
+
+  ! Total flux
+  rho_flux = mdotL          + mdotR
+  u_flux   = mdotL*u_l      + mdotR*u_r
+  ut_flux  = mdotL*ut_left  + mdotR*ut_right
+  utt_flux = mdotL*utt_left + mdotR*utt_right
+  e_flux   = mdotL*h_l      + mdotR*h_r
+  ei_flux  = mdotL*ei_l     + mdotR*ei_r
+
+  ! Set average species
+  do i=1,hy_numXn
+    xnav(i) = w_l*xn_left(i) + w_r*xn_right(i)
+  enddo
+
+
+CONTAINS 
+
+REAL FUNCTION vhalf(ah, Mh, kp, rhobar, fc, vh0, ki, tmp, delX,h)
+  implicit none 
+
+  real, intent(IN):: ah, Mh, kp, rhobar, fc, vh0, ki, tmp, delX,h
+  real ::x0,diff, xnew,f, fprime, tol = 1.0e-6
+  integer :: count=0
+  x0 = vh0
+  diff = 1.0e0 
+  do while ((abs(diff) .ge. tol) .AND. (count .le. 2000))
+    f = x0 - vh0 + (h*ah*fc*x0)/(ki*tmp*delX) + (h*kp/rhobar)/(ki*tmp*delX) - (h*ah**2 * Mh * fc)/(ki*tmp*delX)
+    fprime = (1+(h*ah*fc)/(ki+tmp*delX)) 
+    !write(*,*)"Newton", vh0, x0, f,fprime, (h*ah*fc*x0)/(ki*tmp*delX), (h*kp/rhobar)/(ki*tmp*delX)
+
+    xnew = x0 - f/fprime
+    diff = x0 - Xnew
+    x0 = xnew
+    !write(*,*) "Newton-Rhaps", vh0, f, fprime, x0, count, diff
+
+    count = count + 1
+   
+  end do
+
+
+  count = 0  
+  vhalf = x0
+
+!  write(*,*) count, vhalf
+
+
+
+
+END Function vhalf
+
+
+
+end subroutine riemann_ausmpupit
+
+
+
+
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90	2021-02-22 23:57:38.575465113 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_hlle.F90	2021-02-14 15:24:26.401762358 -0500
@@ -1,3 +1,4 @@
+#define DEBUG_HLLE 0
 !!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_hlle
 !!
 !! NAME
@@ -121,7 +122,8 @@
                         gamc_left, gamc_right, &
                         grav_left, grav_right, &
                         dt, &
-                        rho_flux, u_flux, ut_flux, utt_flux, e_flux, ei_flux)
+                        rho_flux, u_flux, ut_flux, utt_flux, &
+                        e_flux, ei_flux)
 
   use Hydro_data, ONLY : hy_small
 
@@ -363,6 +365,9 @@
           bp*bm*(rho_right*ei_right - rho_left*ei_left))*bdifi
 
   end if
+#if DEBUG_HLLE > 0
+
+  write(*,*) 'fluxes', rho_flux, u_flux, ut_flux, utt_flux, e_flux, ei_flux
+#endif
 
-  return
 end subroutine riemann_hlle
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_roe.F90 source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_roe.F90
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_roe.F90	1969-12-31 19:00:00.000000000 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/mrPPMKernel/riemann_roe.F90	2021-02-14 15:24:26.405762475 -0500
@@ -0,0 +1,512 @@
+!!****if* source/physics/Hydro/HydroMain/split/PPM/PPMKernel/riemann_roe
+!!
+!! NAME
+!!
+!!  riemann_roe
+!!
+!!
+!! SYNOPSIS
+!!
+!!  call riemann_roe ( real(in) :: rho_left,  
+!!                real(in) :: rho_right, 
+!!                real(in) :: u_left,
+!!                real(in) :: u_right, 
+!!                real(in) :: ut_left, 
+!!                real(in) :: ut_right, 
+!!                real(in) :: utt_left,
+!!                real(in) :: utt_right, 
+!!               real(in) :: p_left,
+!!               real(in) :: p_right, 
+!!               real(in) :: e_left,
+!!               real(in) :: e_right, 
+!!               real(in) :: ei_left,
+!!               real(in) :: ei_right,
+!!               real(in) :: game_left,
+!!               real(in) :: game_right,
+!!               real(in) :: gamc_left,
+!!               real(in) :: gamc_right,
+!!               real(in) :: grav_left, 
+!!               real(in) :: grav_right,
+!!               real(in) :: dt,
+!!               real(inout) :: rho_flux, 
+!!               real(inout) :: u_flux, 
+!!               real(inout) ::ut_flux, 
+!!               real(inout) :: utt_flux, 
+!!               real(inout) :: e_flux, 
+!!               real(inout) :: ei_flux)
+!!
+!! DESCRIPTION
+!!
+!!  An approximate-flux Riemann solver that implements the HLLE 
+!!  (Harten-Lax-Van Leer-Einfeldt) algorithm.  This is used in shocks
+!!  to avoid carbuncle pheonomenon or odd-even decoupling.  In contrast
+!!  to other Riemann solvers, which find an approximation to the pressure
+!!  and density at the contact discontinuity, HLLE approximates the 
+!!  largest and smallest signal velocities (Einfeldt 1998).
+!!
+!!  Given the states on the left and right of the interface, compute the
+!!  fluxes through the interface.  
+!!
+!!  see Einfeldt, B., Munz, C.D., Roe, P.L., Sjoegren, B., 1991, JCP, 92, 273
+!!
+!!      Einfeldt, B., 1988, SIAM JNA, 25, 294
+!!
+!!      Roe, P.L., 1981, JCP, 43, 357
+!!
+!!      Einfeldt, B., 1988, in "Shock Tubes and Waves", ed. H. Groenig, 
+!!         Proceedings of the Sixteenth Int.Symp. on Shock Tubes and Waves, 
+!!         Aachen July 26-31, 1987, p. 671
+!!
+!!   (equation numbers refer to the first reference, unless otherwise noted)
+!!
+!!
+!! NOTES
+!! 
+!!  -- This operates on the zone average values to the left and the
+!!     right of the interface, *NOT* the reconstructed interface values
+!!     as returned from states.  Since we are only applying this inside 
+!!     shocks, this is not really a problem.
+!!
+!!  -- The fluxes from the previous Riemann solver should be passed in, 
+!!     and if the right conditions are met, they will be replaced with the 
+!!     appropriate HLLE fluxes.  There is no pressure 'flux', so pav from 
+!!     the regular Riemann solver will be used.
+!!
+!!  -- We ignore the grid velocity in here.
+!!
+!!  -- This code is adapted from AMRA, http://www.camk.edu.pl/~tomek/AMRA/
+!!
+!! ARGUMENTS
+!!
+!! rho_left:  
+!! rho_right: 
+!! u_left:
+!! u_right: 
+!! ut_left: 
+!! ut_right: 
+!! utt_left:
+!! utt_right: 
+!! p_left:
+!! p_right: 
+!! e_left:
+!! e_right: 
+!! ei_left:
+!! ei_right:
+!! game_left:
+!! game_right:
+!! gamc_left:
+!! gamc_right:
+!! grav_left: 
+!! grav_right:
+!! dt:
+!! rho_flux: 
+!! u_flux: 
+!! ut_flux: 
+!! utt_flux: 
+!! e_flux: 
+!! ei_flux:
+!!
+!!
+!!  
+!!***
+
+subroutine riemann_roe(&
+                       rho_left,  rho_right,  &
+                       u_left,    u_right,    &
+                       ut_left,   ut_right,   &
+                       utt_left,  utt_right,  &
+                       p_left,    p_right,    &
+                       e_left,    e_right,    &
+                       ei_left,   ei_right,   &
+                       game_left, game_right, &
+                       gamc_left, gamc_right, &
+                       xn_left,   xn_right,   &
+                       grav_left, grav_right, &
+                       dt,                    &
+                       rho_flux, u_flux, ut_flux, utt_flux, &
+                       pav, e_flux, ei_flux, xnav_flux)
+
+  use Hydro_data, ONLY : hy_small, hy_numXn
+
+  implicit none
+
+  real, INTENT(in) :: rho_left, rho_right
+  real, INTENT(in) :: u_left, u_right
+  real, INTENT(in) :: ut_left, ut_right
+  real, INTENT(in) :: utt_left, utt_right
+  real, INTENT(in) :: p_left, p_right
+  real, INTENT(in) :: e_left, e_right
+  real, INTENT(in) :: ei_left, ei_right
+  real, INTENT(in) :: game_left, game_right
+  real, INTENT(in) :: gamc_left, gamc_right
+  real, INTENT(in) :: xn_left(hy_numXn), xn_right(hy_numXn)
+  real, INTENT(in) :: grav_left, grav_right
+  real, INTENT(in) :: dt
+
+  real, INTENT(inout) :: rho_flux, u_flux, ut_flux, utt_flux, &
+                         pav, e_flux, ei_flux, xnav_flux(hy_numXn)
+
+ real(KIND=8) :: rDenRt, lDenRt, h_L, h_R
+ real(KIND=8) :: uBar, gamcBar, hBar, aBar, utBar, uttBar, vBar, pBar
+ real(KIND=8) :: lamda1, lamda2, lamda3
+ real(KIND=8) :: diff1, diff2, diff3, diff4, diff5, diff6, diff5Bar
+ real(KIND=8), dimension(5,5) :: K, DV, dudv, dvdu, INTER, DU
+ real(KIND=8), dimension(5) :: alpha, lamda
+ real(KIND=8), dimension(5,1) :: DiffVec, flxVec
+ real(KIND=8) :: rhoSum, uSum, utSum, uttSum, eSum, p_flux, as_left, as_right, rssi, e_L, e_R, ei_L, ei_R
+ logical :: preCond = .false.
+ integer :: i
+ real(KIND=8) :: Mr, del, tau, omega, S1, S2, S3, eintBar, rhoBar, Mloc
+ real(KIND=8), parameter  :: Mcut = 1.0e-4
+
+ K = 0.e0
+ DV = 0.e0
+ dudv = 0.e0
+ dvdu = 0.e0
+
+
+
+
+ !write(*,*) "IC", rho_left, rho_right, u_left, u_right, p_left, p_right, e_left, e_right
+ alpha = 0.e0
+ lamda = 0.e0
+  
+ lDenRt = sqrt(rho_left)
+ rDenRt = sqrt(rho_right)
+ rssi = 1.e0/(lDenRt+rDenRt)
+ rhoBar = sqrt(rho_left * rho_right)!(rho_left*lDenRt + rho_right*rDenRt)*rssi
+ h_L = (gamc_left/(gamc_left-1.e0)) * p_left/rho_left + 0.5e0*(u_left**2 + ut_left**2 + utt_left**2)
+ h_R = (gamc_right/(gamc_right-1.e0)) * p_right/rho_right + 0.5e0*(u_right**2 + ut_right**2 + utt_right**2)
+ gamcBar = (gamc_left+gamc_right)/2.e0 
+
+ e_L = e_left  * rho_left
+ e_R = e_right * rho_right
+
+ ei_L = ei_left * rho_left
+ ei_R = ei_right*rho_right
+
+ !write(*,*) "Energies", e_L, e_R
+
+!Compute Roe averages as done in Toro 11.60
+uBar = (lDenRt*u_left  + rDenRt*u_right)/(lDenRt+rDenRt)
+utBar = (lDenRt*ut_left  + rDenRt*ut_right)/(lDenRt+rDenRt)
+uttBar = (lDenRt*utt_left  + rDenRt*utt_right)/(lDenRt+rDenRt)
+eintBar = (lDenRt*ei_L + rDenRt * ei_R) / (lDenRt+rDenRt)
+vBar = uBar**2 + utBar**2 + uttBar**2
+as_left = sqrt(gamc_left*p_left/rho_left)
+as_right = sqrt(gamc_right*p_right/rho_right)
+pBar = (lDenRt*p_left  + rDenRt*p_right)/(lDenRt+rDenRt)
+hBar = (lDenRt*h_L + rDenRt*h_R)/(lDenRt+rDenRt)
+!aBar = sqrt((gamcBar-1.e0)*(hBar - 0.5e0 * vBar))
+!aBar = sqrt((lDenRt*as_left**2 + rDenRt*as_right**2)*rssi &
+       !+ 0.5*lDenRt*rDenRt*rssi**2 *(u_right - u_left)**2 )
+  aBar = sqrt((gamcBar-1.e0)*eintBar + (gamcBar-1.e0)*rhoBar*((eintBar+pBar)/rhoBar))
+  !write(*,*) "aBar = ", aBar
+  Mloc = (abs(uBar)+abs(utBar) + abs(uttBar))/aBar
+
+
+
+!write(*,*) "test", aBar, gamcBar, hBar, vBar
+!write(*,*) lDenRt, h_L, rDenRt, h_R, e_right, p_right, rho_right
+!Compute lambdas accourding to 11.58
+
+!if(.NOT. preCond) then
+  lamda(1) = uBar-aBar
+  lamda(2) = uBar
+  lamda(3) = uBar
+  lamda(4) = uBar
+  lamda(5) = uBar+aBar
+
+
+  !Right eigenvectors according to 11.59
+
+  K(1,1) = 1.e0
+  K(1,2) = (uBar-aBar)
+  K(1,3) = (utBar)
+  K(1,4) = (uttBar)
+  K(1,5) = (hBar-uBar*aBar)
+
+
+  K(2,1) = 1.e0
+  K(2,2) = uBar
+  K(2,3) = utBar
+  K(2,4) = uttBar
+  K(2,5) = 0.5*vBar
+
+  K(3,3) = 1.e0
+  K(3,5) = utBar
+
+  K(4,4) = 1.e0
+  K(4,5) = uttBar
+
+
+  K(5,1) = 1.e0
+  K(5,2) = (uBar+aBar)
+  K(5,3) = utBar
+  K(5,4) = uttBar
+  K(5,5) = hBar+uBar*aBar
+   
+   MLoc = 1.e0
+
+  !Compute alphas according to 11.68-11.70
+  diff1 = min(Mloc,1.e0)*(rho_right-rho_left)
+  diff2 = min(Mloc,1.e0)*(u_right*rho_right-u_left*rho_left)
+  diff3 = min(Mloc,1.e0)*(ut_right*rho_right-ut_left*rho_left)
+  diff4 = min(Mloc,1.e0)*(utt_right*rho_right-utt_left*rho_left)
+  diff5 =  min(Mloc,1.e0)*(e_R-e_L)
+  diff6 = min(Mloc,1.e2)*(ei_right-ei_left)
+  diff5Bar = diff5 - (diff3 - utBar*diff1)*utBar - (diff4 - uttBar*diff1)*uttBar
+  !write(*,*) 'diffs', diff1, diff2, diff3, diff4, diff5
+
+
+  !write(*,*) gamcBar, aBar, hBar, uBar
+
+  alpha(2) = ((gamcBar - 1.e0) / (aBar**2)) * (diff1*(hBar-uBar**2)+uBar*diff2 - diff5Bar)
+  alpha(1) = (1.e0/(2.e0*aBar))*(diff1*(uBar+aBar)-diff2-aBar*alpha(2))
+  alpha(3) = diff3-utBar*diff1
+  alpha(4) = diff4-uttBar*diff1
+  alpha(5) = diff1 - (alpha(1)+alpha(2))
+  !write(*,*) 'alphas', alpha(1), alpha(2), alpha(3), alpha(4), alpha(5)
+  !write(*,*) 'lambdas', lamda(1), lamda(2), lamda(3), lamda(4), lamda(5)
+  !write(*,*)  'ks', K(1,1), K(2,1), K(3,1), K(4,1), K(5,1)
+  !write(*,*)  'ks', K(1,2), K(2,2), K(3,2), K(4,2), K(5,2)
+  !write(*,*)  'ks', K(1,3), K(2,3), K(3,3), K(4,3), K(5,3)
+  !write(*,*)  'ks', K(1,4), K(2,4), K(3,4), K(4,4), K(5,4)
+  !write(*,*)  'ks', K(1,5), K(2,5), K(3,5), K(4,5), K(5,5)
+
+
+   
+  ! Finally, the fluxes as computed by 11.29
+
+    rhoSum = 0.e0
+    uSum = 0.e0
+    utSum = 0.e0
+    uttSum = 0.e0
+    eSum = 0.e0
+  Mloc = (abs(uBar)+abs(utBar) + abs(uttBar))/aBar
+
+
+    do i = 1,5
+      rhoSum = rhoSum + alpha(i) * abs(lamda(i)) * K(i,1)
+      uSum =  uSum  + alpha(i) * abs(lamda(i)) * K(i,2)
+      !write(*,*) 'usumllop',uSum, K(i,2), alpha(i), abs(lamda(i))
+
+      utSum =  utSum  + alpha(i) * abs(lamda(i)) * K(i,3)
+      uttSum =  uttSum  + alpha(i) * abs(lamda(i)) * K(i,4)
+      ESum =  ESum  + alpha(i) * abs(lamda(i)) * K(i,5)
+
+    enddo
+
+
+ rho_flux = 0.5e0*((rho_left*u_left + rho_right*u_right)) -0.5e0 * rhoSum 
+
+ 
+ u_flux = 0.5e0*((rho_left*u_left**2) + (rho_right*u_right**2)) - 0.e50 * uSum
+!write(*,*) "rhoSum", 0.5e0*((rho_left*u_left + rho_right*u_right)), rhoSum
+!write(*,*) 'Roe3', 0.5e0*(rho_left*u_left + rho_right*u_right),  rhoSum
+#if N_DIM >= 2
+     ut_flux = 0.5e0*( rho_left*ut_left*u_left + rho_right*ut_right*u_right) &
+     -0.5e0 * utSum
+#else
+     ut_flux = 0.e0
+#endif
+
+#if N_DIM == 3
+     utt_flux = 0.5e0*( rho_left*ut_left*u_left + rho_right*ut_right*u_right) &
+     -0.5e0 * utSum
+#else
+     utt_flux = 0.e0
+#endif
+
+     e_flux = 0.5e0*(u_left*(e_L+p_left)+u_right*(e_R+p_right)) &
+     -0.5*ESum
+
+     pav = pBar
+     !ei_flux = e_flux - u
+
+
+    !write(*,*) 'fluxes1', rho_flux, u_flux, ut_flux, e_flux, eSum, rhoSum
+
+
+
+if(preCond) then
+
+  Mr = 5.e-4
+  !aBar = sqrt(((gamcBar-1.e0)*eintBar)
+  
+  !if(Mloc .eq. Mcut) Mloc = 1.e0
+
+  del = (1.e0/(min(1.e0, max(Mloc,Mcut))))-1.e0
+
+  tau = sqrt((aBar**2 / Mr**2)+((aBar**2/Mr**2)-uBar**2)*del**2)
+  lamda(1) = uBar - tau
+  lamda(2) = uBar + tau
+  omega = del/(1.e0+del**2)
+  S1 = -(rhoBar/(2.e0*aBar*tau))*((aBar+omega*Mr*lamda(2))*abs(lamda(1)) &
+        - (aBar+omega*Mr*lamda(1))*abs(lamda(2)))
+
+
+  S2 = - (1.e0 / (2.e0*rhoBar*aBar*tau*Mr**2)) * ((aBar-omega*Mr*lamda(2))*abs(lamda(1)) &
+        - (aBar-omega*Mr*lamda(1))*abs(lamda(2)))
+
+  S3 = (abs(lamda(1))+abs(lamda(2)))/(2.e0*(1.e0+del**2)) + &
+      (omega*del*uBar*(abs(lamda(2))-abs(lamda(1))))/(2.e0*tau)
+
+
+  DV(1,1) = abs(uBar)
+  DV(1,2) = S1
+  DV(1,5) = (S3 - abs(uBar))/aBar**2
+
+  DV(2,2) = S3
+  DV(2,3) = 0
+  DV(2,4) = 0
+  DV(2,5) = S2
+
+
+  DV(3,3) = abs(uBar)
+
+  DV(4,4) = abs(uBar)
+  
+  DV(5,2) = aBar**2 * S1 
+  DV(5,5) = S3 
+
+
+ dvdu(1,1) = 1.e0
+ dvdu(2,1) = -uBar/rhoBar
+ dvdu(3,1) = -utBar/rhoBar
+ dvdu(4,1) = -uttBar/rhoBar
+ dvdu(5,1) = -eintBar+eintBar*gamcBar-Mr**2*rhoBar*uBar**2*(1.0E0/2.0E0)-Mr**2*rhoBar*utBar**2*&
+              (1.0E0/2.0E0)-Mr**2*rhoBar*uttBar**2*(1.0E0/2.0E0)+ &
+              Mr**2*gamcBar*rhoBar*uBar**2*(1.0E0/2.0E0)+Mr**2*gamcBar*rhoBar &
+              *utBar**2*(1.0E0/2.0E0)+Mr**2*gamcBar*rhoBar*uttBar**2*(1.0E0/2.0E0)
+
+ dvdu(2,2) = 1.e0/rhoBar
+ dvdu(2,5) = -(gamcBar - 1.e0)*rhoBar*Mr**2*uBar
+
+ dvdu(3,3) = 1.e0/rhoBar
+ dvdu(3,5) = -(gamcBar - 1.e0)*rhoBar*Mr**2*utBar
+ 
+
+ dvdu(4,4) = 1.e0/rhoBar
+ dvdu(4,5) = -(gamcBar - 1.e0)*rhoBar*Mr**2*uttBar
+
+ dvdu(5,5) = (gamcBar-1.e0)*rhoBar
+
+!write(*,*) "dvdu" 
+!write(*,*) dvdu(1,:)
+!write(*,*) dvdu(2,:)
+!write(*,*) dvdu(3,:)
+!write(*,*) dvdu(4,:)
+!write(*,*) dvdu(5,:)
+
+
+
+dudv(1,1) = 1.e0
+dudv(2,1) = uBar
+dudv(3,1) = utBar
+dudv(4,1) = uttBar
+dudv(5,1) = 0.5e0*Mr**2*(uBar**2+utBar**2+uttBar**2)-(((gamcBar-1.e0)*eintBar)/((gamcBar-1.e0)*rhoBar))
+
+dudv(2,2) = rhoBar
+dudv(5,2) = rhoBar*uBar*Mr**2
+
+dudv(3,3)= rhoBar
+dudv(5,3)= rhoBar*utBar*Mr**2
+
+dudv(4,4) = rhoBar
+dudv(5,4) = rhoBar * uttBar * Mr**2
+
+dudv(5,5) = 1.e0 / ((gamcBar-1.e0)*rhoBar)
+
+
+!write(*,*) "dudv" 
+!write(*,*) dudv(1,:)
+!write(*,*) dudv(2,:)
+!write(*,*) dudv(3,:)
+!write(*,*) dudv(4,:)
+!write(*,*) dudv(5,:)
+
+
+!write(*,*) "dv" 
+!write(*,*) DV(1,:)
+!write(*,*) DV(2,:)
+!write(*,*) DV(3,:)
+!write(*,*) DV(4,:)
+!write(*,*) DV(5,:)
+
+INTER = MATMUL(DV, dvdu)
+
+DU = MATMUL(dudv,INTER)
+
+
+
+DiffVec(1,1) = diff1
+DiffVec(2,1) = diff2
+DiffVec(3,1) = diff3
+DiffVec(4,1) = diff4
+DiffVec(5,1) = diff5
+
+
+flxVec = MATMUL(DU,DiffVec)
+!write(*,*) "DU" 
+!write(*,*) DU(1,:)
+!write(*,*) DU(2,:)
+!write(*,*) DU(3,:)
+!write(*,*) DU(4,:)
+!write(*,*) DU(5,:)
+!write(*,*) 'diff', diff1, diff2, diff3, diff4, diff5
+
+
+rhoSum = Mr*flxVec(1,1)
+uSum   = Mr*flxVec(2,1)
+utSum  = Mr*flxVec(3,1)
+uttBar = Mr*flxVec(4,1)
+eSum   = Mr*flxVec(5,1)
+ 
+
+!write(*,*) 'diffs', DiffVec(1,1), DiffVec(2,1), DiffVec(3,1), DiffVec(4,1), DiffVec(5,1)
+
+
+
+
+ rho_flux = 0.5e0*((rho_left*u_left + rho_right*u_right)) - 0.5e0 * rhoSum 
+
+ 
+ u_flux = 0.5e0*((rho_left*u_left**2) + (rho_right*u_right**2)) - 0.e50 * uSum
+!write(*,*) "rhoSum", 0.5e0*((rho_left*u_left + rho_right*u_right)), rhoSum
+!write(*,*) 'Roe3', 0.5e0*(rho_left*u_left + rho_right*u_right),  rhoSum
+#if N_DIM >= 2
+     ut_flux = 0.5e0*( rho_left*ut_left*u_left + rho_right*ut_right*u_right) &
+     -0.5e0 * utSum
+#else
+     ut_flux = 0.e0
+#endif
+
+#if N_DIM == 3
+     utt_flux = 0.5e0*( rho_left*ut_left*u_left + rho_right*ut_right*u_right) &
+     -0.5e0 * utSum
+#else
+     utt_flux = 0.e0
+#endif
+
+     e_flux = 0.5e0*(u_left*(e_L+p_left)+u_right*(e_R+p_right)) &
+     -0.5*ESum
+
+     p_flux = (gamcBar-1)*(e_flux - 0.5e0*rho_flux*(u_flux**2+ut_flux**2+utt_flux**2))
+
+     ei_flux = e_flux-(rho_flux*0.5e0*(uBar**2 + utBar**2 + uttBar**2))
+
+     pav = pBar
+
+  endif
+
+
+  !write(*,*) 'fluxes2', rho_flux, u_flux, ut_flux, e_flux, ei_flux, pav
+
+
+  ! Set average species
+  do i=1,hy_numXn
+     xnav_flux(i) = 0.5e0*((rho_left*xn_left(i)*u_left + rho_right*xn_right(i)*u_right)) - 0.5e0 * rhoSum 
+  enddo
+
+end subroutine riemann_roe
diff -Naur ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/PPM.h source/physics/Hydro/HydroMain/split/PPM/PPM.h
--- ../../../archive/FLASH4.6.2-hamr/source/physics/Hydro/HydroMain/split/PPM/PPM.h	2021-02-22 23:57:26.563113166 -0500
+++ source/physics/Hydro/HydroMain/split/PPM/PPM.h	2021-02-14 18:14:58.852204830 -0500
@@ -9,4 +9,12 @@
 #define UPDATE_BOUND 1
 #define UPDATE_ALL 2
 
-
+!!!!!-----------------------------!!
+!!!!!    RIEMANN SOLVER FLAGS     !!  
+!!!!!-----------------------------!!
+!!!#define EXACTRS 1
+!!!#define HLLE    2
+!!!#define AUSMP   3
+!!!#define AUSMPUP 4
+!!!#define AUSMPUPIT 5
+!!!#define ROEP 6
--- ../../../archive/FLASH4.6.2-hamr/bin/setup_shortcuts.txt	2021-02-22 23:57:26.416108859 -0500
+++ bin/setup_shortcuts.txt	2021-02-22 21:49:01.260527707 -0500
@@ -47,6 +47,12 @@
 chombo_ug:-unit=Grid/GridMain/Chombo/UG:-index-reorder:Grid=Chombo:-maxblocks=1:-nofbs:-makefile=chombo:chomboCompatibleHydro=True
 chombo_amr:-unit=Grid/GridMain/Chombo/AMR:-index-reorder:Grid=Chombo:-nofbs:-makefile=chombo:chomboCompatibleHydro=True
 
+# for multiresolution-driven adaptive mesh refinement
+amr_wvlt:--with-unit=Grid/GridSolvers/Multiresolution
+
+# for hybrid adaptive multiresolution
+mrppm:--with-unit=physics/Hydro/HydroMain/split/PPM/mrPPMKernel
+
 # pm4dev_clean indicates a version of Paramesh closer to the one
 # that can be downloaded from sourceforge.  pm4dev indicates a 
 # modified version of Paramesh that includes a more scalable way
